<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第一人称迷宫驾驶 First-Person Maze Driver</title>
    <!--
    ============================================================================
    ## README：第一人称迷宫驾驶 (First-Person Maze Driver) - v5.2 清晰地面版 ##
    ============================================================================

    这是一款面向中老年用户的、极简交互的第一人称3D迷宫驾驶游戏。
    v5.2 版本根据用户反馈，优化了地面纹理的显示效果，使其更加清晰锐利。

    ### v5.2 更新内容 (What's New in v5.2)
    1.  **清晰瓷砖地面 (Sharper Tiled Ground)**:
        * 调整了地面纹理的渲染方式，禁用了默认的模糊/平滑效果 (`LinearFilter`)。
        * 现在地面瓷砖的边缘变得非常清晰锐利 (`NearestFilter`)，呈现像素风格，有效避免了因纹理模糊可能导致的视觉疲劳或眩晕感。
    2.  **全新瓷砖地面 (New Tiled Ground)**:
        * 地面从原来的纯色更新为黑白棋盘格瓷砖纹理。这种纹理不仅美观，还能更好地帮助玩家感知移动和空间尺度。
    3.  **终点特殊纹理 (Goal Wall Texture)**: 
        * 在每个关卡的终点格子周围的墙面上，部署了用户提供的精美花卉浮雕纹理。这为终点创造了一个独特且华丽的视觉标志。
    4.  **动态天空盒 (Dynamic Skybox)**:
        * 游戏场景的天空不再是单调的纯色，而是增加了一个带有动态白云的天空背景，使整个世界看起来更加开阔和真实。

    ### 玩法说明 (How to Play)
    1.  **启动游戏**: 选择语言，输入昵称和性别，进入主菜单。
    2.  **选择模式**:
        * **通关模式 (Campaign Mode)**: 按顺序挑战15个全新设计的复杂关卡。
        * **自由模式 (Free Mode)**: 自由选择任意关卡进行练习。
    3.  **开始驾驶**:
        * 游戏开始时，会显示一个巨大的俯瞰地图。点击地图，它会缩小并固定在右上角。
    4.  **路口决策 (Intersection)**:
        * 在迷宫的**任何一格**，车辆都会停下等待您的指令。
        * 地面上会出现一个发光的箭头地标 (Landmark)，默认指向车辆当前朝向。
    5.  **选择方向**:
        * 按下 `D` 键，地面箭头会**向右转90度**。
        * 按下 `A` 键，地面箭头会**向左转90度**。
    6.  **确认前进**:
        * 按下 `空格 (Space)` 键确认。车辆会平滑地转向新方向，然后**行驶一格**。
    
    ### 键位 (Controls)
    * `A` : 预备向左转90度 (Prepare Turn Left)。
    * `D` : 预备向右转90度 (Prepare Turn Right)。
    * `空格 (Space)`: 确认并前进 (Confirm & Move)。
    * `ESC`: 呼出/关闭菜单 (Toggle Menu)。
    * `鼠标左键`: 点击UI元素 (Click UI Elements)。

    ============================================================================
    -->
    <style>
        :root {
            --bg-color: #f0f8ff; /* AliceBlue - a very light blue sky */
            --text-color: #333333; /* Dark Grey for text */
            --primary-color: #007bff; /* Bright Blue */
            --highlight-color: #28a745; /* Green */
            --wall-color-ns: #f5deb3; /* Wheat - for North-South walls */
            --wall-color-ew: #faf0e6; /* Linen - slightly lighter for East-West walls */
            --floor-color: #E0E0E0; /* Fallback color, not really used with texture */
            --landmark-color: #ffc107; /* Amber */
            --start-color: #007bff;
            --goal-color: #dc3545; /* Red */
            --font-size-normal: 18px;
            --font-size-large: 22px;
            --font-size-xlarge: 28px;
            --minimap-scale: 1; /* 小地图缩放比例 */
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: var(--font-size-normal);
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        .hud {
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        #top-hud {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        #bottom-hud {
            text-align: center;
            padding-bottom: 40px;
        }

        #choice-prompt {
            background-color: rgba(255, 255, 255, 0.8);
            color: var(--text-color);
            padding: 15px 25px;
            border-radius: 15px;
            border: 2px solid var(--primary-color);
            font-size: var(--font-size-large);
            font-weight: bold;
            display: none; /* Initially hidden */
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        #minimap-container {
            position: fixed;
            background-color: rgba(255, 255, 255, 0.8);
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            transition: all 0.5s ease-in-out;
            z-index: 10;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.5);
        }

        #minimap-container.big-map {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80vmin;
            height: 80vmin;
            cursor: pointer;
        }

        #minimap-container.small-map {
            top: 20px;
            right: 20px;
            width: calc(25vmin * var(--minimap-scale));
            height: calc(25vmin * var(--minimap-scale));
            max-width: calc(250px * var(--minimap-scale));
            max-height: calc(250px * var(--minimap-scale));
            cursor: default;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        /* Modals and Menus */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background-color: white;
            color: var(--text-color);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid var(--primary-color);
            text-align: center;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 0 25px rgba(0, 123, 255, 0.5);
        }

        .modal-content h2 {
            font-size: var(--font-size-xlarge);
            margin-top: 0;
            margin-bottom: 30px;
            color: var(--primary-color);
        }
        
        .modal-content p {
            font-size: var(--font-size-normal);
            margin-bottom: 20px;
        }

        .modal-content input, .modal-content select {
            width: 80%;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 10px;
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            color: var(--text-color);
            font-size: var(--font-size-normal);
            min-height: 44px;
        }

        .modal-content button {
            padding: 15px 0;
            border-radius: 10px;
            border: none;
            background-color: var(--primary-color);
            color: white;
            font-size: var(--font-size-large);
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 80%;
            max-width: 300px;
            min-height: 50px;
            margin: 10px auto;
            display: block;
        }

        .modal-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.4);
        }
        
        #results-medal {
            font-size: 80px;
            margin: 20px 0;
        }
        
        #results-title {
            color: var(--highlight-color);
        }

        #dev-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 20;
            pointer-events: auto;
            display: none;
        }
        #dev-panel h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        #dev-panel select {
            min-height: 44px;
        }

        #settings-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.1);
            border: none;
            color: var(--text-color);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #settings-panel {
            display: none;
        }

        .settings-group {
            text-align: left;
            margin-bottom: 20px;
        }
        .settings-group label {
            display: block;
            margin-bottom: 10px;
        }
        .settings-group select, .settings-group input[type="range"] {
            width: 100%;
        }

        #level-select-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
            max-height: 50vh;
            overflow-y: auto;
        }

        #level-select-grid button {
            min-width: 60px;
            width: 100%;
            padding: 10px;
        }

        #level-select-grid button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        .lang-en { display: none; }

    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-container">
        <div id="top-hud" class="hud">
        </div>
        <div id="bottom-hud" class="hud">
            <div id="choice-prompt"></div>
        </div>
    </div>

    <div id="minimap-container">
        <canvas id="minimap-canvas"></canvas>
    </div>
    
    <button id="settings-button">⚙️</button>

    <div id="startup-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 data-lang-zh="欢迎来到迷宫驾驶" data-lang-en="Welcome to Maze Driver">欢迎来到迷宫驾驶</h2>
            <div class="settings-group">
                <label for="initial-language-select" data-lang-zh="语言 / Language" data-lang-en="语言 / Language">语言 / Language</label>
                <select id="initial-language-select">
                    <option value="zh">中文</option>
                    <option value="en">English</option>
                </select>
            </div>
            <p data-lang-zh="为了更好地称呼您，请输入您的信息：" data-lang-en="To get started, please enter your info:">为了更好地称呼您，请输入您的信息：</p>
            <input type="text" id="nickname-input" data-lang-placeholder-zh="请输入您的昵称" data-lang-placeholder-en="Enter your nickname">
            <select id="gender-select">
                <option value="male" data-lang-zh="男" data-lang-en="Male">男</option>
                <option value="female" data-lang-zh="女" data-lang-en="Female">女</option>
                <option value="other" data-lang-zh="其他" data-lang-en="Other">其他</option>
            </select>
            <button id="start-game-btn" data-lang-zh="开始游戏" data-lang-en="Start Game">开始游戏</button>
        </div>
    </div>

    <div id="main-menu-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="welcome-message"></h2>
            <button id="campaign-mode-btn" data-lang-zh="通关模式" data-lang-en="Campaign Mode">通关模式</button>
            <button id="free-mode-btn" data-lang-zh="自由模式" data-lang-en="Free Mode">自由模式</button>
        </div>
    </div>
    
    <div id="level-complete-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="results-title"></h2>
            <div id="results-medal"></div>
            <p id="results-stats"></p>
            <p id="results-quote"></p>
            <button id="next-level-btn" data-lang-zh="下一关" data-lang-en="Next Level">下一关</button>
            <button id="main-menu-btn" data-lang-zh="返回主菜单" data-lang-en="Main Menu">返回主菜单</button>
        </div>
    </div>

    <div id="settings-panel" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="设置" data-lang-en="Settings">设置</h2>
            <div class="settings-group">
                <label for="language-select" data-lang-zh="语言" data-lang-en="Language">语言</label>
                <select id="language-select">
                    <option value="zh">中文</option>
                    <option value="en">English</option>
                </select>
            </div>
            <div class="settings-group">
                <label for="font-size-slider" data-lang-zh="字体大小" data-lang-en="Font Size">字体大小</label>
                <input type="range" id="font-size-slider" min="0.8" max="1.5" step="0.1" value="1">
            </div>
            <div class="settings-group">
                <label for="minimap-size-slider" data-lang-zh="小地图大小" data-lang-en="Minimap Size">小地图大小</label>
                <input type="range" id="minimap-size-slider" min="1" max="1.414" step="0.01" value="1">
            </div>
            <div class="settings-group">
                <label for="helper-text-toggle" data-lang-zh="辅助文字" data-lang-en="Helper Text">辅助文字</label>
                <select id="helper-text-toggle">
                    <option value="on" data-lang-zh="开启" data-lang-en="On">开启</option>
                    <option value="off" data-lang-zh="关闭" data-lang-en="Off">关闭</option>
                </select>
            </div>
            <button id="close-settings-btn" data-lang-zh="关闭" data-lang-en="Close">关闭</button>
        </div>
    </div>

    <div id="pause-menu-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="暂停菜单" data-lang-en="Pause Menu">暂停菜单</h2>
            <button id="resume-game-btn" data-lang-zh="返回游戏" data-lang-en="Resume Game">返回游戏</button>
            <button id="level-select-btn" data-lang-zh="选择关卡" data-lang-en="Select Level">选择关卡</button>
            <button id="reset-game-btn" data-lang-zh="重置游戏" data-lang-en="Reset Game">重置游戏</button>
            <button id="pause-to-main-menu-btn" data-lang-zh="返回主菜单" data-lang-en="Main Menu">返回主菜单</button>
        </div>
    </div>

    <div id="level-select-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="选择关卡" data-lang-en="Select Level">选择关卡</h2>
            <div id="level-select-grid"></div>
            <button id="close-level-select-btn" data-lang-zh="返回" data-lang-en="Back">返回</button>
        </div>
    </div>

    <div id="dev-panel">
        <h4 data-lang-zh="关卡快速切换" data-lang-en="Quick Level Select">关卡快速切换</h4>
        <select id="level-select"></select>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // ====================================================================
        // 全局变量和状态机 (Global Variables & State Machine)
        // ====================================================================
        
        const TILE_SIZE = 10;
        const WALL_HEIGHT = 5;
        const MOVE_SPEED = 15;
        const TURN_SPEED = Math.PI * 2;

        let scene, camera, renderer, clock;
        let player, mazeGroup, landmarksGroup, goalMarker, sceneryGroup, previewArrow;
        let minimap, minimapCtx;
        
        let gameState = 'STARTUP_MODAL';
        let gameMode = 'campaign';
        let currentLevelIndex = 0;
        let playerInfo = { nickname: 'Driver', gender: 'other' };

        let playerChoices = 0;
        let optimalChoices = 0;
        
        let targetPosition = new THREE.Vector3();
        let targetRotation = new THREE.Euler();
        let previewAngle;
        let previousGameState = '';
        let unlockedLevel = 0;

        const keyState = { 'a': false, 'd': false, 'space': false, 'escape': false };
        let keyDebounce = false;

        let wallMaterialNS, wallMaterialEW, floorMaterial, landmarkMaterial, goalWallMaterial;
        let hemisphereLight, dirLight; // DEBUG: Moved dirLight to global scope

        let currentLanguage = 'zh';

        // ====================================================================
        // 语言翻译数据 (Language Translation Data)
        // ====================================================================
        const translations = {
            zh: {
                welcome: (nickname) => `你好, ${nickname}!`,
                levelComplete: "关卡完成！",
                drivingGenius: "驾驶天才",
                greatDriver: "优秀司机",
                newDriver: "新手上路",
                quoteGenius: "完美！你就是这座城市的传奇！",
                quoteGreat: "干得漂亮！路线规划得非常出色。",
                quoteNew: "安全到达！经验丰富的选择。",
                stats: (p, o, r) => `你的步数: ${p} | 最优步数: ${o} | R值: ${r}`,
                freeModeComplete: "自由模式练习完成。",
                nextLevel: "下一关",
                finalResults: "查看最终结果",
                select: "选择",
                forward: "向前",
                turnLeft: "向左",
                turnRight: "向右",
                turnAround: "掉头",
                helperText: "按 A/D 切换, 空格确认",
                level: "关卡",
                confirmReset: "您确定要重置所有游戏数据吗？此操作无法撤销。",
                allLevelsCleared: "恭喜你！已通关所有关卡！"
            },
            en: {
                welcome: (nickname) => `Hello, ${nickname}!`,
                levelComplete: "Level Complete!",
                drivingGenius: "Driving Genius",
                greatDriver: "Great Driver",
                newDriver: "New Driver",
                quoteGenius: "Perfect! You are a legend in this city!",
                quoteGreat: "Well done! An excellent route plan.",
                quoteNew: "Arrived safely! A solid choice.",
                stats: (p, o, r) => `Your Steps: ${p} | Optimal: ${o} | R-Value: ${r}`,
                freeModeComplete: "Free mode practice complete.",
                nextLevel: "Next Level",
                finalResults: "View Final Results",
                select: "Select",
                forward: "Forward",
                turnLeft: "Turn Left",
                turnRight: "Turn Right",
                turnAround: "Turn Around",
                helperText: "Use A/D to switch, Space to confirm",
                level: "Level",
                confirmReset: "Are you sure you want to reset all game data? This action cannot be undone.",
                allLevelsCleared: "Congratulations! You have cleared all levels!"
            }
        };

        // ====================================================================
        // 关卡数据 (Level Data) - mazes_v4.js
        // ====================================================================
        const MAZE_DATA = [
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',1,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1],[1,0,0,0,1,0,1,0,1,0,1,0,0,'S',1],[1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,0,1,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,1,1],[1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,0,1,0,1,0,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,1,'S',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,'S',1,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',1,0,0,'S',1,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1],[1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1],[1,0,1,0,0,0,0,0,0,0,1,0,1,'E',0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1],[1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,'S',1,0,1,0,0,0,1,'E',1],[1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1],[1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1],[1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,'S',1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1],[1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1],[1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1],[1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1],[1,0,0,'S',1,0,0,0,1,0,1,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1],[1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,'E',1],[1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,'S',0,0,0,0,1,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,'S',0,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1],[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,0,0,0,0,'E',1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,'S',0,0,1],[1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1],[1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1],[1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1],[1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1],[1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,'E',0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,'S',1,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1],[1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1],[1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1],[1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,'E',1,0,1,0,0,0,1,0,1],[1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1],[1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1],[1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,'S',0,0,1,0,1,0,0,0,0,0,1,0,1],[1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,1,'S',1,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1],[1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
        ];
        
        const levels = MAZE_DATA.map(mazeData => {
            const grid = [];
            let start = {};
            let goal = {};
            const height = mazeData.length;
            const width = mazeData[0].length;

            for(let z = 0; z < height; z++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    const cell = mazeData[z][x];
                    if (cell === 'S') {
                        start = { x, z, dir: 'S' }; // Default dir, can be changed
                        row.push(1); // Path
                    } else if (cell === 'E') {
                        goal = { x, z };
                        row.push(1); // Path
                    } else {
                        // In your data, 1 is wall and 0 is path.
                        // In my game, 0 is wall and 1 is path. So I flip it.
                        row.push(cell === 1 ? 0 : 1);
                    }
                }
                grid.push(row);
            }
            
            if (start.x === 0) start.dir = 'E';
            else if (start.x === width - 1) start.dir = 'W';
            else if (start.z === 0) start.dir = 'S';
            else if (start.z === height - 1) start.dir = 'N';

            return { grid, start, goal };
        });

        // ====================================================================
        // 初始化函数 (Initialization)
        // ====================================================================
        
        function init() {
            scene = new THREE.Scene();
            // MODIFICATION: Set up skybox
            const loader = new THREE.CubeTextureLoader();
            const texture = loader.load([
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/px.jpg',
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/nx.jpg',
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/py.jpg',
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/ny.jpg',
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/pz.jpg',
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/nz.jpg',
            ]);
            scene.background = texture;
            scene.fog = new THREE.Fog(0xcccccc, TILE_SIZE * 5, TILE_SIZE * 20);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);
            clock = new THREE.Clock();

            hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
            hemisphereLight.position.set(0, 20, 0);
            scene.add(hemisphereLight);

            // DEBUG: Assign to global variable
            dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
            dirLight.position.set(-1, 1.75, 1);
            dirLight.position.multiplyScalar(30);
            scene.add(dirLight);

            player = new THREE.Object3D();
            scene.add(player);
            player.add(camera);

            camera.position.set(0, WALL_HEIGHT * 0.4, 0);
            camera.rotation.x = THREE.MathUtils.degToRad(-8);

            const headLight = new THREE.SpotLight(0xffffff, 10, 8 * TILE_SIZE, Math.PI / 4, 0.5, 1.5);
            headLight.position.set(0, 0, 1);
            camera.add(headLight);

            mazeGroup = new THREE.Group();
            landmarksGroup = new THREE.Group();
            sceneryGroup = new THREE.Group();
            scene.add(mazeGroup);
            scene.add(landmarksGroup);
            scene.add(sceneryGroup);
            
            minimap = document.getElementById('minimap-canvas');
            minimapCtx = minimap.getContext('2d');

            createMaterials();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            setupUI();
            updateUIText();
            
            animate();
        }

        function setupUI() {
            document.getElementById('initial-language-select').addEventListener('change', (e) => {
                currentLanguage = e.target.value;
                updateUIText();
            });

            document.getElementById('start-game-btn').addEventListener('click', () => {
                currentLanguage = document.getElementById('initial-language-select').value;
                document.getElementById('language-select').value = currentLanguage;

                const nickname = document.getElementById('nickname-input').value.trim();
                playerInfo.nickname = nickname || (currentLanguage === 'zh' ? '司机' : 'Driver');
                playerInfo.gender = document.getElementById('gender-select').value;

                document.getElementById('startup-modal').style.display = 'none';
                document.getElementById('main-menu-modal').style.display = 'flex';
                updateUIText();
                gameState = 'MAIN_MENU';
            });

            document.getElementById('campaign-mode-btn').addEventListener('click', () => {
                gameMode = 'campaign';
                currentLevelIndex = 0;
                document.getElementById('main-menu-modal').style.display = 'none';
                document.getElementById('dev-panel').style.display = 'none';
                loadLevel(currentLevelIndex);
            });

            document.getElementById('free-mode-btn').addEventListener('click', () => {
                gameMode = 'free';
                currentLevelIndex = 0;
                document.getElementById('main-menu-modal').style.display = 'none';
                setupDevPanel();
                document.getElementById('dev-panel').style.display = 'block';
                loadLevel(currentLevelIndex);
            });
            
            document.getElementById('next-level-btn').addEventListener('click', () => {
                document.getElementById('level-complete-modal').style.display = 'none';
                currentLevelIndex++;
                if (currentLevelIndex < levels.length) {
                    loadLevel(currentLevelIndex);
                } else {
                    alert(translations[currentLanguage].allLevelsCleared);
                    showMainMenu();
                }
            });
            document.getElementById('main-menu-btn').addEventListener('click', () => {
                document.getElementById('level-complete-modal').style.display = 'none';
                showMainMenu();
            });

            document.getElementById('minimap-container').addEventListener('click', () => {
                if (gameState === 'BIG_MAP') {
                    const container = document.getElementById('minimap-container');
                    container.classList.remove('big-map');
                    container.classList.add('small-map');
                    gameState = 'AT_INTERSECTION';
                    checkForTurns();
                }
            });

            document.getElementById('settings-button').addEventListener('click', () => {
                document.getElementById('settings-panel').style.display = 'flex';
            });
            document.getElementById('close-settings-btn').addEventListener('click', () => {
                document.getElementById('settings-panel').style.display = 'none';
            });
            document.getElementById('font-size-slider').addEventListener('input', (e) => {
                document.body.style.fontSize = `calc(${getComputedStyle(document.body).getPropertyValue('--font-size-normal')} * ${e.target.value})`;
            });
            document.getElementById('minimap-size-slider').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--minimap-scale', e.target.value);
            });
            document.getElementById('language-select').addEventListener('change', (e) => {
                currentLanguage = e.target.value;
                document.getElementById('initial-language-select').value = currentLanguage;
                updateUIText();
            });
            
            document.getElementById('resume-game-btn').addEventListener('click', togglePauseMenu);
            document.getElementById('pause-to-main-menu-btn').addEventListener('click', () => {
                togglePauseMenu();
                showMainMenu();
            });
            document.getElementById('level-select-btn').addEventListener('click', showLevelSelectModal);
            document.getElementById('reset-game-btn').addEventListener('click', () => {
                if(confirm(translations[currentLanguage].confirmReset)) {
                    resetGame();
                }
            });

            document.getElementById('close-level-select-btn').addEventListener('click', () => {
                document.getElementById('level-select-modal').style.display = 'none';
                document.getElementById('pause-menu-modal').style.display = 'flex';
            });
        }

        function setupDevPanel() {
            const select = document.getElementById('level-select');
            select.innerHTML = '';
            levels.forEach((_, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${translations[currentLanguage].level} ${index + 1}`;
                select.appendChild(option);
            });
            select.addEventListener('change', (e) => {
                loadLevel(parseInt(e.target.value));
            });
        }
        
        function showMainMenu() {
            gameState = 'MAIN_MENU';
            document.getElementById('main-menu-modal').style.display = 'flex';
            while(mazeGroup.children.length > 0){ mazeGroup.remove(mazeGroup.children[0]); }
            while(landmarksGroup.children.length > 0){ landmarksGroup.remove(landmarksGroup.children[0]); }
            while(sceneryGroup.children.length > 0){ sceneryGroup.remove(sceneryGroup.children[0]); }
            if(goalMarker) scene.remove(goalMarker);

            document.getElementById('minimap-container').style.display = 'none';
        }

        // ====================================================================
        // 游戏核心逻辑 (Core Game Logic)
        // ====================================================================
        
        function loadLevel(index) {
            if (index >= levels.length) {
                console.error(`Level index ${index} out of bounds!`);
                showMainMenu();
                return;
            }
            currentLevelIndex = index;
            const level = levels[index];

            playerChoices = 0;
            document.getElementById('choice-prompt').style.display = 'none';

            while(mazeGroup.children.length > 0){ mazeGroup.remove(mazeGroup.children[0]); }
            while(landmarksGroup.children.length > 0){ landmarksGroup.remove(landmarksGroup.children[0]); }
            while(sceneryGroup.children.length > 0){ sceneryGroup.remove(sceneryGroup.children[0]); }
            if(goalMarker) scene.remove(goalMarker);

            createMazeMesh(level.grid, level.goal);
            placeRoadsideObjects(level.grid);
            createGoalMarker(level.goal);
            
            const startPos = gridToWorld(level.start.x, level.start.z);
            player.position.set(startPos.x, 0, startPos.z);
            player.rotation.y = dirToAngle(level.start.dir);

            const pathInfo = findShortestPath(level);
            if (!pathInfo) {
                alert(`Error: Level ${index + 1} is unsolvable or has data issues. Skipping.`);
                console.error(`Level ${index + 1} unsolvable!`, level);
                if (gameMode === 'campaign' && currentLevelIndex + 1 < levels.length) {
                    setTimeout(() => loadLevel(currentLevelIndex + 1), 1000);
                } else {
                    showMainMenu();
                }
                return;
            }
            optimalChoices = pathInfo.choices;
            console.log(`Level ${index + 1}: Optimal Steps = ${optimalChoices}`);
            
            const minimapContainer = document.getElementById('minimap-container');
            minimapContainer.style.display = 'block';
            minimapContainer.classList.remove('small-map');
            minimapContainer.classList.add('big-map');
            
            lastPlayerGridPos = { x: -1, z: -1 }; 
            updateMinimapPlayer();
            
            gameState = 'BIG_MAP';
        }

        function gridToWorld(x, z) {
            const level = levels[currentLevelIndex];
            const gridWidth = level.grid[0].length;
            const gridHeight = level.grid.length;
            return new THREE.Vector3(
                (x - gridWidth / 2 + 0.5) * TILE_SIZE,
                0,
                (z - gridHeight / 2 + 0.5) * TILE_SIZE
            );
        }
        
        function worldToGrid(position) {
            const level = levels[currentLevelIndex];
            const gridWidth = level.grid[0].length;
            const gridHeight = level.grid.length;
            return {
                x: Math.round(position.x / TILE_SIZE + gridWidth / 2 - 0.5),
                z: Math.round(position.z / TILE_SIZE + gridHeight / 2 - 0.5)
            };
        }
        
        function dirToAngle(dir) {
            switch (dir) {
                case 'N': return Math.PI;
                case 'E': return -Math.PI / 2;
                case 'S': return 0;
                case 'W': return Math.PI / 2;
            }
            return 0;
        }

        function checkForTurns() {
            const gridPos = worldToGrid(player.position);
            const level = levels[currentLevelIndex];
            const { goal } = level;

            if (gridPos.x === goal.x && gridPos.z === goal.z) {
                gameState = 'LEVEL_COMPLETE';
                showLevelComplete();
                return;
            }

            previewAngle = player.rotation.y;
            createPreviewLandmark();
            updateChoicePrompt();
            gameState = 'AT_INTERSECTION';
        }

        function cameraShake() {
            const shakeIntensity = 0.05;
            let shakeDuration = 200; // ms
            const startTime = Date.now();

            function shake() {
                const elapsedTime = Date.now() - startTime;
                if (elapsedTime > shakeDuration) {
                    camera.position.set(0, WALL_HEIGHT * 0.4, 0);
                    return;
                }
                const progress = elapsedTime / shakeDuration;
                const shakeAmount = shakeIntensity * (1 - progress);
                const shakeX = (Math.random() - 0.5) * shakeAmount;
                const shakeY = (Math.random() - 0.5) * shakeAmount;
                camera.position.set(shakeX, WALL_HEIGHT * 0.4 + shakeY, 0);
                requestAnimationFrame(shake);
            }
            shake();
        }

        function createPreviewLandmark() {
            while(landmarksGroup.children.length > 0){ 
                landmarksGroup.remove(landmarksGroup.children[0]); 
            }

            const arrowShape = new THREE.Shape();
            const w = TILE_SIZE * 0.25;
            const h = TILE_SIZE * 0.4;
            arrowShape.moveTo(0, h);
            arrowShape.lineTo(w, 0);
            arrowShape.lineTo(w/2, 0);
            arrowShape.lineTo(w/2, -h/2);
            arrowShape.lineTo(-w/2, -h/2);
            arrowShape.lineTo(-w/2, 0);
            arrowShape.lineTo(-w, 0);
            arrowShape.closePath();
            const landmarkGeo = new THREE.ShapeGeometry(arrowShape);
            landmarkGeo.rotateX(-Math.PI / 2);

            const turnVector = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, previewAngle, 0));
            const landmarkPos = player.position.clone().add(turnVector.multiplyScalar(TILE_SIZE * 0.7));
            landmarkPos.y = 0.1;

            previewArrow = new THREE.Mesh(landmarkGeo, landmarkMaterial);
            previewArrow.position.copy(landmarkPos);
            previewArrow.rotation.y = previewAngle;
            landmarksGroup.add(previewArrow);
        }
        
        function updateChoicePrompt() {
            const prompt = document.getElementById('choice-prompt');
            const helperToggle = document.getElementById('helper-text-toggle').value;
            const lang = translations[currentLanguage];

            if (gameState !== 'AT_INTERSECTION') {
                prompt.style.display = 'none';
                return;
            }
            
            prompt.style.display = 'inline-block';
            
            const currentAngle = (player.rotation.y % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
            const targetAngle = (previewAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
            
            let angleDiff = targetAngle - currentAngle;
            if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

            let turnText = '...';
            if (Math.abs(angleDiff) < 0.1) turnText = lang.forward;
            else if (Math.abs(angleDiff - Math.PI / 2) < 0.1) turnText = lang.turnLeft;
            else if (Math.abs(angleDiff + Math.PI / 2) < 0.1) turnText = lang.turnRight;
            else if (Math.abs(angleDiff) > Math.PI - 0.1) turnText = lang.turnAround;
            
            prompt.innerHTML = `${lang.select}: ${turnText}` + (helperToggle === 'on' ? `<br><span style="font-size: 0.8em;">${lang.helperText}</span>` : '');
        }

        function setupMove() {
            const gridPos = worldToGrid(player.position);
            const moveVector = new THREE.Vector3(0, 0, -1).applyEuler(player.rotation);
            const nextGridX = gridPos.x + Math.round(moveVector.x);
            const nextGridZ = gridPos.z + Math.round(moveVector.z);
            const level = levels[currentLevelIndex];

            if (nextGridZ < 0 || nextGridZ >= level.grid.length || nextGridX < 0 || nextGridX >= level.grid[0].length || level.grid[nextGridZ][nextGridX] === 0) {
                cameraShake();
                gameState = 'AT_INTERSECTION'; 
            } else {
                playerChoices++;
                document.getElementById('choice-prompt').style.display = 'none';
                while (landmarksGroup.children.length > 0) {
                    landmarksGroup.remove(landmarksGroup.children[0]);
                }
                targetPosition.copy(gridToWorld(nextGridX, nextGridZ));
                gameState = 'DRIVING';
            }
        }

        function confirmChoice() {
            if (gameState !== 'AT_INTERSECTION') return;

            targetRotation.y = previewAngle;

            let angleDiff = targetRotation.y - player.rotation.y;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

            if (Math.abs(angleDiff) < 0.01) {
                setupMove();
            } else {
                gameState = 'TURNING';
            }
        }
        
        function showLevelComplete() {
            const modal = document.getElementById('level-complete-modal');
            const stats = document.getElementById('results-stats');
            const medalEl = document.getElementById('results-medal');
            const quoteEl = document.getElementById('results-quote');
            const nextBtn = document.getElementById('next-level-btn');
            const lang = translations[currentLanguage];
            
            if (gameMode === 'campaign') {
                unlockedLevel = Math.max(unlockedLevel, currentLevelIndex + 1);
                const R = optimalChoices > 0 ? playerChoices / optimalChoices : 1;
                let medal = '';
                let title = '';
                let quote = '';

                if (R <= 1.0) {
                    medal = '🥇';
                    title = lang.drivingGenius;
                    quote = lang.quoteGenius;
                } else if (R <= 1.5) {
                    medal = '🥈';
                    title = lang.greatDriver;
                    quote = lang.quoteGreat;
                } else {
                    medal = '🥉';
                    title = lang.newDriver;
                    quote = lang.quoteNew;
                }
                
                medalEl.textContent = medal;
                document.getElementById('results-title').textContent = title;
                stats.textContent = lang.stats(playerChoices, optimalChoices, R.toFixed(2));
                quoteEl.textContent = quote;
                
                stats.style.display = 'block';
                medalEl.style.display = 'block';
                quoteEl.style.display = 'block';

                if (currentLevelIndex >= levels.length - 1) {
                    nextBtn.textContent = lang.finalResults;
                } else {
                    nextBtn.textContent = lang.nextLevel;
                }
                nextBtn.style.display = 'inline-block';

            } else {
                document.getElementById('results-title').textContent = lang.levelComplete;
                stats.style.display = 'none';
                medalEl.style.display = 'none';
                quoteEl.textContent = lang.freeModeComplete;
                nextBtn.style.display = 'none';
            }
            
            modal.style.display = 'flex';
        }

        // ====================================================================
        // 渲染和动画 (Rendering & Animation)
        // ====================================================================
        
        function animate() {
            requestAnimationFrame(animate);
            if(gameState === 'PAUSED') return;
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            const dayNightCycle = (Math.sin(elapsedTime * 0.1) + 1) / 2;
            const nightIntensity = Math.max(0, 1 - dayNightCycle * 4);
            
            if (scene.background.isCubeTexture) {
                hemisphereLight.intensity = dayNightCycle * 1.5 + 0.2;
                dirLight.intensity = dayNightCycle * 2.0 + 0.2;
            } else {
                scene.background.setHSL(0.6, 0.7, dayNightCycle * 0.4 + 0.3);
                hemisphereLight.intensity = dayNightCycle * 2.5 + 0.5;
            }
            
            sceneryGroup.children.forEach(sceneryObject => {
                const light = sceneryObject.getObjectByName('lampLight');
                if (light) {
                    light.intensity = nightIntensity * 8;
                }
            });


            if (goalMarker) {
                goalMarker.position.y = WALL_HEIGHT + 2 + Math.sin(elapsedTime) * 0.5;
                goalMarker.rotation.y += delta * 0.2;
            }

            if (gameState === 'TURNING') {
                let angleDiff = targetRotation.y - player.rotation.y;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

                if (Math.abs(angleDiff) > 0.01) {
                    const turnStep = Math.sign(angleDiff) * TURN_SPEED * delta;
                    if (Math.abs(turnStep) >= Math.abs(angleDiff)) {
                        player.rotation.y = targetRotation.y;
                    } else {
                        player.rotation.y += turnStep;
                    }
                } else {
                    player.rotation.y = targetRotation.y;
                    setupMove();
                }
            }
            
            if (gameState === 'DRIVING') {
                const distanceToTarget = player.position.distanceTo(targetPosition);
                if (distanceToTarget > 0.01) {
                    const moveVector = targetPosition.clone().sub(player.position).normalize();
                    const moveDistance = Math.min(distanceToTarget, MOVE_SPEED * delta);
                    player.position.add(moveVector.multiplyScalar(moveDistance));
                } else {
                    player.position.copy(targetPosition);
                    gameState = 'AT_INTERSECTION';
                    checkForTurns();
                }
            }
            
            if (['DRIVING', 'TURNING', 'AT_INTERSECTION', 'BIG_MAP'].includes(gameState)) {
                updateMinimapPlayer();
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ====================================================================
        // 输入处理 (Input Handling)
        // ====================================================================
        
        function onKeyDown(event) {
            if (!event || !event.key) return;
            const key = event.key.toLowerCase();
            if (keyState[key]) return;
            keyState[key] = true;

            if (key === 'escape') {
                togglePauseMenu();
                return;
            }

            if (gameState !== 'AT_INTERSECTION') return;
            
            if (key === 'a' || key === 'd') {
                if (keyDebounce) return;
                keyDebounce = true;
                setTimeout(() => { keyDebounce = false; }, 100);

                if (key === 'd') {
                    previewAngle -= Math.PI / 2;
                } else if (key === 'a') {
                    previewAngle += Math.PI / 2;
                }
                createPreviewLandmark();
                updateChoicePrompt();
            } else if (key === ' ' || key === 'spacebar') {
                confirmChoice();
            }
        }
        
        function onKeyUp(event) {
            if (!event || !event.key) return;
            const key = event.key.toLowerCase();
            keyState[key] = false;
        }

        // ====================================================================
        // 3D迷宫与视觉生成 (3D Maze & Visuals Generation)
        // ====================================================================

        function createMazeMesh(grid, goal) {
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;

            const floorPlane = new THREE.PlaneGeometry(gridWidth * TILE_SIZE, gridHeight * TILE_SIZE);
            const floor = new THREE.Mesh(floorPlane, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            mazeGroup.add(floor);

            const wallGeo = new THREE.PlaneGeometry(TILE_SIZE, WALL_HEIGHT);

            for (let z = 0; z < gridHeight; z++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[z][x] !== 1) continue;
                    
                    const worldPos = gridToWorld(x, z);
                    const isNearGoal = Math.abs(x - goal.x) <= 1 && Math.abs(z - goal.z) <= 1 && !(x === goal.x && z === goal.z);

                    if (z > 0 && grid[z - 1][x] === 0) {
                        const material = isNearGoal && z - 1 === goal.z ? goalWallMaterial : wallMaterialNS;
                        const wall = new THREE.Mesh(wallGeo, material);
                        wall.position.set(worldPos.x, WALL_HEIGHT / 2, worldPos.z - TILE_SIZE / 2);
                        mazeGroup.add(wall);
                    }
                    if (z < gridHeight - 1 && grid[z + 1][x] === 0) {
                        const material = isNearGoal && z + 1 === goal.z ? goalWallMaterial : wallMaterialNS;
                        const wall = new THREE.Mesh(wallGeo, material);
                        wall.position.set(worldPos.x, WALL_HEIGHT / 2, worldPos.z + TILE_SIZE / 2);
                        wall.rotation.y = Math.PI;
                        mazeGroup.add(wall);
                    }
                    if (x > 0 && grid[z][x - 1] === 0) {
                        const material = isNearGoal && x - 1 === goal.x ? goalWallMaterial : wallMaterialEW;
                        const wall = new THREE.Mesh(wallGeo, material);
                        wall.position.set(worldPos.x - TILE_SIZE / 2, WALL_HEIGHT / 2, worldPos.z);
                        wall.rotation.y = Math.PI / 2;
                        mazeGroup.add(wall);
                    }
                    if (x < gridWidth - 1 && grid[z][x + 1] === 0) {
                        const material = isNearGoal && x + 1 === goal.x ? goalWallMaterial : wallMaterialEW;
                        const wall = new THREE.Mesh(wallGeo, material);
                        wall.position.set(worldPos.x + TILE_SIZE / 2, WALL_HEIGHT / 2, worldPos.z);
                        wall.rotation.y = -Math.PI / 2;
                        mazeGroup.add(wall);
                    }
                }
            }
        }

        function createGoalMarker(goalCoords) {
            const goalPos = gridToWorld(goalCoords.x, goalCoords.z);
            
            goalMarker = new THREE.Group();

            const balloonGeo = new THREE.SphereGeometry(TILE_SIZE * 0.2, 32, 32);
            const balloonMat = new THREE.MeshStandardMaterial({ color: 0xdc3545, roughness: 0.4, metalness: 0.1 });
            const balloon = new THREE.Mesh(balloonGeo, balloonMat);

            const stringMat = new THREE.LineBasicMaterial({ color: 0x555555 });
            const points = [];
            points.push(new THREE.Vector3(0, 0, 0));
            points.push(new THREE.Vector3(0, -WALL_HEIGHT, 0));
            const stringGeo = new THREE.BufferGeometry().setFromPoints(points);
            const balloonString = new THREE.Line(stringGeo, stringMat);
            
            goalMarker.add(balloon);
            goalMarker.add(balloonString);
            
            goalMarker.position.copy(goalPos);
            goalMarker.position.y = WALL_HEIGHT;
            scene.add(goalMarker);
        }
        
        function createClassicalLamp() {
            const group = new THREE.Group();
            const postMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.6, metalness: 0.4 });

            const baseGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.2, 8);
            const base = new THREE.Mesh(baseGeo, postMat);
            base.position.y = 0.1;
            group.add(base);
            
            const postGeo = new THREE.CylinderGeometry(0.15, 0.1, 3.5, 8);
            const post = new THREE.Mesh(postGeo, postMat);
            post.position.y = 1.85;
            group.add(post);

            const holderGeo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const holder = new THREE.Mesh(holderGeo, postMat);
            holder.position.set(0, 3.6, 0.3);
            group.add(holder);

            const lanternGeo = new THREE.SphereGeometry(0.4, 8, 6);
            const lightColors = [0xfffee0, 0xffffff, 0xe0e0ff, 0xffe0e0, 0xffd54f];
            const randomColor = lightColors[Math.floor(Math.random() * lightColors.length)];
            const bulbMat = new THREE.MeshBasicMaterial({ color: randomColor });
            const bulb = new THREE.Mesh(lanternGeo, bulbMat);
            bulb.position.set(0, 3.6, 0.3);
            group.add(bulb);

            const light = new THREE.PointLight(randomColor, 0, TILE_SIZE * 2, 1.5);
            light.position.copy(bulb.position);
            light.name = 'lampLight';
            group.add(light);
            
            return group;
        }

        function placeRoadsideObjects(grid) {
            const gridHeight = grid.length;
            const gridWidth = grid[0].length;

            for (let z = 0; z < gridHeight; z++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[z][x] === 0) continue;

                    const worldPos = gridToWorld(x, z);

                    if (z > 0 && grid[z - 1][x] === 0) {
                        if (x % 3 === 0) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x, 0, worldPos.z - TILE_SIZE * 0.45);
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (z < gridHeight - 1 && grid[z + 1][x] === 0) {
                       if (x % 3 === 1) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x, 0, worldPos.z + TILE_SIZE * 0.45);
                            lamp.rotation.y = Math.PI;
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (x > 0 && grid[z][x - 1] === 0) {
                        if (z % 3 === 0) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x - TILE_SIZE * 0.45, 0, worldPos.z);
                            lamp.rotation.y = Math.PI / 2;
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (x < gridWidth - 1 && grid[z][x + 1] === 0) {
                        if (z % 3 === 1) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x + TILE_SIZE * 0.45, 0, worldPos.z);
                            lamp.rotation.y = -Math.PI / 2;
                            sceneryGroup.add(lamp);
                        }
                    }
                }
            }
        }

        function createMaterials() {
            const textureLoader = new THREE.TextureLoader();

            wallMaterialNS = new THREE.MeshStandardMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--wall-color-ns')),
                roughness: 0.8,
                metalness: 0.2
            });

            wallMaterialEW = new THREE.MeshStandardMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--wall-color-ew')),
                roughness: 0.8,
                metalness: 0.2
            });
            
            // MODIFICATION: Create a tiled floor material with sharp edges
            const floorTexture = textureLoader.load('https://threejs.org/examples/textures/checker.png');
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            
            // MODIFICATION: Use NearestFilter for a sharp, pixelated look
            floorTexture.magFilter = THREE.NearestFilter;
            floorTexture.minFilter = THREE.NearestFilter;

            // The texture itself is a 2x2 checkerboard, so we repeat it many times.
            // A maze tile is TILE_SIZE x TILE_SIZE (10x10). We can make each texture tile cover half a maze tile.
            const repeatsPerMazeTile = 2;
            const largestMazeDim = 25; // Based on MAZE_DATA
            floorTexture.repeat.set(largestMazeDim * repeatsPerMazeTile, largestMazeDim * repeatsPerMazeTile);

            floorMaterial = new THREE.MeshStandardMaterial({
                map: floorTexture,
                roughness: 0.8,
                metalness: 0.1
            });

            landmarkMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--landmark-color')),
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const goalTexture = textureLoader.load('http://googleusercontent.com/file_content/1');
            goalTexture.wrapS = THREE.RepeatWrapping;
            goalTexture.wrapT = THREE.RepeatWrapping;
            goalTexture.repeat.set(1, 1);
            goalWallMaterial = new THREE.MeshStandardMaterial({
                map: goalTexture,
                roughness: 0.7,
                metalness: 0.1
            });
        }

        // ====================================================================
        // 小地图 (Minimap)
        // ====================================================================

        let lastPlayerGridPos = { x: -1, z: -1 };

        function drawMinimapBackground(grid, start, goal) {
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;
            const canvas = minimap;
            canvas.width = 500;
            canvas.height = 500;
            const ctx = minimapCtx;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cellWidth = canvas.width / gridWidth;
            const cellHeight = canvas.height / gridHeight;

            ctx.fillStyle = '#cccccc';
            for (let z = 0; z < gridHeight; z++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[z][x] === 1) {
                        ctx.fillRect(x * cellWidth, z * cellHeight, cellWidth, cellHeight);
                    }
                }
            }

            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--start-color');
            ctx.fillRect(start.x * cellWidth, start.z * cellHeight, cellWidth, cellHeight);
            
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--goal-color');
            ctx.fillRect(goal.x * cellWidth, goal.z * cellHeight, cellWidth, cellHeight);
        }

        function updateMinimapPlayer() {
            const level = levels[currentLevelIndex];
            if (!level) return;
            const { grid, start, goal } = level;
            const gridPos = worldToGrid(player.position);
            
            lastPlayerGridPos = { ...gridPos };

            drawMinimapBackground(grid, start, goal);

            const ctx = minimapCtx;
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;
            const cellWidth = ctx.canvas.width / gridWidth;
            const cellHeight = ctx.canvas.height / gridHeight;

            const playerX = (gridPos.x + 0.5) * cellWidth;
            const playerZ = (gridPos.z + 0.5) * cellHeight;

            ctx.save();
            const dirVec = new THREE.Vector3(0, 0, -1).applyEuler(player.rotation);
            const angle = Math.atan2(dirVec.z, dirVec.x);
            ctx.translate(playerX, playerZ);
            ctx.rotate(angle);
            const size = Math.min(cellWidth, cellHeight) * 0.9;
            const half = size * 0.5;
            const tail = -half * 0.6;
            ctx.beginPath();
            ctx.moveTo(half, 0);
            ctx.lineTo(tail, -half * 0.5);
            ctx.lineTo(tail,  half * 0.5);
            ctx.closePath();
            
            ctx.fillStyle = '#00ff00';
            ctx.shadowColor = 'rgba(50, 255, 50, 0.9)';
            ctx.shadowBlur = size * 0.6;

            ctx.fill();
            
            ctx.lineWidth = Math.max(1, size * 0.08);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.stroke();
            ctx.restore();
        }

        // ====================================================================
        // 寻路算法 (Pathfinding - BFS) for step counting
        // ====================================================================

        function getNeighbors(x, z, grid) {
            const neighbors = [];
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dx, dz] of dirs) {
                const newX = x + dx;
                const newZ = z + dz;
                if (newZ >= 0 && newZ < grid.length && newX >= 0 && newX < grid[0].length && grid[newZ][newX] === 1) {
                    neighbors.push({ x: newX, z: newZ });
                }
            }
            return neighbors;
        }

        function findShortestPath(level) {
            const { grid, start, goal } = level;
            const queue = [{ x: start.x, z: start.z, path: [] }];
            const visited = new Set([`${start.x},${start.z}`]);

            while (queue.length > 0) {
                const { x, z, path } = queue.shift();

                if (x === goal.x && z === goal.z) {
                    return { path, choices: path.length };
                }

                const neighbors = getNeighbors(x, z, grid);
                for (const neighbor of neighbors) {
                    const key = `${neighbor.x},${neighbor.z}`;
                    if (!visited.has(key)) {
                        visited.add(key);
                        const newPath = path.concat([{x, z}]);
                        queue.push({ ...neighbor, path: newPath });
                    }
                }
            }
            return null;
        }
        
        // ====================================================================
        // 菜单与UI逻辑 (Menu & UI Logic)
        // ====================================================================
        
        function updateUIText() {
            document.querySelectorAll('[data-lang-zh]').forEach(el => {
                const key = currentLanguage === 'zh' ? 'langZh' : 'langEn';
                if (el.dataset[key]) {
                    if (el.tagName === 'OPTION') {
                        el.textContent = el.dataset[key];
                    } else {
                        el.textContent = el.dataset[key];
                    }
                }
            });
             document.querySelectorAll('select').forEach(select => {
                select.querySelectorAll('option').forEach(option => {
                    const key = currentLanguage === 'zh' ? 'langZh' : 'langEn';
                    if (option.dataset[key]) {
                        option.textContent = option.dataset[key];
                    }
                });
            });
            document.querySelectorAll('[data-lang-placeholder-zh]').forEach(el => {
                const key = currentLanguage === 'zh' ? 'langPlaceholderZh' : 'langPlaceholderEn';
                 if (el.dataset[key]) {
                    el.placeholder = el.dataset[key];
                }
            });
            
            const welcomeMsg = document.getElementById('welcome-message');
            if (welcomeMsg) {
                welcomeMsg.textContent = translations[currentLanguage].welcome(playerInfo.nickname);
            }
            if (gameState === 'AT_INTERSECTION') {
                updateChoicePrompt();
            }
            if (document.getElementById('dev-panel').style.display === 'block') {
                setupDevPanel();
            }
        }

        function togglePauseMenu() {
            const menu = document.getElementById('pause-menu-modal');
            const isPaused = menu.style.display === 'flex';

            if (isPaused) {
                menu.style.display = 'none';
                gameState = previousGameState;
            } else {
                if(!['AT_INTERSECTION', 'DRIVING', 'TURNING', 'BIG_MAP'].includes(gameState)) return;
                previousGameState = gameState;
                gameState = 'PAUSED';
                menu.style.display = 'flex';
            }
        }

        function showLevelSelectModal() {
            const grid = document.getElementById('level-select-grid');
            grid.innerHTML = '';
            
            for (let i = 0; i < levels.length; i++) {
                const button = document.createElement('button');
                button.textContent = i + 1;
                const isUnlocked = gameMode === 'free' || i <= unlockedLevel;
                button.disabled = !isUnlocked;
                if (isUnlocked) {
                    button.onclick = () => {
                        document.getElementById('level-select-modal').style.display = 'none';
                        togglePauseMenu();
                        loadLevel(i);
                    };
                }
                grid.appendChild(button);
            }

            document.getElementById('pause-menu-modal').style.display = 'none';
            document.getElementById('level-select-modal').style.display = 'flex';
        }

        function resetGame() {
            unlockedLevel = 0;
            playerInfo = { nickname: 'Driver', gender: 'other' };
            document.getElementById('nickname-input').value = '';
            
            const modals = document.querySelectorAll('.modal-overlay');
            modals.forEach(modal => modal.style.display = 'none');
            
            document.getElementById('startup-modal').style.display = 'flex';
            gameState = 'STARTUP_MODAL';
            updateUIText();
        }
        
        // ====================================================================
        // 启动 (Boot)
        // ====================================================================
        init();

    </script>
</body>
</html>
