<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第一人称迷宫驾驶 First-Person Maze Driver</title>
    <!--
    ============================================================================
    ## README：第一人称迷宫驾驶 (First-Person Maze Driver) - v7.9 ##
    ============================================================================

    这是根据用户请求修改的版本。

    ### v7.9 更新内容 (What's New in v7.9)
    1.  **键位修改 (Controls Change)**:
        * 向前移动的按键已从 `空格 (Space)` 更改为 `W` 键。
    2.  **文本更新 (Text Update)**:
        * 游戏内所有相关的操作说明已同步更新为 `W` 键。

    ### 玩法说明 (How to Play)
    1.  **路口决策 (Intersection)**:
        * 在迷宫的任何一格，车辆都会停下。此时可以观察前方浮动的黄色箭头来决定方向。
    2.  **选择方向或前进**:
        * 按下 `D` 键，车辆会**平滑地向右转90度**。
        * 按下 `A` 键，车辆会**平滑地向左转90度**。
        * 按下 `W` 键，车辆会沿当前方向**前进一格**。
    
    ### 键位 (Controls)
    * `A`: 向左转90度 (Turn Left)。
    * `D`: 向右转90度 (Turn Right)。
    * `W`: 前进一格 (Move Forward)。
    * `E`: (仅自主导航模式) 打开/关闭大地图 (Toggle Full Map in Autonomous Navigation Mode)。
    * `ESC`: 呼出/关闭菜单 (Toggle Menu)。
    * `鼠标左键`: 点击UI元素 (Click UI Elements)。

    ============================================================================
    -->
    <style>
        :root {
            --bg-color: #f0f8ff; /* AliceBlue - a very light blue sky */
            --text-color: #333333; /* Dark Grey for text */
            --primary-color: #007bff; /* Bright Blue */
            --highlight-color: #28a745; /* Green */
            --danger-color: #dc3545; /* Red */
            --wall-color-ns: #f5deb3; /* Wheat - for North-South walls */
            --wall-color-ew: #ffc0cb; /* light pink */ /* Linen - slightly lighter for East-West walls */
            --floor-color: #E0E0E0; /* Fallback color, not really used with texture */
            --landmark-color: #ffc107; /* Amber */
            --start-color: #007bff;
            --goal-color: #dc3545; /* Red */
            --font-size-normal: 18px;
            --font-size-large: 22px;
            --font-size-xlarge: 28px;
            --minimap-scale: 1; /* 小地图缩放比例 */
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: var(--font-size-normal);
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        .hud {
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        #top-hud {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
            position: relative; /* For positioning hints */
        }

        #map-view-count {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: var(--font-size-normal);
            font-weight: bold;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: none; /* Hidden by default */
        }

        #bottom-hud {
           text-align: center;
            position: absolute; 
            bottom: 3vh;        
            left: 0;            
            right: 0;           
        }

        /* Shared style for prompts */
        .hud-prompt {
            background-color: rgba(255, 255, 255, 0.85);
            color: var(--text-color);
            padding: 15px 25px;
            border-radius: 15px;
            border: 2px solid var(--primary-color);
            font-size: var(--font-size-large);
            font-weight: bold;
            display: none; /* Initially hidden */
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 90%;
        }
        
        #big-map-prompt {
             border-color: var(--highlight-color);
        }

        #minimap-container {
            position: fixed;
            background-color: rgba(255, 255, 255, 0.8);
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            transition: all 0.5s ease-in-out;
            z-index: 10;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.5);
        }

        #minimap-container.big-map {
            /* MODIFIED: Centering is now handled by a flex container */
            position: relative;
            width: 60vmin;
            height: 60vmin;
            cursor: pointer;
        }

        #minimap-container.small-map {
            top: 20px;
            right: 20px;
            width: calc(25vmin * var(--minimap-scale));
            height: calc(25vmin * var(--minimap-scale));
            max-width: calc(250px * var(--minimap-scale));
            max-height: calc(250px * var(--minimap-scale));
            cursor: default;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        
        #ingame-hint {
            position: absolute;
            top: 80px; /* Positioned below the settings button */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: var(--font-size-normal);
            z-index: 5;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }

        /* Modals and Menus */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background-color: white;
            color: var(--text-color);
            padding: 24px;
            border-radius: 16px;
            border: 2px solid var(--primary-color);
            text-align: center;
            width: 95vw;
            max-width: 1000px;
            max-height: 90vh;
            overflow: auto;
            box-shadow: 0 0 25px rgba(0, 123, 255, 0.5);
        }
        
        #editor-modal .modal-content, #custom-maps-modal .modal-content {
            max-width: 95vmin;
        }

        .modal-content h2 {
            font-size: var(--font-size-xlarge);
            margin-top: 0;
            margin-bottom: 30px;
            color: var(--primary-color);
        }
        
        .modal-content p {
            font-size: var(--font-size-normal);
            margin-bottom: 20px;
        }

        .modal-content input, .modal-content select {
            width: 80%;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 10px;
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            color: var(--text-color);
            font-size: var(--font-size-normal);
            min-height: 44px;
        }

        .modal-content button {
            padding: 15px 0;
            border-radius: 10px;
            border: none;
            background-color: var(--primary-color);
            color: white;
            font-size: var(--font-size-large);
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 80%;
            max-width: 300px;
            min-height: 50px;
            margin: 10px auto;
            display: block;
        }
        
        .modal-content .button-row {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .modal-content .button-row button {
            width: 45%;
            max-width: 150px;
        }

        .modal-content button.danger {
            background-color: var(--danger-color);
        }
        .modal-content button.secondary {
            background-color: #6c757d;
        }

        .modal-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.4);
        }
        .modal-content button.danger:hover {
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
        }
        .modal-content button.secondary:hover {
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.4);
        }
        
        .modal-content button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        #results-medal {
            font-size: 80px;
            margin: 20px 0;
        }
        
        #results-title {
            color: var(--highlight-color);
        }

        #dev-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 20;
            pointer-events: auto;
            display: none;
        }
        #dev-panel h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        #dev-panel select {
            min-height: 44px;
        }

        #settings-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.1);
            border: none;
            color: var(--text-color);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #settings-panel {
            display: none;
        }

        .settings-group {
            text-align: left;
            margin-bottom: 20px;
        }
        .settings-group label {
            display: block;
            margin-bottom: 10px;
        }
        .settings-group select, .settings-group input[type="range"] {
            width: 100%;
        }

        #level-select-grid, #custom-maps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
            max-height: 50vh;
            overflow-y: auto;
        }

        #level-select-grid button, #custom-maps-grid button {
            min-width: 60px;
            width: 100%;
            padding: 10px;
        }

        #level-select-grid button:disabled, #custom-maps-grid button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        #custom-maps-grid button.selected {
            border: 3px solid var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }

        /* Editor Styles */
        #editor-toolbar {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        #editor-toolbar button, #editor-toolbar select {
            width: auto;
            min-width: 80px;
            padding: 10px 15px;
            font-size: var(--font-size-normal);
            min-height: 44px;
            margin: 5px;
        }
        #editor-toolbar button.selected {
            background-color: var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }
        #editor-grid {
            display: grid;
            /* columns/rows will be set dynamically in JS according to editorSize */
            width: min(90vmin, 900px);
            height: min(90vmin, 900px);
            margin: 8px auto 16px;
        }
        .editor-cell {
            border: 1px solid #dee2e6;
            transition: background-color 0.1s;
            min-width: 0; min-height: 0;
        }

        .editor-cell.lm1 { background: #fff3cd; border: 2px solid #ffc107; }
        .editor-cell.lm2 { background: #e2f0d9; border: 2px solid #28a745; }
        .editor-cell.lm3 { background: #d1ecf1; border: 2px solid #17a2b8; }
        .editor-cell.lm4 { background: #f8d7da; border: 2px solid #dc3545; }
        .editor-cell.lm5 { background: #ede7f6; border: 2px solid #6f42c1; }

        .editor-cell:hover {
            background-color: #ced4da;
        }
        .editor-cell.wall { background-color: #343a40; }
        .editor-cell.path { background-color: #f8f9fa; }
        .editor-cell.start { background-color: var(--start-color); }
        .editor-cell.goal { background-color: var(--goal-color); }
        
        .lang-en { display: none; }

        /* Intro Video Overlay */
        .intro-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            opacity: 1;
            transition: opacity .5s ease;
        }
        .intro-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #intro-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #skip-intro-btn {
            position: absolute;
            right: 20px;
            bottom: 20px;
            padding: 12px 18px;
            border: 0;
            border-radius: 999px;
            font-size: 16px;
            font-weight: 700;
            background: rgba(255, 255, 255, .15);
            color: #fff;
            backdrop-filter: blur(6px);
            cursor: pointer;
        }
        #skip-intro-btn:hover {
            background: rgba(255, 255, 255, .3);
        }

        /* Animated Info Box for Menus */
        .menu-info-box {
            margin-top: 20px;
            padding: 15px;
            min-height: 80px;
            width: 85%;
            background-color: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #dee2e6;
            color: #495057;
            font-size: var(--font-size-normal);
            text-align: left;
            overflow: hidden;
            white-space: normal;
        }

        .menu-info-box p {
            margin: 0;
            opacity: 0;
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Big map layout styles */
        .big-map-flex-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            width: 95vw;
            height: 95vh;
        }

        #map-instructions-panel h3 {
            margin-top: 0;
            color: var(--primary-color);
        }
        
        /* NEW: Styles for the detailed map legend */
        #map-instructions-panel ul {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }

        #map-instructions-panel li {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            font-size: 17px;
        }

        .map-legend-swatch {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 5px;
            margin-right: 12px;
            border: 1px solid rgba(0,0,0,0.2);
        }

        .swatch-player {
            background: #c00000;
        }
        .swatch-start {
            background-color: var(--start-color);
        }
        .swatch-goal {
            background-color: var(--goal-color);
        }
        
        #map-instructions-panel .instruction-text {
            margin-top: 15px;
            font-weight: bold;
        }



        .legend-icon{width:24px;height:24px;margin-right:12px;display:inline-block;vertical-align:middle;}
        .legend-icon path{vector-effect:non-scaling-stroke;}

        @media (max-width: 800px) {
            .big-map-flex-container {
                flex-direction: column;
                gap: 15px;
                justify-content: center;
            }
            #map-instructions-panel {
                max-width: 90vw;
                order: 2; /* Instructions below map */
                padding: 20px;
                font-size: 16px;
            }
            #big-map-container-wrapper {
                order: 1; /* Map above instructions */
            }
            #minimap-container.big-map {
                width: 80vw;
                height: 80vw;
            }
        }
    </style>
</head>
<body>
    <!-- Intro video overlay -->
    <div id="intro-overlay" class="intro-overlay" aria-label="开场视频" role="dialog" aria-modal="true">
        <video id="intro-video" src="intro.mp4" autoplay muted playsinline webkit-playsinline preload="auto"></video>
        <button id="skip-intro-btn" aria-label="跳过视频">跳过</button>
    </div>

    <div id="game-container"></div>

    <div id="ui-container">
        <div id="top-hud" class="hud">
             <div id="map-view-count"></div>
             <div id="ingame-hint" style="display: none;"></div>
        </div>
        <div id="bottom-hud" class="hud">
            <div id="big-map-prompt" class="hud-prompt"></div>
            <div id="choice-prompt" class="hud-prompt"></div>
        </div>
    </div>

    <div id="minimap-container">
        <canvas id="minimap-canvas"></canvas>
    </div>
    
    <button id="settings-button">⚙️</button>

    <div id="startup-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 data-lang-zh="欢迎来到快乐驾驶" data-lang-en="Welcome to Happy Drive">欢迎来到快乐驾驶</h2>
            <div class="settings-group">
                <label for="initial-language-select" data-lang-zh="语言 / Language" data-lang-en="语言 / Language">语言 / Language</label>
                <select id="initial-language-select">
                    <option value="zh">中文</option>
                    <option value="en">English</option>
                </select>
            </div>
            <p data-lang-zh="为了更好地称呼您，请输入您的信息：" data-lang-en="To get started, please enter your info:">为了更好地称呼您，请输入您的信息：</p>
            <input type="text" id="nickname-input" data-lang-placeholder-zh="请输入您的昵称" data-lang-placeholder-en="Enter your nickname">
            <select id="gender-select">
                <option value="male" data-lang-zh="男" data-lang-en="Male">男</option>
                <option value="female" data-lang-zh="女" data-lang-en="Female">女</option>
                <option value="other" data-lang-zh="其他" data-lang-en="Other">其他</option>
            </select>
            <button id="start-game-btn" data-lang-zh="开始游戏" data-lang-en="Start Game">开始游戏</button>
        </div>
    </div>

    <div id="main-menu-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="welcome-message"></h2>
            <button id="campaign-mode-btn" data-lang-zh="通关模式" data-lang-en="Campaign Mode">通关模式</button>
            <button id="free-mode-btn" data-lang-zh="自由模式" data-lang-en="Free Mode">自由模式</button>
            <button id="custom-mode-btn" data-lang-zh="自定义模式" data-lang-en="Custom Mode" disabled>自定义模式</button>
            <button id="editor-mode-btn" data-lang-zh="地图编辑器" data-lang-en="Map Editor">地图编辑器</button>
            <div id="main-menu-info-box" class="menu-info-box"></div>
        </div>
    </div>
    
    <div id="level-complete-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="results-title"></h2>
            <div id="results-medal"></div>
            <p id="results-stats"></p>
            <p id="results-quote"></p>
            <button id="next-level-btn" data-lang-zh="下一关" data-lang-en="Next Level">下一关</button>
            <button id="main-menu-btn" data-lang-zh="返回主菜单" data-lang-en="Main Menu">返回主菜单</button>
        </div>
    </div>

    <div id="settings-panel" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="设置" data-lang-en="Settings">设置</h2>
            <div class="settings-group">
                <label for="language-select" data-lang-zh="语言" data-lang-en="Language">语言</label>
                <select id="language-select">
                    <option value="zh">中文</option>
                    <option value="en">English</option>
                </select>
            </div>
            <div class="settings-group">
                <label for="font-size-slider" data-lang-zh="字体大小" data-lang-en="Font Size">字体大小</label>
                <input type="range" id="font-size-slider" min="0.8" max="1.5" step="0.1" value="1">
            </div>
            <div class="settings-group">
                <label for="minimap-size-slider" data-lang-zh="小地图大小" data-lang-en="Minimap Size">小地图大小</label>
                <input type="range" id="minimap-size-slider" min="1" max="1.414" step="0.01" value="1">
            </div>
            <div class="settings-group">
                <label for="helper-text-toggle" data-lang-zh="辅助文字" data-lang-en="Helper Text">辅助文字</label>
                <select id="helper-text-toggle">
                    <option value="on" data-lang-zh="开启" data-lang-en="On">开启</option>
                    <option value="off" data-lang-zh="关闭" data-lang-en="Off">关闭</option>
                </select>
            </div>
            <button id="close-settings-btn" data-lang-zh="关闭" data-lang-en="Close">关闭</button>
        </div>
    </div>

    <div id="pause-menu-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="暂停菜单" data-lang-en="Pause Menu">暂停菜单</h2>
            <button id="resume-game-btn" data-lang-zh="返回游戏" data-lang-en="Resume Game">返回游戏</button>
            <button id="level-select-btn" data-lang-zh="选择关卡" data-lang-en="Select Level">选择关卡</button>
            <button id="reset-game-btn" data-lang-zh="重置游戏" data-lang-en="Reset Game">重置游戏</button>
            <button id="pause-to-main-menu-btn" data-lang-zh="返回主菜单" data-lang-en="Main Menu">返回主菜单</button>
        </div>
    </div>

    <div id="level-select-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="选择关卡" data-lang-en="Select Level">选择关卡</h2>
            <div id="level-select-grid"></div>
            <button id="close-level-select-btn" data-lang-zh="返回" data-lang-en="Back">返回</button>
        </div>
    </div>
    
    <div id="editor-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="地图编辑器" data-lang-en="Map Editor">地图编辑器</h2>
            <div id="editor-toolbar">
                <select id="editor-slot-select"></select>
                <label style="margin-left:8px;">尺寸</label>
                <input id="editor-size-input" type="number" min="5" max="30" value="15" style="width:64px;" />
                <button id="tool-wall" data-tool="wall" data-lang-zh="墙" data-lang-en="Wall">墙</button>
                <button id="tool-path" data-tool="path" data-lang-zh="路" data-lang-en="Path">路</button>
                <button id="tool-start" data-tool="start" data-lang-zh="起点" data-lang-en="Start">起点</button>
                <button id="tool-goal" data-tool="goal" data-lang-zh="终点" data-lang-en="Goal">终点</button>
                <button id="tool-lm1" data-tool="lm1" data-lang-zh="路标1" data-lang-en="LM1">路标1</button>
                <button id="tool-lm2" data-tool="lm2" data-lang-zh="路标2" data-lang-en="LM2">路标2</button>
                <button id="tool-lm3" data-tool="lm3" data-lang-zh="路标3" data-lang-en="LM3">路标3</button>
                <button id="tool-lm4" data-tool="lm4" data-lang-zh="路标4" data-lang-en="LM4">路标4</button>
                <button id="tool-lm5" data-tool="lm5" data-lang-zh="路标5" data-lang-en="LM5">路标5</button>
            </div>
            <div id="editor-grid"></div>
            <p id="editor-message" style="color: red; min-height: 1.2em;"></p>
            <button id="editor-save-btn" data-lang-zh="保存地图" data-lang-en="Save Map">保存地图</button>
            <button id="editor-delete-btn" data-lang-zh="删除此地图" data-lang-en="Delete Map" class="danger">删除此地图</button>
            <button id="editor-back-btn" data-lang-zh="返回主菜单" data-lang-en="Back to Menu">返回主菜单</button>
        </div>
    </div>
    
    <div id="custom-maps-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="自定义地图" data-lang-en="Custom Maps">自定义地图</h2>
            <div id="custom-maps-grid"></div>
            <p data-lang-zh="选择一张地图进行操作。" data-lang-en="Select a map to continue.">选择一张地图进行操作。</p>
            <button id="custom-play-btn" data-lang-zh="游玩" data-lang-en="Play" disabled>游玩</button>
            <button id="custom-edit-btn" data-lang-zh="编辑" data-lang-en="Edit" disabled>编辑</button>
            <button id="custom-delete-btn" data-lang-zh="删除" data-lang-en="Delete" disabled class="danger">删除</button>
            <button id="custom-back-btn" data-lang-zh="返回主菜单" data-lang-en="Back to Menu">返回主菜单</button>
        </div>
    </div>

    <!-- MODIFIED: Modal for Big Map View with detailed legend -->
    <div id="big-map-view-modal" class="modal-overlay" style="display: none;">
        <div class="big-map-flex-container">
            <div id="map-instructions-panel" class="modal-content" style="width: auto; max-width: 350px; text-align: left; padding: 30px;">
                <h3 id="map-instructions-title" data-lang-zh="地图说明" data-lang-en="Map Instructions">地图说明</h3>
                <ul>
                    <li>
                        
<svg class="legend-icon" viewBox="0 0 24 24" aria-label="您的位置箭头">
    <defs>
        <radialGradient id="legendPlayerGrad" cx="50%" cy="50%" r="50%">
            <stop offset="0%" stop-color="#ff8080"/>
            <stop offset="100%" stop-color="#c00000"/>
        </radialGradient>
    </defs>
    <path d="M4 12 L16 4 L16 9 L21 9 L21 15 L16 15 L16 20 Z"
          fill="url(#legendPlayerGrad)" stroke="#006400" stroke-width="2" stroke-linejoin="round"/>
</svg>

                        <span data-lang-zh="您的位置 (红色箭头)" data-lang-en="Your Position (Red Arrow)">您的位置 (红色箭头)</span>
                    </li>
                    <li>
                        <span class="map-legend-swatch swatch-start"></span>
                        <span data-lang-zh="起点 (蓝色方块)" data-lang-en="Start Point (Blue Square)">起点 (蓝色方块)</span>
                    </li>
                    <li>
                        <span class="map-legend-swatch swatch-goal"></span>
                        <span data-lang-zh="终点 (红色方块)" data-lang-en="Goal (Red Square)">终点 (红色方块)</span>
                    </li>
                </ul>
                <p class="instruction-text" data-lang-zh="请仔细规划路线，准备好后，用鼠标左键点击大地图开始驾驶。" data-lang-en="Plan your route carefully. When ready, click the big map to start driving.">
                    请仔细规划路线，准备好后，用鼠标左键点击大地图开始驾驶。
                </p>
            </div>
            <div id="big-map-container-wrapper">
                <!-- The minimap canvas container will be moved here by JS -->
            </div>
        </div>
    </div>

    <div id="mode-select-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="选择导航模式" data-lang-en="Select Navigation Mode">选择导航模式</h2>
            <button id="mode-select-minimap-btn" data-lang-zh="小地图导航" data-lang-en="Minimap Navigation">小地图导航</button>
            <button id="mode-select-challenge-btn" data-lang-zh="自主导航" data-lang-en="Autonomous Navigation">自主导航</button>
            <div id="nav-mode-info-box" class="menu-info-box"></div>
        </div>
    </div>
    
    <div id="confirm-reset-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="确认重置" data-lang-en="Confirm Reset">确认重置</h2>
            <p data-lang-zh="您确定要重置所有游戏数据吗？此操作无法撤销。" data-lang-en="Are you sure you want to reset all game data? This action cannot be undone.">您确定要重置所有游戏数据吗？此操作无法撤销。</p>
            <div class="button-row">
                <button id="confirm-reset-btn" class="danger" data-lang-zh="确认" data-lang-en="Confirm">确认</button>
                <button id="cancel-reset-btn" class="secondary" data-lang-zh="取消" data-lang-en="Cancel">取消</button>
            </div>
        </div>
    </div>


    <div id="dev-panel">
        <h4 data-lang-zh="关卡快速切换" data-lang-en="Quick Level Select">关卡快速切换</h4>
        <select id="level-select"></select>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/loaders/GLTFLoader.js';


        // ================= Landmark Hunt Helpers =================

// === Remote dog asset (GLB) ===
const DOG_GLTF_URL = "https://raw.githubusercontent.com/novaz001-sar/maze-driver-game/main/assets/fantasy_dog.glb";
let __gltfLoader = null;
function createNumberBadgeSprite(numberId=1){
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 512;
    const ctx = canvas.getContext('2d');
    const cx = 256, cy = 256, R = 210;
    const grad = ctx.createRadialGradient(cx-40, cy-40, 40, cx, cy, R);
    grad.addColorStop(0, '#fff8e1'); grad.addColorStop(0.5, '#ffe082'); grad.addColorStop(1, '#ffca28');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.closePath(); ctx.fill();
    ctx.lineWidth = 18; ctx.strokeStyle = '#8d6e63'; ctx.stroke();
    ctx.beginPath(); ctx.arc(cx, cy, R-26, 0, Math.PI*2); ctx.closePath();
    ctx.lineWidth = 10; ctx.strokeStyle = 'rgba(255,255,255,0.7)'; ctx.stroke();
    const shadowGrad = ctx.createRadialGradient(cx, cy+20, 30, cx, cy+20, R);
    shadowGrad.addColorStop(0, 'rgba(0,0,0,0.12)'); shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = shadowGrad; ctx.beginPath(); ctx.arc(cx, cy, R-6, 0, Math.PI*2); ctx.closePath(); ctx.fill();
    ctx.font = 'bold 270px "Trebuchet MS", "Segoe UI", Arial, sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(0,0,0,0.35)'; ctx.shadowBlur = 16; ctx.shadowOffsetY = 8;
    ctx.fillStyle = '#1b1b1b'; ctx.fillText(String(numberId), cx, cy+6);
    ctx.shadowColor = 'transparent'; ctx.lineWidth = 18; ctx.strokeStyle = '#ffffff'; ctx.strokeText(String(numberId), cx, cy+6);
    const tex = new THREE.CanvasTexture(canvas); tex.needsUpdate = true;
    const spriteMat = new THREE.SpriteMaterial({ map: tex, depthTest: true, depthWrite: true });
    const sprite = new THREE.Sprite(spriteMat);
    sprite.scale.set(1.2, 1.2, 1.2);
    sprite.position.set(0, 2.35, 0.62);
    sprite.name = 'numberBillboard';
    return sprite;
}

async function loadPuppyFromURL(url, numberId=1){
    try{
        if(!__gltfLoader) __gltfLoader = new GLTFLoader();
        const gltf = await new Promise((resolve, reject)=>{
            __gltfLoader.load(url, resolve, undefined, reject);
        });
        const group = new THREE.Group();
        const sceneNode = gltf.scene || (gltf.scenes && gltf.scenes[0]);
        if (sceneNode){
            sceneNode.traverse(o=>{ if (o.isMesh){ o.castShadow = true; o.receiveShadow = true; }});
            group.add(sceneNode);
        }
        const badge = createNumberBadgeSprite(numberId);
        group.add(badge);
        if (gltf.animations && gltf.animations.length){
            const mixer = new THREE.AnimationMixer(sceneNode);
            const clip = gltf.animations[0];
            mixer.clipAction(clip).play();
            group.userData.mixer = mixer;
        }
        group.userData.id = numberId;
        return group;
    }catch(err){
        console.warn('GLB load failed, fallback to procedural dog:', err);
        return createPuppyDog(numberId);
    }
}


        // Enforce minimum spacing between landmarks: Euclidean distance >= 3 grid units
        function enforceLandmarkSpacing(level) {
            if (!level.landmarks || level.landmarks.length < 2) return level;
            const grid = level.grid;
            const H = grid.length, W = grid[0].length;
            const isWalkable = (x,z) => z>=0 && z<H && x>=0 && x<W && grid[z][x] === 1;
            const minD = 3.0;
            // Iterate by increasing id; if too close to any previous, try to relocate current to nearest valid cell
            for (let i = 0; i < level.landmarks.length; i++) {
                const lm = level.landmarks[i];
                let ok = true;
                for (let j = 0; j < i; j++) {
                    const p = level.landmarks[j];
                    const d = Math.hypot(lm.x - p.x, lm.z - p.z);
                    if (d < minD) { ok = false; break; }
                }
                if (!ok) {
                    // BFS outward by rings to find nearest position satisfying spacing to all previous landmarks
                    const q = [{x: lm.x, z: lm.z}];
                    const seen = new Set([`${lm.x},${lm.z}`]);
                    let found = null;
                    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
                    while (q.length) {
                        const cur = q.shift();
                        if (isWalkable(cur.x, cur.z)) {
                            let spaceOK = true;
                            for (let j = 0; j < i; j++) {
                                const p = level.landmarks[j];
                                const d = Math.hypot(cur.x - p.x, cur.z - p.z);
                                if (d < minD) { spaceOK = false; break; }
                            }
                            if (spaceOK) { found = cur; break; }
                        }
                        for (const [dx,dz] of dirs) {
                            const nx = cur.x + dx, nz = cur.z + dz;
                            const key = `${nx},${nz}`;
                            if (nx>=0 && nx<W && nz>=0 && nz<H && !seen.has(key)) {
                                seen.add(key); q.push({x:nx, z:nz});
                            }
                        }
                    }
                    if (found) {
                        lm.x = found.x; lm.z = found.z;
                    }
                }
            }
            return level;
        }

        let huntGroup = null;
        let effectsGroup = null;
        let currentHunt = { active: false, nextId: 1, total: 0, indexByKey: {}, objects: {} };

        
        
        
        function createPuppyDog(numberId = 1) {
            const g = new THREE.Group();

            // --- Materials (ultra-cute white) ---
            const furWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4, metalness: 0.08 });
            const earPink  = new THREE.MeshStandardMaterial({ color: 0xffc0cb, roughness: 0.6, metalness: 0.0 });
            const noseBlack= new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.25, metalness: 0.0 });
            const eyeGloss = new THREE.MeshPhysicalMaterial({ color: 0x111111, roughness: 0.05, metalness: 0.0, clearcoat: 1.0, clearcoatRoughness: 0.03 });
            const collarMat= new THREE.MeshStandardMaterial({ color: 0xaed4ff, metalness: 0.25, roughness: 0.35, emissive: 0x2c4a7a, emissiveIntensity: 0.06 });
            const blushMat = new THREE.MeshStandardMaterial({ color: 0xff94b6, roughness: 0.85, metalness: 0.0 });
            const padMat   = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.5, metalness: 0.0 });
            const toothMat = new THREE.MeshStandardMaterial({ color: 0xf8f8f8, roughness: 0.2, metalness: 0.0 });
            const tongueMat= new THREE.MeshStandardMaterial({ color: 0xff6b81, roughness: 0.7, metalness: 0.0 });

            // --- Body ---
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.9, 1.0, 2.5), furWhite);
            body.position.y = 0.5;
            body.geometry.computeVertexNormals();
            g.add(body);

            // Subtle rounding: add a small hemisphere rump to make the back rounder
            const rump = new THREE.Mesh(new THREE.SphereGeometry(0.7, 24, 16), furWhite);
            rump.position.set(0, 0.8, -0.7);
            g.add(rump);

            // --- Head (bigger) ---
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.85, 32, 22), furWhite);
            head.position.set(0, 1.25, 0.85);
            g.add(head);

            // Muzzle / snout (slightly extruded)
            const snoutBase = new THREE.Mesh(new THREE.SphereGeometry(0.38, 24, 16), furWhite);
            snoutBase.scale.set(1.15, 0.8, 1.2);
            snoutBase.position.set(0, 1.02, 1.25);
            g.add(snoutBase);

            // Nose
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.1, 18, 14), noseBlack);
            nose.position.set(0, 1.05, 1.45);
            g.add(nose);

            // Mouth: tiny teeth + tongue
            const toothL = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.05, 0.02), toothMat);
            const toothR = toothL.clone();
            toothL.position.set(-0.08, 0.92, 1.37);
            toothR.position.set( 0.08, 0.92, 1.37);
            const tongue = new THREE.Mesh(new THREE.CapsuleGeometry(0.05, 0.1, 6, 12), tongueMat);
            tongue.position.set(0, 0.88, 1.38);
            tongue.rotation.x = Math.PI*0.48;
            g.add(toothL, toothR, tongue);

            // Ears (outer + inner)
            const earOuterL = new THREE.Mesh(new THREE.ConeGeometry(0.28, 0.58, 16), furWhite);
            earOuterL.position.set(-0.44, 1.62, 0.52); earOuterL.rotation.z = 0.35;
            const earOuterR = earOuterL.clone(); earOuterR.position.x *= -1; earOuterR.rotation.z = -0.35;
            const earInnerL = new THREE.Mesh(new THREE.ConeGeometry(0.22, 0.5, 14), earPink);
            earInnerL.position.copy(earOuterL.position); earInnerL.rotation.copy(earOuterL.rotation);
            const earInnerR = earInnerL.clone(); earInnerR.position.x *= -1; earInnerR.rotation.z = -0.35;
            g.add(earOuterL, earOuterR, earInnerL, earInnerR);

            // Eyes (larger & glossy) + brows
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.135, 18, 14), eyeGloss);
            eyeL.position.set(-0.24, 1.32, 1.10);
            const eyeR = eyeL.clone(); eyeR.position.x *= -1;
            const browL = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.04, 0.02), noseBlack);
            browL.position.set(-0.26, 1.44, 1.0); browL.rotation.z = 0.12;
            const browR = browL.clone(); browR.position.x *= -1; browR.rotation.z = -0.12;
            g.add(eyeL, eyeR, browL, browR);

            // Whiskers (thin cylinders)
            for (let side of [-1, 1]) {
                for (let k = -1; k <= 1; k++) {
                    const whisk = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.5, 6), noseBlack);
                    whisk.position.set(0.13 * side, 1.03 + k*0.06, 1.34);
                    whisk.rotation.z = side * 1.25;
                    g.add(whisk);
                }
            }

            // Blush
            const blushL = new THREE.Mesh(new THREE.CircleGeometry(0.13, 18), blushMat);
            blushL.position.set(-0.33, 1.08, 1.2); blushL.rotation.x = -Math.PI/2;
            const blushR = blushL.clone(); blushR.position.x *= -1;
            g.add(blushL, blushR);

            // Tail (curled, two torus segments)
            const tail1 = new THREE.Mesh(new THREE.TorusGeometry(0.38, 0.075, 12, 28, Math.PI*1.1), furWhite);
            tail1.position.set(0, 0.95, -0.55);
            tail1.rotation.set(Math.PI/2, 0, Math.PI/5);
            const tail2 = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.06, 12, 28, Math.PI*1.0), furWhite);
            tail2.position.set(0.15, 1.08, -0.4);
            tail2.rotation.set(Math.PI/2, 0.2, Math.PI/3);
            g.add(tail1, tail2);

            // Legs with tiny paw pads (four toes)
            const legPos = [[-0.56,-0.9],[0.56,-0.9],[-0.56,0.9],[0.56,0.9]];
            legPos.forEach(([dx, dz]) => {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.14, 0.14, 0.65, 16), furWhite);
                leg.position.set(dx, 0.325, dz);
                g.add(leg);
                const pad = new THREE.Mesh(new THREE.CircleGeometry(0.12, 14), padMat);
                pad.rotation.x = -Math.PI/2;
                pad.position.set(dx, 0.0, dz);
                g.add(pad);
                for (let i=0;i<4;i++) {
                    const toe = new THREE.Mesh(new THREE.CircleGeometry(0.04, 10), padMat);
                    toe.rotation.x = -Math.PI/2;
                    const angle = (-0.18 + i*0.12);
                    toe.position.set(dx + Math.sin(angle)*0.12, 0.005, dz + Math.cos(angle)*0.12);
                    g.add(toe);
                }
            });

            // Collar + small tag
            const collar = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.06, 14, 28), collarMat);
            collar.rotation.x = Math.PI/2;
            collar.position.set(0, 0.96, 0.72);
            const tag = new THREE.Mesh(new THREE.CircleGeometry(0.08, 16), new THREE.MeshStandardMaterial({ color: 0xffd54f, metalness: 0.6, roughness: 0.3, emissive: 0x7a5c00, emissiveIntensity: 0.1 }));
            tag.position.set(0, 0.86, 0.96);
            g.add(collar, tag);

            // --- Premium number medallion (canvas) ---
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Background: circular medallion with radial gradient
            const cx = 256, cy = 256, R = 210;
            const grad = ctx.createRadialGradient(cx-40, cy-40, 40, cx, cy, R);
            grad.addColorStop(0, '#fff8e1');
            grad.addColorStop(0.5, '#ffe082');
            grad.addColorStop(1, '#ffca28');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.closePath(); ctx.fill();

            // Outer stroke + inner bevel ring
            ctx.lineWidth = 18; ctx.strokeStyle = '#8d6e63'; ctx.stroke();
            ctx.beginPath(); ctx.arc(cx, cy, R-26, 0, Math.PI*2); ctx.closePath();
            ctx.lineWidth = 10; ctx.strokeStyle = 'rgba(255,255,255,0.7)'; ctx.stroke();

            // Subtle inner shadow
            const shadowGrad = ctx.createRadialGradient(cx, cy+20, 30, cx, cy+20, R);
            shadowGrad.addColorStop(0, 'rgba(0,0,0,0.12)');
            shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = shadowGrad;
            ctx.beginPath(); ctx.arc(cx, cy, R-6, 0, Math.PI*2); ctx.closePath(); ctx.fill();

            // Number with drop shadow & stroke
            ctx.font = 'bold 270px "Trebuchet MS", "Segoe UI", Arial, sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0,0,0,0.35)'; ctx.shadowBlur = 16; ctx.shadowOffsetY = 8;
            ctx.fillStyle = '#1b1b1b'; ctx.fillText(String(numberId), cx, cy+6);
            ctx.shadowColor = 'transparent';
            ctx.lineWidth = 18; ctx.strokeStyle = '#ffffff'; ctx.strokeText(String(numberId), cx, cy+6);

            // Sparkles
            function star(ctx, x, y, r1, r2, n){
                ctx.beginPath();
                let rot = -Math.PI/2;
                const step = Math.PI/n;
                for(let i=0;i<n;i++){
                    ctx.lineTo(x + Math.cos(rot)*r1, y + Math.sin(rot)*r1); rot += step;
                    ctx.lineTo(x + Math.cos(rot)*r2, y + Math.sin(rot)*r2); rot += step;
                }
                ctx.closePath();
            }
            ctx.fillStyle = '#fffde7';
            ctx.strokeStyle = '#ffe082';
            [[80,90,12,5,5],[430,120,10,4,5],[420,380,14,6,5]].forEach(([x,y,r1,r2,n])=>{
                star(ctx,x,y,r1,r2,n); ctx.fill(); ctx.lineWidth = 4; ctx.stroke();
            });

            const tex = new THREE.CanvasTexture(canvas);
            tex.needsUpdate = true;
            const spriteMat = new THREE.SpriteMaterial({ map: tex, depthTest: true, depthWrite: true });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(1.2, 1.2, 1.2);
            sprite.position.set(0, 2.35, 0.62);
            sprite.name = 'numberBillboard';
            g.add(sprite);

            // Gentle idle tilt
            g.userData.id = numberId;
            return g;
        }

    
function replaceNumberWithGoldStar(obj3d) {
            const old = obj3d.getObjectByName('numberBillboard');
            if (old) obj3d.remove(old);
            const shape = new THREE.Shape();
            const spikes = 5, outerR = 0.6, innerR = 0.28;
            let rot = Math.PI / 2 * 3, x = 0, y = 0, step = Math.PI / spikes;
            shape.moveTo(0, -outerR);
            for (let i = 0; i < spikes; i++) {
                x = Math.cos(rot) * outerR; y = Math.sin(rot) * outerR; shape.lineTo(x, y); rot += step;
                x = Math.cos(rot) * innerR; y = Math.sin(rot) * innerR; shape.lineTo(x, y); rot += step;
            }
            shape.lineTo(0, -outerR);
            const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.2, bevelEnabled: true, bevelSegments: 2, steps: 1, bevelSize: 0.05, bevelThickness: 0.05 });
            const mat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2, emissive: 0x8b7500, emissiveIntensity: 0.2 });
            const star = new THREE.Mesh(geo, mat);
            star.position.set(0, 2.4, 0.62);
            star.scale.set(1.0,1.0,0.22);
            star.rotation.y = Math.PI/8;
            obj3d.add(star);
        }

        function spawnFireworksAtWorldPos(worldPos) {
            if (!effectsGroup) { effectsGroup = new THREE.Group(); scene.add(effectsGroup); }
            const pCount = 180;
            const positions = new Float32Array(pCount * 3);
            const velocities = new Float32Array(pCount * 3);
            const colors = new Float32Array(pCount * 3);
            for (let i = 0; i < pCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2*Math.random()-1);
                const speed = 2 + Math.random() * 4;
                const vx = Math.sin(phi)*Math.cos(theta)*speed;
                const vy = Math.cos(phi)*speed;
                const vz = Math.sin(phi)*Math.sin(theta)*speed;
                velocities[i*3+0] = vx;
                velocities[i*3+1] = Math.abs(vy);
                velocities[i*3+2] = vz;
                positions[i*3+0] = worldPos.x + (Math.random()-0.5)*1.0;
                positions[i*3+1] = 0.5 + Math.random()*0.5;
                positions[i*3+2] = worldPos.z + (Math.random()-0.5)*1.0;
                const c = new THREE.Color().setHSL(Math.random(), 0.9, 0.6);
                colors[i*3+0] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            const mat = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, transparent: true, opacity: 0.95, depthWrite: false, blending: THREE.AdditiveBlending });
            const points = new THREE.Points(geo, mat);
            points.userData = { ttl: 5.0 }; // seconds
            effectsGroup.add(points);
        }

        function updateEffects(delta) {
            if (!effectsGroup) return;
            for (let i = effectsGroup.children.length - 1; i >= 0; i--) {
                const p = effectsGroup.children[i];
                const attrPos = p.geometry.getAttribute('position');
                const attrVel = p.geometry.getAttribute('velocity');
                const positions = attrPos.array;
                const velocities = attrVel.array;
                const len = velocities.length / 3;
                for (let j = 0; j < len; j++) {
                    velocities[j*3+1] -= 9.8 * 0.6 * delta; // gravity
                    positions[j*3+0] += velocities[j*3+0] * delta;
                    positions[j*3+1] += velocities[j*3+1] * delta;
                    positions[j*3+2] += velocities[j*3+2] * delta;
                }
                attrPos.needsUpdate = true;
                p.userData.ttl -= delta;
                p.material.opacity = Math.max(0, Math.min(1, p.userData.ttl / 5.0));
                if (p.userData.ttl <= 0) {
                    effectsGroup.remove(p);
                }
            }
        }

        function createHuntObjects(level) {
            if (huntGroup) {
                huntGroup.traverse(o=>{ if (o.userData && o.userData.mixer) o.userData.mixer.update(delta); }); scene.remove(huntGroup); huntGroup = null; }
            huntGroup = new THREE.Group();
            scene.add(huntGroup);
            currentHunt = { active: true, nextId: 1, total: level.landmarks.length, indexByKey: {}, objects: {} };

            for (const lm of level.landmarks) {
                const worldPos = gridToWorld(lm.x, lm.z, level.grid);
                loadPuppyFromURL(DOG_GLTF_URL, lm.id).then(dog=>{
                    dog.position.set(worldPos.x, 0, worldPos.z);
                    huntGroup.add(dog);
                    currentHunt.objects[lm.id] = dog;
                });
                currentHunt.indexByKey[`${lm.x},${lm.z}`] = lm.id;
            }
        }

        function computeHuntOptimal(level) {
            // sum of shortest path segments: S->1->2->...->N
            if (!level.landmarks || !level.landmarks.length) return null;
            let from = {x: level.start.x, z: level.start.z};
            let total = 0;
            for (const lm of level.landmarks) {
                const d = findShortestDist(level.grid, from, {x: lm.x, z: lm.z});
                if (d == null) return null;
                total += d;
                from = {x: lm.x, z: lm.z};
            }
            return total;
        }

        function findShortestDist(grid, from, to) {
            const H = grid.length, W = grid[0].length;
            const q = [{x: from.x, z: from.z, d: 0}];
            const vis = new Set([`${from.x},${from.z}`]);
            const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
            while (q.length) {
                const cur = q.shift();
                if (cur.x === to.x && cur.z === to.z) return cur.d;
                for (const [dx,dz] of dirs) {
                    const nx = cur.x + dx, nz = cur.z + dz;
                    if (nz>=0 && nz<H && nx>=0 && nx<W && grid[nz][nx] === 1) {
                        const key = `${nx},${nz}`;
                        if (!vis.has(key)) {
                            vis.add(key);
                            q.push({x:nx, z:nz, d: cur.d+1});
                        }
                    }
                }
            }
            return null;
        }

        function handleHuntCollect(gridPos) {
            if (!currentHunt.active) return;
            const key = `${gridPos.x},${gridPos.z}`;
            const hitId = currentHunt.indexByKey[key];
            if (!hitId) return;
            if (hitId !== currentHunt.nextId) {
                (function(){ 
                const t = translations[currentLanguage] && translations[currentLanguage].hunt_wrong_order;
                let msg = '';
                if (typeof t === 'function') { msg = t(currentHunt.nextId); }
                else if (typeof t === 'string') { msg = t.replace('${need}', String(currentHunt.nextId)).replace('{need}', String(currentHunt.nextId)); }
                else { msg = '请先找到正确编号的路标 / Find the correct landmark first.'; }
                showTemporaryMessage(msg); 
            })();
                return;
            }
            // collect
            const dog = currentHunt.objects[hitId];
            replaceNumberWithGoldStar(dog);
            // mark for float-up animation
            dog.userData.collected = true;
            dog.userData.floatYTarget = Math.max((dog.position.y || 0), 6.2);
            dog.userData.floatSpeed = 0.9; // units per second
            const worldPos = gridToWorld(gridPos.x, gridPos.z, (currentLevelIndex===-1?customLevels[selectedCustomMapIndex]:levels[currentLevelIndex]).grid);
            spawnFireworksAtWorldPos(worldPos);
            currentHunt.nextId++;
            (function(){ 
                const t = translations[currentLanguage] && translations[currentLanguage].hunt_collected;
                let msg = '';
                if (typeof t === 'function') { msg = t(currentHunt.nextId-1, currentHunt.total); }
                else if (typeof t === 'string') { 
                    msg = t.replace('${n}', String(currentHunt.nextId-1)).replace('{n}', String(currentHunt.nextId-1))
                           .replace('${total}', String(currentHunt.total)).replace('{total}', String(currentHunt.total));
                } else { msg = `已收集路标 ${currentHunt.nextId-1}/${currentHunt.total}`; }
                showTemporaryMessage(msg, 2000); 
            })();
            if (currentHunt.nextId > currentHunt.total) {
                // all collected
                (function(){ 
                const t = translations[currentLanguage] && translations[currentLanguage].hunt_all_done;
                const msg = (typeof t === 'string') ? t : '全部路标收集完成！';
                showTemporaryMessage(msg, 2500); 
            })();
            }
        }

        // ====================================================================
        // 全局变量和状态机 (Global Variables & State Machine)
        // ====================================================================
        
        const TILE_SIZE = 10;
        const WALL_HEIGHT = 5;
        const MOVE_SPEED = 15;
        const TURN_SPEED = Math.PI * 2;

        
        const LUCKY_CAT = {
            WAVE_CENTER_DEG: 30,
            WAVE_AMPL_DEG: 10,
            WAVE_SPEED: 5.0,
            WRIST_AMPL_DEG: 8,
            WRIST_SPEED: 10.0
        };
        let scene, camera, renderer, clock;
        let starField;
        let player, mazeGroup, landmarksGroup, goalMarker, sceneryGroup, steeringWheel;
        let minimap, minimapCtx;
        
        let gameState = 'STARTUP_MODAL';
        let gameMode = 'campaign';
        let navigationMode = 'minimap';
        let currentLevelIndex = 0;
        let playerInfo = { nickname: 'Driver', gender: 'other' };

        let playerChoices = 0;
        let optimalChoices = 0;
        let mapViewChances = 3;
        
        let targetPosition = new THREE.Vector3();
        let targetRotation = new THREE.Euler();
        let previousGameState = '';
        let unlockedLevel = 0;

        // MODIFIED: Changed 'space' to 'w' for moving forward
        const keyState = { 'a': false, 'd': false, 'e': false, 'w': false, 'escape': false };
        let keyDebounce = false;

        let wallMaterialNS, wallMaterialEW, floorMaterial, landmarkMaterial, goalWallMaterial;
        let hemisphereLight, dirLight;
        
        let customLevels = [];
        let luckyCatArm, luckyCatWrist, floatingHeart;

        let currentLanguage = 'zh';
        let promptTimeout;
        let hintTimeout;

        // ====================================================================
        // 语言翻译数据 (Language Translation Data)
        // ====================================================================
        const translations = {
            zh: {
                welcome: (nickname) => `你好, ${nickname}!`,
                levelComplete: "关卡完成！",
                drivingGenius: "驾驶天才",
                greatDriver: "优秀司机",
                newDriver: "新手上路",
                quoteGenius: "完美！你就是这座城市的传奇！",
                quoteGreat: "干得漂亮！路线规划得非常出色。",
                quoteNew: "安全到达！经验丰富的选择。",
                stats: (p, o, r) => `你的步数: ${p} | 最优步数: ${o} | R值: ${r}`,
                freeModeComplete: "自由模式练习完成。",
                nextLevel: "下一关",
                finalResults: "查看最终结果",
                select: "选择",
                forward: "向前",
                turnLeft: "向左",
                turnRight: "向右",
                turnAround: "掉头",
                // MODIFIED: Updated helper text to use 'W'
                helperText: "按 A/D 转向, W 前进",
                level: "关卡",
                confirmReset: "您确定要重置所有游戏数据吗？此操作无法撤销。",
                allLevelsCleared: "恭喜你！已通关所有关卡！",
                mapChances: "查看地图次数",
                editor_need_start: "地图需要一个起点。",
                editor_need_goal: "地图需要一个终点。",
                editor_unsolvable: "地图无解！请确保起点和终点连通。",
                map_slot: "地图槽",
                empty_slot: "空槽位",
                confirm_delete: "您确定要删除这张地图吗？",
                desc_campaign: "挑战一系列精心设计的关卡，从易到难，解锁全部地图并成为驾驶大师。",
                desc_free: "自由选择任何已解锁的关卡进行练习，没有步数和成绩的压力。",
                desc_custom: "游玩、编辑或删除您在地图编辑器中创作的地图。",
                desc_editor: "发挥你的创造力！设计、建造并保存属于你自己的迷宫地图。",
                desc_minimap: "屏幕上会始终显示一个小地图，帮助您轻松定位和规划路线。",
                desc_challenge: "挑战模式！地图不会一直显示，您只有有限的几次查看地图的机会。",
                prompt_wall: "前方是墙壁，请选择其他方向。",
                prompt_options: (options) => `可选方向: ${options.join(' | ')}`,
                hint_ingame_controls: "提示：点击左上角 ⚙️ 更改设置，按 [ESC] 可打开菜单。",
                hint_driving_start: "提示：黄色箭头指的是没有墙阻挡的可选方向，不是导航方向。",
                prompt_dead_end: "遇到死胡同！连续按两次 [A] 或 [D] 键可以掉头。",
                prompt_near_goal: "再往前一步就到达目的地了！"
            },
            en: {
                welcome: (nickname) => `Hello, ${nickname}!`,
                levelComplete: "Level Complete!",
                drivingGenius: "Driving Genius",
                greatDriver: "Great Driver",
                newDriver: "New Driver",
                quoteGenius: "Perfect! You are a legend in this city!",
                quoteGreat: "Well done! An excellent route plan.",
                quoteNew: "Arrived safely! A solid choice.",
                stats: (p, o, r) => `Your Steps: ${p} | Optimal: ${o} | R-Value: ${r}`,
                freeModeComplete: "Free mode practice complete.",
                nextLevel: "Next Level",
                finalResults: "View Final Results",
                select: "Select",
                forward: "Forward",
                turnLeft: "Turn Left",
                turnRight: "Turn Right",
                turnAround: "Turn Around",
                // MODIFIED: Updated helper text to use 'W'
                helperText: "Use A/D to turn, W to move",
                level: "Level",
                confirmReset: "Are you sure you want to reset all game data? This action cannot be undone.",
                allLevelsCleared: "Congratulations! You have cleared all levels!",
                mapChances: "Map Views Left",
                editor_need_start: "Map needs a starting point.",
                editor_need_goal: "Map needs a goal point.",
                editor_unsolvable: "Map is unsolvable! Make sure the start and goal are connected.",
                map_slot: "Map Slot",
                empty_slot: "Empty Slot",
                confirm_delete: "Are you sure you want to delete this map?",
                desc_campaign: "Challenge a series of designed levels, from easy to hard, unlock all maps and become a master driver.",
                desc_free: "Freely select any unlocked level for practice without the pressure of steps and scores.",
                desc_custom: "Play, edit, or delete the maps you've created in the map editor.",
                desc_editor: "Unleash your creativity! Design, build, and save your own maze maps.",
                desc_minimap: "A small map will always be displayed on the screen to help you easily locate and plan your route.",
                desc_challenge: "Challenge mode! The map is not always visible, and you have limited chances to view it.",
                prompt_wall: "There is a wall ahead, please choose another direction.",
                prompt_options: (options) => `Available moves: ${options.join(' | ')}`,
                hint_ingame_controls: "Hint: Click the ⚙️ in the top-left to change settings. Press [ESC] to open the menu.",
                hint_driving_start: "Hint: Yellow arrows indicate available directions without walls, not a navigation path.",
                prompt_dead_end: "Dead end! Press [A] or [D] twice to turn around.",
                prompt_near_goal: "One more step to the destination!"
            }
        };

        // ====================================================================
        // 关卡数据 (Level Data)
        // ====================================================================
// ===== New: 5 easier intro levels (7x7 .. 11x11), each has ≥2 branches & ≥1 dead end =====
const INTRO_MAZES = [
    // Intro 1 (7x7)
    [[1,1,1,1,1,1,1],
     [1,0,0,0,1,'E',1],
     [1,0,1,0,1,0,1],
     [1,0,1,0,0,0,1],
     [1,0,1,1,1,0,1],
     [1,'S',0,0,1,0,1],
     [1,1,1,1,1,1,1]],
    // Intro 2 (8x8)
    [[1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,0,1],
     [1,0,1,1,1,1,0,1],
     [1,0,1,0,0,1,0,1],
     [1,0,1,0,0,1,0,1],
     [1,0,0,0,1,0,0,1],
     [1,0,1,0,1,0,'E',1],
     [1,1,1,1,1,1,1,1]],
    // Intro 3 (9x9)
    [[1,1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,1,0,0,1],
     [1,0,1,1,0,1,0,1,1],
     [1,0,0,1,0,0,0,0,1],
     [1,1,0,1,1,1,1,0,1],
     [1,0,0,0,0,0,1,0,1],
     [1,0,1,1,1,0,1,0,1],
     [1,0,0,0,1,0,0,'E',1],
     [1,1,1,1,1,1,1,1,1]],
    // Intro 4 (10x10)
    [[1,1,1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,0,1,0,1],
     [1,0,1,1,1,1,0,1,0,1],
     [1,0,0,0,0,1,0,0,0,1],
     [1,1,1,1,0,1,1,1,0,1],
     [1,0,0,1,0,0,0,1,0,1],
     [1,0,0,1,1,1,0,1,0,1],
     [1,0,1,0,0,0,0,1,0,1],
     [1,0,1,0,1,1,0,'E',0,1],
     [1,1,1,1,1,1,1,1,1,1]],
    // Intro 5 (11x11)
    [[1,1,1,1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,1,0,0,0,1],
     [1,0,1,1,1,0,1,0,1,0,1],
     [1,0,0,0,1,0,0,0,1,0,1],
     [1,1,1,0,1,1,1,0,1,0,1],
     [1,0,0,0,0,0,1,0,0,0,1],
     [1,0,1,1,1,0,1,1,1,0,1],
     [1,0,0,0,1,0,0,0,1,0,1],
     [1,1,0,0,1,1,1,0,1,0,1],
     [1,0,0,0,0,0,0,0,0,'E',1],
     [1,1,1,1,1,1,1,1,1,1,1]]
];
        const MAZE_DATA = [...INTRO_MAZES, 
            // Level 1 (15x15)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',1,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1],[1,0,0,0,1,0,1,0,1,0,1,0,0,'S',1],[1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,0,1,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,1,1],[1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 2 (15x15)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,0,1,0,1,0,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,1,'S',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 3 (15x15)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,'S',1,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 4 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',1,0,0,'S',1,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1],[1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 5 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1],[1,0,1,0,0,0,0,0,0,0,1,0,1,'E',0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 6 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,1],[1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1],[1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 7 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,'E',1],[1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1],[1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 8 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],[1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1],[1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1],[1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],[1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1],[1,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1],[1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 9 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],[1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1],[1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1],[1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1],[1,0,0,0,0,1,0,0,0,1,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,0,1,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 10 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 11 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1],[1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 12 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],[1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1],[1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,0,1],[1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1],[1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,0,1],[1,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,1],[1,0,1,1,1,1,0,1,'S',1,0,1,1,1,0,1,1],[1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,1],[1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1],[1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1],[1,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,1,0,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 13 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1],[1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1],[1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1],[1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1],[1,'E',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 14 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1],[1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 15 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,1,'S',0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1],[1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1,'E',0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
        ];
        
        
// ================= Landmark Hunt Levels (10 maps, sizes 5x5..10x10, incremental complexity) =================

const HUNT_MAZES = [
    // H1: 5x5, 2 landmarks (guaranteed path S->1->2->E)
    [[1,1,1,1,1],
     [1,'S',0,'1',1],
     [1,0,0,0,1],
     [1,0,'2','E',1],
     [1,1,1,1,1]],

    // H2: 6x6, 3 landmarks
    [[1,1,1,1,1,1],
     [1,'S',0,0,'1',1],
     [1,0,1,0,0,1],
     [1,0,1,0,'2',1],
     [1,0,0,0,'3','E'],
     [1,1,1,1,1,1]],

    // H3: 6x6, 3 landmarks
    [[1,1,1,1,1,1],
     [1,'S',0,0,0,1],
     [1,0,1,1,0,1],
     [1,'1',0,1,0,1],
     [1,'2',0,0,'3','E'],
     [1,1,1,1,1,1]],

    // H4: 7x7, 3 landmarks
    [[1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,1],
     [1,0,1,1,1,0,1],
     [1,'1',0,0,1,0,1],
     [1,0,1,0,1,'2',1],
     [1,0,0,0,0,'3','E'],
     [1,1,1,1,1,1,1]],

    // H5: 7x7, 4 landmarks
    [[1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,1],
     [1,0,1,1,1,0,1],
     [1,'1',0,0,1,0,1],
     [1,0,1,0,1,'2',1],
     [1,0,'3',0,0,'4','E'],
     [1,1,1,1,1,1,1]],

    // H6: 8x8, 4 landmarks
    [[1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,0,1],
     [1,0,1,1,1,1,0,1],
     [1,'1',0,0,0,1,0,1],
     [1,0,1,1,0,1,'2',1],
     [1,0,0,1,0,0,'3','E'],
     [1,0,0,0,1,0,'4',1],
     [1,1,1,1,1,1,1,1]],

    // H7: 8x8, 5 landmarks
    [[1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,0,1],
     [1,0,1,1,1,1,0,1],
     [1,'1',0,0,0,1,0,1],
     [1,0,1,1,0,1,'2',1],
     [1,0,0,1,0,0,'3','E'],
     [1,0,0,0,1,'4','5',1],
     [1,1,1,1,1,1,1,1]],

    // H8: 9x9, 5 landmarks
    [[1,1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,1,0,1],
     [1,0,1,1,0,1,1,0,1],
     [1,'1',0,1,0,0,0,0,1],
     [1,0,0,1,1,1,1,'2',1],
     [1,0,1,0,0,0,1,'3',1],
     [1,0,1,1,1,0,1,'4',1],
     [1,0,0,0,1,0,0,'5','E'],
     [1,1,1,1,1,1,1,1,1]],

    // H9: 10x10, 5 landmarks (simplified connectivity)
    [[1,1,1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,0,0,0,1],
     [1,0,1,1,1,1,1,1,0,1],
     [1,'1',0,0,0,0,0,1,0,1],
     [1,0,1,1,1,1,0,1,0,1],
     [1,0,0,1,0,0,0,1,'2',1],
     [1,0,0,1,1,1,0,1,'3','E'],
     [1,0,0,0,0,1,0,1,'4',1],
     [1,0,1,1,0,0,0,0,'5',1],
     [1,1,1,1,1,1,1,1,1,1]],

    // H10: 10x10, 5 landmarks
    [[1,1,1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,1,0,0,0,1],
     [1,0,1,1,0,1,0,1,0,1],
     [1,'1',0,1,0,1,0,1,0,1],
     [1,0,0,1,0,0,0,1,'2',1],
     [1,0,1,1,1,1,0,1,'3',1],
     [1,0,0,0,0,1,0,1,'4','E'],
     [1,0,1,1,0,1,0,0,0,1],
     [1,0,0,1,0,0,0,1,'5',1],
     [1,1,1,1,1,1,1,1,1,1]]
];


function buildHuntLevels(huntMazes) {
    const huntLevels = [];
    for (let idx = 0; idx < huntMazes.length; idx++) {
        const mazeData = huntMazes[idx];
        const grid = [];
        let start = {}, goal = {};
        const landmarks = [];
        const H = mazeData.length, W = mazeData[0].length;
        for (let z = 0; z < H; z++) {
            const row = [];
            for (let x = 0; x < W; x++) {
                const cell = mazeData[z][x];
                if (cell === 'S') {
                    start = { x, z, dir: 'S' };
                    row.push(1);
                } else if (cell === 'E') {
                    goal = { x, z };
                    row.push(1);
                } else if (typeof cell === 'string' && /^[1-5]$/.test(cell)) {
                    const id = parseInt(cell, 10);
                    landmarks.push({ x, z, id });
                    row.push(1);
                } else {
                    row.push(cell === 1 ? 0 : 1);
                }
            }
            grid.push(row);
        }
        // orient start
        if (start.x === 0) start.dir = 'E';
        else if (start.x === W - 1) start.dir = 'W';
        else if (start.z === 0) start.dir = 'S';
        else if (start.z === H - 1) start.dir = 'N';
        landmarks.sort((a, b) => a.id - b.id);
        let level = { grid, start, goal, landmarks, hunt: true };
        level = enforceLandmarkSpacing(level);
        huntLevels.push(level);
    }
    return huntLevels;
}

        const levels = MAZE_DATA.map(mazeData => {
            const grid = [];
            let start = {};
            let goal = {};
            const height = mazeData.length;
            const width = mazeData[0].length;

            for(let z = 0; z < height; z++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    const cell = mazeData[z][x];
                    if (cell === 'S') {
                        start = { x, z, dir: 'S' };
                        row.push(1);
                    } else if (cell === 'E') {
                        goal = { x, z };
                        row.push(1);
                    } else {
                        row.push(cell === 1 ? 0 : 1);
                    }
                }
                grid.push(row);
            }
            
            if (start.x === 0) start.dir = 'E';
            else if (start.x === width - 1) start.dir = 'W';
            else if (start.z === 0) start.dir = 'S';
            else if (start.z === height - 1) start.dir = 'N';

            return { grid, start, goal };
        });

        // Append Landmark Hunt levels to levels and record index range
        const __baseCount = levels.length;
        const __huntLevels = buildHuntLevels(HUNT_MAZES);
        window.__huntStartIndex = __baseCount;
        __huntLevels.forEach(lv => levels.push(lv));
        window.__huntEndIndex = levels.length; // exclusive


        // ====================================================================
        // 初始化函数 (Initialization)
        // ====================================================================
        
        function init() {
            scene = new THREE.Scene();
            
            // === DEBUG: Resilient Skybox Loader ===
            // The original code was trying to load local files (e.g., 'px.jpg'),
            // which is blocked by browser CORS policy when opening an HTML file directly.
            // This function is modified to always use the gradient fallback,
            // avoiding the CORS errors. The original skybox loading is commented out.
         function setupSkyBackground() {
  const loader = new THREE.TextureLoader();
  loader.load(
    'assets/sky_gradient_starry.png',
    function (texture) {
      // 使用 equirectangular 映射，使全景天空正确显示
      texture.mapping = THREE.EquirectangularReflectionMapping;
      // 设置场景背景和环境贴图为星空纹理
      scene.background = texture;
      scene.environment = texture;
    },
    undefined,
    function (err) {
      console.info('Sky texture not loaded (fallback to solid color).', err);
      // 如果加载失败，可设置备用颜色或简易渐变
      if (typeof renderer !== 'undefined' && renderer.setClearColor) {
        renderer.setClearColor(0x0a152b, 1); // 备用深色天空
      }
    }
  );
}


            setupSkyBackground();
            
            scene.fog = new THREE.Fog(0x87ceeb, TILE_SIZE * 7, TILE_SIZE * 28);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);
            renderer.setClearColor(scene.fog.color, 1);
            clock = new THREE.Clock();

            hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
            hemisphereLight.position.set(0, 20, 0);
            scene.add(hemisphereLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
            dirLight.position.set(-1, 1.75, 1);
            dirLight.position.multiplyScalar(30);
            scene.add(dirLight);

            player = new THREE.Object3D();
            scene.add(player);
            player.add(camera);

            camera.position.set(0, WALL_HEIGHT * 0.4, 0);
            camera.rotation.x = THREE.MathUtils.degToRad(-8);

            const headLight = new THREE.SpotLight(0xffffff, 10, 8 * TILE_SIZE, Math.PI / 4, 0.5, 1.5);
            headLight.position.set(0, 0, 1);
            camera.add(headLight);

            mazeGroup = new THREE.Group();
            sceneryGroup = new THREE.Group();
            scene.add(mazeGroup);
            scene.add(sceneryGroup);
            
            landmarksGroup = new THREE.Group();
            camera.add(landmarksGroup);
            
            steeringWheel = createSteeringWheel();
            camera.add(steeringWheel);
            
            minimap = document.getElementById('minimap-canvas');
            minimapCtx = minimap.getContext('2d');

            createMaterials();
            loadCustomLevels();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            setupUI();
            updateUIText();
            
            createStarField();
            
            animate();
        }

        function setupUI() {
            document.getElementById('initial-language-select').addEventListener('change', (e) => {
                currentLanguage = e.target.value;
                updateUIText();
            });

            document.getElementById('start-game-btn').addEventListener('click', () => {
                currentLanguage = document.getElementById('initial-language-select').value;
                document.getElementById('language-select').value = currentLanguage;

                const nickname = document.getElementById('nickname-input').value.trim();
                playerInfo.nickname = nickname || (currentLanguage === 'zh' ? '司机' : 'Driver');
                playerInfo.gender = document.getElementById('gender-select').value;

                document.getElementById('startup-modal').style.display = 'none';
                document.getElementById('main-menu-modal').style.display = 'flex';
                updateUIText();
                gameState = 'MAIN_MENU';
            });

            const setupMenuInfo = (buttonId, infoBoxId, descriptionKey) => {
                const button = document.getElementById(buttonId);
                const infoBox = document.getElementById(infoBoxId);
                if (button && infoBox) {
                    button.addEventListener('mouseover', () => {
                        infoBox.innerHTML = `<p>${translations[currentLanguage][descriptionKey]}</p>`;
                    });
                    button.addEventListener('mouseout', () => {
                        infoBox.innerHTML = '';
                    });
                }
            };

            setupMenuInfo('campaign-mode-btn', 'main-menu-info-box', 'desc_campaign');
            setupMenuInfo('free-mode-btn', 'main-menu-info-box', 'desc_free');
            setupMenuInfo('custom-mode-btn', 'main-menu-info-box', 'desc_custom');
            setupMenuInfo('editor-mode-btn', 'main-menu-info-box', 'desc_editor');
            
            setupMenuInfo('mode-select-minimap-btn', 'nav-mode-info-box', 'desc_minimap');
            setupMenuInfo('mode-select-challenge-btn', 'nav-mode-info-box', 'desc_challenge');


            document.getElementById('campaign-mode-btn').addEventListener('click', () => {
                gameMode = 'campaign';
                document.getElementById('main-menu-modal').style.display = 'none';
                document.getElementById('mode-select-modal').style.display = 'flex';
            });

            document.getElementById('free-mode-btn').addEventListener('click', () => {
                gameMode = 'free'; 
                document.getElementById('main-menu-modal').style.display = 'none';
                document.getElementById('mode-select-modal').style.display = 'flex';
            });
            
            document.getElementById('editor-mode-btn').addEventListener('click', () => showEditor());
            
            
            document.getElementById('custom-mode-btn').addEventListener('click', () => {
                if (customLevels.some(level => level !== null)) {
                    gameMode = 'custom';
                    showCustomMapsModal();
                }
            });
            
            function startGameFromModeSelect() {
                document.getElementById('mode-select-modal').style.display = 'none';
                
                if (gameMode === 'free') {
                    setupDevPanel();
                    document.getElementById('dev-panel').style.display = 'block';
                    loadLevel(0);
                } else if (gameMode === 'custom') {
                    loadLevel(customLevels[selectedCustomMapIndex]);
                } else if (gameMode === 'campaign') {
                    document.getElementById('dev-panel').style.display = 'none';
                    loadLevel(0);
                } else if (gameMode === 'hunt') {
                    document.getElementById('dev-panel').style.display = 'none';
                    if (typeof window.__huntStartIndex === 'number') {
                        loadLevel(window.__huntStartIndex);
                    } else {
                        loadLevel(levels.length - 1); // fallback
                    }
                }
            }

            document.getElementById('mode-select-minimap-btn').addEventListener('click', () => {
                navigationMode = 'minimap';
                startGameFromModeSelect();
            });
            
            document.getElementById('mode-select-challenge-btn').addEventListener('click', () => {
                navigationMode = 'limited';
                startGameFromModeSelect();
            });

            document.getElementById('next-level-btn').addEventListener('click', () => {
                document.getElementById('level-complete-modal').style.display = 'none';
                if (currentLevelIndex !== -1) {
                    currentLevelIndex++;
                    if (currentLevelIndex < levels.length) {
                        loadLevel(currentLevelIndex);
                    } else {
                        alert(translations[currentLanguage].allLevelsCleared);
                        showMainMenu();
                    }
                }
            });
            document.getElementById('main-menu-btn').addEventListener('click', () => {
                document.getElementById('level-complete-modal').style.display = 'none';
                showMainMenu();
            });

            document.getElementById('minimap-container').addEventListener('click', () => {
                if (gameState === 'BIG_MAP') {
                    const bigMapViewModal = document.getElementById('big-map-view-modal');
                    const minimapContainer = document.getElementById('minimap-container');
                    bigMapViewModal.style.display = 'none';
                    document.body.appendChild(minimapContainer); 
                    
                    const container = document.getElementById('minimap-container');
                    if (navigationMode === 'limited') {
                        container.style.display = 'none';
                    } else {
                        container.classList.remove('big-map');
                        container.classList.add('small-map');
                    }
                    gameState = 'AT_INTERSECTION';
                    checkForTurns();
                    
                    showIngameHint('hint_driving_start'); // MODIFIED: Show specific hint

                } else if (gameState === 'CHALLENGE_MAP_VIEW') {
                    toggleChallengeMap();
                }
            });

            document.getElementById('settings-button').addEventListener('click', () => {
                document.getElementById('settings-panel').style.display = 'flex';
            });
            document.getElementById('close-settings-btn').addEventListener('click', () => {
                document.getElementById('settings-panel').style.display = 'none';
            });
            document.getElementById('font-size-slider').addEventListener('input', (e) => {
                document.body.style.fontSize = `calc(${getComputedStyle(document.body).getPropertyValue('--font-size-normal')} * ${e.target.value})`;
            });
            document.getElementById('minimap-size-slider').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--minimap-scale', e.target.value);
            });
            document.getElementById('language-select').addEventListener('change', (e) => {
                currentLanguage = e.target.value;
                document.getElementById('initial-language-select').value = currentLanguage;
                updateUIText();
            });
            
            document.getElementById('resume-game-btn').addEventListener('click', togglePauseMenu);
            document.getElementById('pause-to-main-menu-btn').addEventListener('click', () => {
                togglePauseMenu();
                showMainMenu();
            });
            document.getElementById('level-select-btn').addEventListener('click', showLevelSelectModal);
            
            document.getElementById('reset-game-btn').addEventListener('click', () => {
                document.getElementById('confirm-reset-modal').style.display = 'flex';
            });
            
            document.getElementById('confirm-reset-btn').addEventListener('click', () => {
                document.getElementById('confirm-reset-modal').style.display = 'none';
                resetGame();
            });

            document.getElementById('cancel-reset-btn').addEventListener('click', () => {
                document.getElementById('confirm-reset-modal').style.display = 'none';
            });

            document.getElementById('close-level-select-btn').addEventListener('click', () => {
                document.getElementById('level-select-modal').style.display = 'none';
                document.getElementById('pause-menu-modal').style.display = 'flex';
            });
        }

        function setupDevPanel() {
            const select = document.getElementById('level-select');
            select.innerHTML = '';
            levels.forEach((_, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${translations[currentLanguage].level} ${index + 1}`;
                select.appendChild(option);
            });
            select.addEventListener('change', (e) => {
                loadLevel(parseInt(e.target.value));
            });
            // 让下拉保持与当前关卡同步
            select.value = String(currentLevelIndex);
        }
        
        function showMainMenu() {
            gameState = 'MAIN_MENU';
            document.getElementById('main-menu-modal').style.display = 'flex';
            document.getElementById('custom-mode-btn').disabled = !customLevels.some(level => level !== null);

            document.getElementById('main-menu-info-box').innerHTML = '';
            document.getElementById('nav-mode-info-box').innerHTML = '';

            while(mazeGroup.children.length > 0){ mazeGroup.remove(mazeGroup.children[0]); }
            while(landmarksGroup.children.length > 0){ landmarksGroup.remove(landmarksGroup.children[0]); }
            while(sceneryGroup.children.length > 0){ sceneryGroup.remove(sceneryGroup.children[0]); }
            if(goalMarker) scene.remove(goalMarker);

            document.getElementById('minimap-container').style.display = 'none';
            document.getElementById('map-view-count').style.display = 'none';
            document.getElementById('big-map-prompt').style.display = 'none';
            document.getElementById('ingame-hint').style.display = 'none';
            clearTimeout(hintTimeout);
        }

        // ====================================================================
        // 游戏核心逻辑 (Core Game Logic)
        // ====================================================================
        
        function loadLevel(levelData) {
            let level;
            if (typeof levelData === 'number') {
                if (levelData >= levels.length) {
                    console.error(`Level index ${levelData} out of bounds!`);
                    showMainMenu();
                    return;
                }
                currentLevelIndex = levelData;
                level = levels[levelData];
            } else {
                level = levelData;
                currentLevelIndex = -1;
            }
            
            clearTimeout(hintTimeout);
            document.getElementById('ingame-hint').style.display = 'none';

            playerChoices = 0;
            document.getElementById('choice-prompt').style.display = 'none';

            while(mazeGroup.children.length > 0){ mazeGroup.remove(mazeGroup.children[0]); }
            while(landmarksGroup.children.length > 0){ camera.remove(landmarksGroup); landmarksGroup = new THREE.Group(); camera.add(landmarksGroup); }
            if (huntGroup) {
                huntGroup.traverse(o=>{ if (o.userData && o.userData.mixer) o.userData.mixer.update(delta); }); scene.remove(huntGroup); huntGroup = null; }
            if (effectsGroup) { scene.remove(effectsGroup); effectsGroup = null; }
            while(sceneryGroup.children.length > 0){ sceneryGroup.remove(sceneryGroup.children[0]); }
            if(goalMarker) scene.remove(goalMarker);

            createMazeMesh(level.grid, level.goal);
            placeRoadsideObjects(level.grid);
            createGoalMarker(level.goal);
            if (level.landmarks && level.landmarks.length) { createHuntObjects(level); }
            
            const startPos = gridToWorld(level.start.x, level.start.z, level.grid);
            player.position.set(startPos.x, 0, startPos.z);
            player.rotation.y = dirToAngle(level.start.dir);
            targetRotation.y = player.rotation.y;

            let pathInfo;
            if (level.landmarks && level.landmarks.length) {
                const opt = computeHuntOptimal(level);
                pathInfo = opt != null ? {choices: opt} : findShortestPath(level);
            } else {
                pathInfo = findShortestPath(level);
            }
            // 同步开发者面板选择状态（自由模式）
            const dev = document.getElementById('level-select');
            if (dev && getComputedStyle(document.getElementById('dev-panel')).display === 'block' && currentLevelIndex >= 0) {
                dev.value = String(currentLevelIndex);
            }
            if (!pathInfo) {
                const message = `Level ${currentLevelIndex >= 0 ? currentLevelIndex + 1 : 'Custom'} is unsolvable!`;
                alert(message);
                console.error(message, level);
                showMainMenu();
                return;
            }
            optimalChoices = pathInfo.choices;
            console.log(`Level ${currentLevelIndex >= 0 ? currentLevelIndex + 1 : 'Custom'}: Optimal Steps = ${optimalChoices}`);
            
            if (navigationMode === 'limited') {
                mapViewChances = 3;
            }
            updateHUD();
            
            lastPlayerGridPos = { x: -1, z: -1 }; 
            updateMinimapPlayer();
            
            gameState = 'BIG_MAP';
            
            const bigMapViewModal = document.getElementById('big-map-view-modal');
            const bigMapWrapper = document.getElementById('big-map-container-wrapper');
            const minimapContainer = document.getElementById('minimap-container');

            bigMapWrapper.appendChild(minimapContainer);
            minimapContainer.style.display = 'block';
            minimapContainer.classList.remove('small-map');
            minimapContainer.classList.add('big-map');
            
            // The text is now part of the HTML, so we just need to ensure it's translated
            updateUIText();
            
            bigMapViewModal.style.display = 'flex';
            document.getElementById('big-map-prompt').style.display = 'none'; 
        }

        function gridToWorld(x, z, grid) {
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;
            return new THREE.Vector3(
                (x - gridWidth / 2 + 0.5) * TILE_SIZE,
                0,
                (z - gridHeight / 2 + 0.5) * TILE_SIZE
            );
        }
        
        function worldToGrid(position) {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            if (!level) return {x:0, z:0};
            const gridWidth = level.grid[0].length;
            const gridHeight = level.grid.length;
            return {
                x: Math.round(position.x / TILE_SIZE + gridWidth / 2 - 0.5),
                z: Math.round(position.z / TILE_SIZE + gridHeight / 2 - 0.5)
            };
        }
        
        function dirToAngle(dir) {
            switch (dir) {
                case 'N': return Math.PI;
                case 'E': return -Math.PI / 2;
                case 'S': return 0;
                case 'W': return Math.PI / 2;
            }
            return 0;
        }

        function checkForTurns() {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            const gridPos = worldToGrid(player.position);
            const { goal } = level;

            if (gridPos.x === goal.x && gridPos.z === goal.z) {
                if (!level.landmarks || !level.landmarks.length || (currentHunt.active && currentHunt.nextId > currentHunt.total)) {
                    gameState = 'LEVEL_COMPLETE';
                    showLevelComplete();
                    return;
                }
            }
            
            const availableTurns = createDirectionalHelpers();
            updateChoicePrompt(availableTurns);
            gameState = 'AT_INTERSECTION';
        }

        function cameraShake() {
            const shakeIntensity = 0.05;
            let shakeDuration = 200;
            const startTime = Date.now();

            function shake() {
                const elapsedTime = Date.now() - startTime;
                if (elapsedTime > shakeDuration) {
                    camera.position.set(0, WALL_HEIGHT * 0.4, 0);
                    return;
                }
                const progress = elapsedTime / shakeDuration;
                const shakeAmount = shakeIntensity * (1 - progress);
                const shakeX = (Math.random() - 0.5) * shakeAmount;
                const shakeY = (Math.random() - 0.5) * shakeAmount;
                camera.position.set(shakeX, WALL_HEIGHT * 0.4 + shakeY, 0);
                requestAnimationFrame(shake);
            }
            shake();
        }
        
        function showTemporaryMessage(message, duration = 2000) {
            const prompt = document.getElementById('choice-prompt');
            prompt.textContent = message;
            prompt.style.display = 'inline-block';

            clearTimeout(promptTimeout);
            promptTimeout = setTimeout(() => {
                if (gameState === 'AT_INTERSECTION') {
                    checkForTurns();
                }
            }, duration);
        }

        function updateChoicePrompt(availableTurns) {
            const prompt = document.getElementById('choice-prompt');
            const helperToggle = document.getElementById('helper-text-toggle').value;
            const lang = translations[currentLanguage];

            if (gameState !== 'AT_INTERSECTION' || helperToggle === 'off') {
                prompt.style.display = 'none';
                return;
            }
            
            prompt.style.display = 'inline-block';
            
            const options = [];
            // MODIFIED: Updated prompt to show 'W' key
            if (availableTurns.forward) options.push(`${lang.forward} [W]`);
            if (availableTurns.left) options.push(`${lang.turnLeft} [A]`);
            if (availableTurns.right) options.push(`${lang.turnRight} [D]`);

            if (!availableTurns.forward && !availableTurns.left && !availableTurns.right) {
                prompt.textContent = lang.prompt_dead_end;
            } else if (options.length > 0) {
                prompt.textContent = lang.prompt_options(options);
            } else {
                prompt.textContent = lang.turnAround; 
            }
        }

        function setupMove() {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            const gridPos = worldToGrid(player.position);
            const moveVector = new THREE.Vector3(0, 0, -1).applyEuler(player.rotation);
            const nextGridX = gridPos.x + Math.round(moveVector.x);
            const nextGridZ = gridPos.z + Math.round(moveVector.z);

            if ((!level.landmarks || !level.landmarks.length) && nextGridX === level.goal.x && nextGridZ === level.goal.z) {
                showTemporaryMessage(translations[currentLanguage].prompt_near_goal, 2500);
            }

            if (nextGridZ < 0 || nextGridZ >= level.grid.length || nextGridX < 0 || nextGridX >= level.grid[0].length || level.grid[nextGridZ][nextGridX] === 0) {
                cameraShake();
                showTemporaryMessage(translations[currentLanguage].prompt_wall);
            } else {
                playerChoices++;
                document.getElementById('choice-prompt').style.display = 'none';
                while (landmarksGroup.children.length > 0) {
                    landmarksGroup.remove(landmarksGroup.children[0]);
                }
                targetPosition.copy(gridToWorld(nextGridX, nextGridZ, level.grid));
                gameState = 'DRIVING';
            }
        }
        
        function showLevelComplete() {
            const modal = document.getElementById('level-complete-modal');
            const stats = document.getElementById('results-stats');
            const medalEl = document.getElementById('results-medal');
            const quoteEl = document.getElementById('results-quote');
            const nextBtn = document.getElementById('next-level-btn');
            const lang = translations[currentLanguage];
            
            nextBtn.style.display = 'none';

            if (gameMode === 'campaign') {
                unlockedLevel = Math.max(unlockedLevel, currentLevelIndex + 1);
                const R = optimalChoices > 0 ? playerChoices / optimalChoices : 1;
                let medal = '';
                let title = '';
                let quote = '';

                if (R <= 1.0) {
                    medal = '🥇';
                    title = lang.drivingGenius;
                    quote = lang.quoteGenius;
                } else if (R <= 1.5) {
                    medal = '🥈';
                    title = lang.greatDriver;
                    quote = lang.quoteGreat;
                } else {
                    medal = '🥉';
                    title = lang.newDriver;
                    quote = lang.quoteNew;
                }
                
                medalEl.textContent = medal;
                document.getElementById('results-title').textContent = title;
                stats.textContent = lang.stats(playerChoices, optimalChoices, R.toFixed(2));
                quoteEl.textContent = quote;
                
                stats.style.display = 'block';
                medalEl.style.display = 'block';
                quoteEl.style.display = 'block';

                if (currentLevelIndex !== -1 && ((gameMode === 'hunt' && currentLevelIndex < window.__huntEndIndex - 1) || (gameMode !== 'hunt' && currentLevelIndex < levels.length - 1))) {
                    nextBtn.textContent = lang.nextLevel;
                    nextBtn.style.display = 'inline-block';
                }

            } else {
                document.getElementById('results-title').textContent = lang.levelComplete;
                stats.style.display = 'none';
                medalEl.style.display = 'none';
                quoteEl.textContent = lang.freeModeComplete;
            }
            
            modal.style.display = 'flex';
        }

        // ====================================================================
        // 渲染和动画 (Rendering & Animation)
        // ====================================================================
        
        function animate() {
            requestAnimationFrame(animate);
            if(gameState === 'PAUSED' || gameState === 'CHALLENGE_MAP_VIEW') return;
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            const dayNightCycle = (Math.sin(elapsedTime * (0.1 / 3)) + 1) / 2; // 1 for day, 0 for night
            const skyDay = new THREE.Color(0x87ceeb);
            const skyNight = new THREE.Color(0x210033); 
            const visualColor = skyNight.clone().lerp(skyDay, dayNightCycle);

            if (scene.fog) {
                scene.fog.color.copy(visualColor);
            }
            if (!scene.background || !scene.background.isCubeTexture) {
                 scene.background = visualColor;
            }
            renderer.setClearColor(visualColor, 1);

            hemisphereLight.intensity = dayNightCycle * 2.0 + 0.4;
            dirLight.intensity = dayNightCycle * 2.5 + 0.3;

            const nightIntensity = Math.max(0, 1 - dayNightCycle * 3);

            sceneryGroup.children.forEach(sceneryObject => {
                const light = sceneryObject.getObjectByName('lampLight');
                if (light) {
                    light.intensity = nightIntensity * 8;
                }
            });


            if (goalMarker) {
                goalMarker.position.y = WALL_HEIGHT/2 - 1.5 + Math.sin(elapsedTime) * 0.2;
                goalMarker.rotation.y += delta * 0.4;
                if (luckyCatArm) {
                    const toRad = THREE.MathUtils.degToRad;
                    const c  = toRad(LUCKY_CAT.WAVE_CENTER_DEG);
                    const a  = toRad(LUCKY_CAT.WAVE_AMPL_DEG);
                    const w1 = LUCKY_CAT.WAVE_SPEED;

                    luckyCatArm.rotation.x = c + Math.sin(elapsedTime * w1) * a;

                    if (typeof luckyCatWrist !== 'undefined' && luckyCatWrist) {
                        const a2 = toRad(LUCKY_CAT.WRIST_AMPL_DEG);
                        const w2 = LUCKY_CAT.WRIST_SPEED;
                        luckyCatWrist.rotation.x = Math.sin(elapsedTime * w2) * a2;
                    }
                }
            }
            if (typeof floatingHeart !== 'undefined' && floatingHeart) {
                const t = elapsedTime * 1.5;
                floatingHeart.position.y = floatingHeart.userData.baseY + Math.sin(t) * 0.18;
                const s = 1.0 + Math.sin(t * 2.0) * 0.06;
                floatingHeart.scale.set(s, s, s);
                floatingHeart.rotation.y += delta * 0.6;
            }

            if (gameState === 'TURNING') {
                let angleDiff = targetRotation.y - player.rotation.y;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

                if (Math.abs(angleDiff) > 0.01) {
                    const turnStep = Math.sign(angleDiff) * TURN_SPEED * delta;
                    if (Math.abs(turnStep) >= Math.abs(angleDiff)) {
                        player.rotation.y = targetRotation.y;
                    } else {
                        player.rotation.y += turnStep;
                    }
                } else {
                    player.rotation.y = targetRotation.y;
                    gameState = 'AT_INTERSECTION';
                    checkForTurns();
                }
            }
            
            if (gameState === 'DRIVING') {
                const distanceToTarget = player.position.distanceTo(targetPosition);
                if (distanceToTarget > 0.01) {
                    const moveVector = targetPosition.clone().sub(player.position).normalize();
                    const moveDistance = Math.min(distanceToTarget, MOVE_SPEED * delta);
                    player.position.add(moveVector.multiplyScalar(moveDistance));
                } else {
                    player.position.copy(targetPosition);
                    gameState = 'AT_INTERSECTION';
                    checkForTurns();
                }
            }
            
            if (huntGroup) {
                huntGroup.traverse(o=>{ if (o.userData && o.userData.mixer) o.userData.mixer.update(delta); });
                huntGroup.children.forEach(d => {
                    const idle = Math.sin(elapsedTime*1.8 + (d.userData.id||0))*0.05;
                    if (d.userData.collected) {
                        const target = d.userData.floatYTarget || 1.2;
                        const spd = d.userData.floatSpeed || 0.8;
                        d.position.y = Math.min(target, (d.position.y||0) + spd*delta);
                        d.rotation.y += delta*0.8; // slightly faster spin when collected
                    } else {
                        d.position.y = idle;
                    }
                });
            }
            updateEffects(delta);

            if (steeringWheel) {
                steeringWheel.rotation.z = (player.rotation.y - targetRotation.y) * 2;
            }
            
            if (['DRIVING', 'TURNING', 'AT_INTERSECTION', 'BIG_MAP'].includes(gameState)) {
                updateMinimapPlayer();
            }

            landmarksGroup.traverse(child => {
                if (child.name === 'arrowGlow') {
                    child.material.opacity = (Math.sin(elapsedTime * 6 + child.userData.phase) + 1) / 2 * 0.6 + 0.1; 
                }
            });

            if (typeof starField !== 'undefined' && starField && starField.material) {
                const nightFactor = Math.max(0, 1 - dayNightCycle * 1.15);
                starField.material.opacity = Math.min(1.0, Math.pow(nightFactor, 0.6) * 1.2);
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ====================================================================
        // 输入处理 (Input Handling)
        // ====================================================================
        
        function onKeyDown(event) {
            if (!event || !event.key) return;
            const key = event.key.toLowerCase();
            if (keyState[key]) return;
            keyState[key] = true;

            if (key === 'escape') {
                togglePauseMenu();
                return;
            }
            
            if (key === 'e') {
                if (navigationMode === 'limited') {
                    toggleChallengeMap();
                }
                return;
            }

            if (gameState !== 'AT_INTERSECTION') return;
            
            if (key === 'a' || key === 'd') {
                if (keyDebounce) return;
                keyDebounce = true;
                setTimeout(() => { keyDebounce = false; }, 100);

                if (key === 'd') {
                    targetRotation.y -= Math.PI / 2;
                } else if (key === 'a') {
                    targetRotation.y += Math.PI / 2;
                }
                gameState = 'TURNING';
            // MODIFIED: Changed key check from 'space' to 'w'
            } else if (key === 'w') {
                setupMove();
            }
        }
        
        function onKeyUp(event) {
            if (!event || !event.key) return;
            const key = event.key.toLowerCase();
            keyState[key] = false;
        }

        // ====================================================================
        // 3D迷宫与视觉生成 (3D Maze & Visuals Generation)
        // ====================================================================

        
// === Bollard lamps between adjacent cells ===
function createBollardLamp({
  postHeight = 0.6,
  postRadiusTop = 0.05,
  postRadiusBottom = 0.06,
  headRadius = 0.08,
  colorPost = 0x333333,
  colorHead = 0xffd700,
  lightColor = 0xffee88,
  lightIntensity = 1.3,
  lightDistance = 2.4,
  castShadow = true
} = {}) {
  const group = new THREE.Group();

  const postGeo = new THREE.CylinderGeometry(postRadiusTop, postRadiusBottom, postHeight, 16);
  const postMat = new THREE.MeshStandardMaterial({ color: colorPost, metalness: 0.2, roughness: 0.8 });
  const post = new THREE.Mesh(postGeo, postMat);
  post.castShadow = castShadow;
  post.receiveShadow = castShadow;
  post.position.y = postHeight / 2;
  group.add(post);

  const headGeo = new THREE.SphereGeometry(headRadius, 16, 12);
  const headMat = new THREE.MeshStandardMaterial({
    color: colorHead, emissive: colorHead, emissiveIntensity: 1.4, metalness: 0.0, roughness: 0.4
  });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = postHeight + headRadius * 0.6;
  head.castShadow = castShadow;
  group.add(head);

  const light = new THREE.PointLight(lightColor, lightIntensity, lightDistance, 2.0);
  light.position.set(0, head.position.y + 0.02, 0);
  light.castShadow = castShadow;
  group.add(light);

  return group;
}

function addBollardsBetweenCells(mazeGroup, gridWidth, gridHeight, TILE_SIZE) {
  const halfW = (gridWidth * TILE_SIZE) / 2;
  const halfH = (gridHeight * TILE_SIZE) / 2;
  const sideOffset = TILE_SIZE * 0.18;
  const edgeClearance = 0.02;
  const lampParams = { postHeight: 0.6, headRadius: 0.08, lightIntensity: 1.3, lightDistance: 2.4 };

  // Vertical seams (between X-adjacent cells), seam line along Z
  for (let i = 0; i < gridWidth - 1; i++) {
    const seamX = -halfW + (i + 1) * TILE_SIZE;
    for (let j = 0; j < gridHeight; j++) {
      const centerZ = -halfH + (j + 0.5) * TILE_SIZE;
      const L = createBollardLamp(lampParams); L.position.set(seamX - sideOffset, edgeClearance, centerZ); mazeGroup.add(L);
      const R = createBollardLamp(lampParams); R.position.set(seamX + sideOffset, edgeClearance, centerZ); mazeGroup.add(R);
    }
  }
  // Horizontal seams (between Z-adjacent cells), seam line along X
  for (let j = 0; j < gridHeight - 1; j++) {
    const seamZ = -halfH + (j + 1) * TILE_SIZE;
    for (let i = 0; i < gridWidth; i++) {
      const centerX = -halfW + (i + 0.5) * TILE_SIZE;
      const N = createBollardLamp(lampParams); N.position.set(centerX, edgeClearance, seamZ - sideOffset); mazeGroup.add(N);
      const S = createBollardLamp(lampParams); S.position.set(centerX, edgeClearance, seamZ + sideOffset); mazeGroup.add(S);
    }
  }
}

function createMazeMesh(grid, goal) {
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;

            const floorPlane = new THREE.PlaneGeometry(gridWidth * TILE_SIZE, gridHeight * TILE_SIZE);
            const floor = new THREE.Mesh(floorPlane, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            mazeGroup.add(floor);
            if (floor.material && floor.material.map) {
                floor.material.map.repeat.set(gridWidth, gridHeight);
                floor.material.map.needsUpdate = true;
            }

            const wallGeo = new THREE.PlaneGeometry(TILE_SIZE, WALL_HEIGHT);

            for (let z = 0; z < gridHeight; z++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[z][x] === 1) {
                        const worldPos = gridToWorld(x, z, grid);
                        const isNearGoal = Math.abs(x - goal.x) <= 1 && Math.abs(z - goal.z) <= 1 && !(x === goal.x && z === goal.z);

                        if (z > 0 && grid[z - 1][x] === 0) {
                             const material = isNearGoal && z - 1 === goal.z ? goalWallMaterial : wallMaterialNS;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x, WALL_HEIGHT / 2, worldPos.z - TILE_SIZE / 2);
                             mazeGroup.add(wall);
                        }
                        if (z < gridHeight - 1 && grid[z + 1][x] === 0) {
                             const material = isNearGoal && z + 1 === goal.z ? goalWallMaterial : wallMaterialNS;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x, WALL_HEIGHT / 2, worldPos.z + TILE_SIZE / 2);
                             wall.rotation.y = Math.PI;
                             mazeGroup.add(wall);
                        }
                        if (x > 0 && grid[z][x - 1] === 0) {
                             const material = isNearGoal && x - 1 === goal.x ? goalWallMaterial : wallMaterialEW;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x - TILE_SIZE / 2, WALL_HEIGHT / 2, worldPos.z);
                             wall.rotation.y = Math.PI / 2;
                             mazeGroup.add(wall);
                        }
                        if (x < gridWidth - 1 && grid[z][x + 1] === 0) {
                             const material = isNearGoal && x + 1 === goal.x ? goalWallMaterial : wallMaterialEW;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x + TILE_SIZE / 2, WALL_HEIGHT / 2, worldPos.z);
                             wall.rotation.y = -Math.PI / 2;
                             mazeGroup.add(wall);
                        }
                    }
                }
            }
        }
        
        function createLuckyCat() {
            const catGroup = new THREE.Group();
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.25, metalness: 0.1 });
            const redMat   = new THREE.MeshStandardMaterial({ color: 0xaa2222, roughness: 0.35, metalness: 0.1 });
            const goldMat  = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.1,  metalness: 0.5 });
            const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
            const pinkMat  = new THREE.MeshStandardMaterial({ color: 0xffc0cb, roughness: 0.4 });
            const body = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 16), whiteMat);
            body.scale.y = 0.8;
            catGroup.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(1.2, 32, 16), whiteMat);
            head.position.y = 1.8;
            catGroup.add(head);
            const eyeGeo = new THREE.SphereGeometry(0.1, 12, 8);
            const leftEye  = new THREE.Mesh(eyeGeo, blackMat); leftEye.position.set(-0.4, 0.2, 1.11); head.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, blackMat); rightEye.position.set( 0.4, 0.2, 1.11); head.add(rightEye);
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), blackMat);
            nose.position.set(0, 0, 1.18); nose.scale.set(1.5, 1, 1); head.add(nose);
            const lineMat = new THREE.LineBasicMaterial({ color: 0x111111, linewidth: 2 });
            for (let i = 0; i < 3; i++) {
                const whiskerL = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-0.2, -0.1, 1.15), new THREE.Vector3(-1.2, -i * 0.15, 0.8)
                ]), lineMat);
                const whiskerR = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3( 0.2, -0.1, 1.15), new THREE.Vector3( 1.2, -i * 0.15, 0.8)
                ]), lineMat);
                head.add(whiskerL, whiskerR);
            }
            const earOuterGeo = new THREE.ConeGeometry(0.4, 0.8, 12);
            const earInnerGeo = new THREE.ConeGeometry(0.28, 0.5, 12);
            const leftEar = new THREE.Mesh(earOuterGeo, whiteMat);
            leftEar.position.set(-0.8, 2.8, 0.06); leftEar.rotation.z = Math.PI / 10;
            catGroup.add(leftEar);
            const leftInner = new THREE.Mesh(earInnerGeo, pinkMat);
            leftInner.position.set(0, -0.05, 0.15); leftInner.rotation.x = -Math.PI / 12;
            leftEar.add(leftInner);
            const rightEar = new THREE.Mesh(earOuterGeo, whiteMat);
            rightEar.position.set( 0.8, 2.8, 0.06); rightEar.rotation.z = -Math.PI / 10;
            catGroup.add(rightEar);
            const rightInner = new THREE.Mesh(earInnerGeo, pinkMat);
            rightInner.position.set(0, -0.05, 0.15); rightInner.rotation.x = -Math.PI / 12;
            rightEar.add(rightInner);
            const collar = new THREE.Mesh(new THREE.TorusGeometry(1.3, 0.1, 8, 32), redMat);
            collar.position.y = 1.2; collar.rotation.x = Math.PI / 2; catGroup.add(collar);
            const bell = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 8), goldMat);
            bell.position.set(0, 1.2, 1.3); catGroup.add(bell);
            luckyCatArm = new THREE.Object3D();
            luckyCatArm.position.set(-1.05, 1.1, 0.35);
            catGroup.add(luckyCatArm);
            const armCurvePoints = [
                new THREE.Vector3(0,   0.0, 0.0),
                new THREE.Vector3(0,   0.75, 0.25),
                new THREE.Vector3(0,   1.35, 0.40)
            ];
            const armCurve = new THREE.CatmullRomCurve3(armCurvePoints);
            const arm = new THREE.Mesh(new THREE.TubeGeometry(armCurve, 20, 0.30, 8, false), whiteMat);
            luckyCatArm.add(arm);
            luckyCatWrist = new THREE.Object3D();
            luckyCatWrist.position.copy(armCurvePoints[armCurvePoints.length - 1]);
            luckyCatArm.add(luckyCatWrist);
            const paw = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 12), whiteMat);
            paw.scale.set(1, 0.8, 1);
            paw.position.set(0, 0, 0);
            paw.rotation.y = 0;
            luckyCatWrist.add(paw);
            const mainPad = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 8), pinkMat);
            mainPad.position.set(0, -0.1, 0.30); mainPad.scale.set(1.2, 1, 0.5); paw.add(mainPad);
            for (let i = 0; i < 3; i++) {
                const pad = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), pinkMat);
                pad.position.set(-0.2 + i * 0.2, 0.1, 0.35); pad.scale.z = 0.5; paw.add(pad);
            }
            return catGroup;
        }

        function createGoalMarker(goalCoords) {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            const goalPos = gridToWorld(goalCoords.x, goalCoords.z, level.grid);
            goalMarker = new THREE.Group();
            const cat = createLuckyCat();
            cat.scale.set(1.5, 1.5, 1.5);
            goalMarker.add(cat);
            const heartShape = new THREE.Shape();
            const x = 0, y = 0, s = 0.6;
            heartShape.moveTo( x + 0.5*s, y + 0.5*s );
            heartShape.bezierCurveTo( x + 0.5*s, y + 0.5*s, x + 0.4*s, y + 0.0*s, x + 0.0*s, y + 0.0*s );
            heartShape.bezierCurveTo( x - 0.6*s, y + 0.0*s, x - 0.6*s, y + 0.7*s, x - 0.6*s, y + 0.7*s );
            heartShape.bezierCurveTo( x - 0.6*s, y + 1.1*s, x - 0.3*s, y + 1.54*s, x + 0.5*s, y + 1.9*s );
            heartShape.bezierCurveTo( x + 1.2*s, y + 1.54*s, x + 1.6*s, y + 1.1*s, x + 1.6*s, y + 0.7*s );
            heartShape.bezierCurveTo( x + 1.6*s, y + 0.7*s, x + 1.6*s, y + 0.0*s, x + 1.0*s, y + 0.0*s );
            heartShape.bezierCurveTo( x + 0.7*s, y + 0.0*s, x + 0.5*s, y + 0.5*s, x + 0.5*s, y + 0.5*s );
            const extrudeSettings = { depth: 0.25, bevelEnabled: true, bevelSegments: 2, steps: 1, bevelSize: 0.08, bevelThickness: 0.08 };
            const heartGeo = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            const heartMat = new THREE.MeshBasicMaterial({ color: 0xff4d6d, depthTest: true, depthWrite: true });
            const heart = new THREE.Mesh(heartGeo, heartMat);
            heart.position.set(0, 6.2, 0.2);
            heart.rotation.x = Math.PI;
            heart.scale.set(0.9, 0.9, 0.9);
            // renderOrder removed to honor depth testing
goalMarker.add(heart);
            floatingHeart = heart;
            floatingHeart.userData.baseY = heart.position.y;
            goalMarker.position.copy(goalPos);
            goalMarker.position.y = WALL_HEIGHT/2 - 1.5;
            scene.add(goalMarker);
        }
        
        function createDirectionalHelpers() {
            while (landmarksGroup.children.length > 0) {
                landmarksGroup.remove(landmarksGroup.children[0]);
            }
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            if (!level) return { forward: false, left: false, right: false };
            const gridPos = worldToGrid(player.position);

            const available = { forward: false, left: false, right: false };

            const arrowShape = new THREE.Shape();
            const w = 0.50;
            const h = 0.72;
            arrowShape.moveTo(0,  h/2);
            arrowShape.lineTo(w/2, 0);
            arrowShape.lineTo(w/4, 0);
            arrowShape.lineTo(w/4, -h/2);
            arrowShape.lineTo(-w/4, -h/2);
            arrowShape.lineTo(-w/4, 0);
            arrowShape.lineTo(-w/2, 0);
            arrowShape.closePath();
            const arrowGeo = new THREE.ShapeGeometry(arrowShape);

            const arrowMat = new THREE.MeshBasicMaterial({
                color: 0xffc107,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
            });
            
            function quantizeYaw(y) {
                return Math.round(y / (Math.PI / 2)) * (Math.PI / 2);
            }
            const baseYaw = quantizeYaw(player.rotation.y);
            
            function stepFromYaw(yaw) {
                const dirVec = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, yaw, 0));
                return { sx: Math.round(dirVec.x), sz: Math.round(dirVec.z) };
            }
            
            function isPath(x, z) {
                return z >= 0 && z < level.grid.length && x >= 0 && x < level.grid[0].length && level.grid[z][x] === 1;
            }
            
            const dirs = [
                {name:'forward', yaw: baseYaw,             pos: new THREE.Vector3( 0.0, 0.0, -4.0), rotZ:  0.0},
                {name:'left',    yaw: baseYaw + Math.PI/2, pos: new THREE.Vector3(-1.6, 0.0, -4.0), rotZ:  Math.PI/2},
                {name:'right',   yaw: baseYaw - Math.PI/2, pos: new THREE.Vector3( 1.6, 0.0, -4.0), rotZ: -Math.PI/2}
            ];
            
            for (const d of dirs) {
                const { sx, sz } = stepFromYaw(d.yaw);
                const nx = gridPos.x + sx;
                const nz = gridPos.z + sz;
                if (isPath(nx, nz)) {
                    available[d.name] = true;
                    const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                    arrow.position.copy(d.pos);
                    arrow.rotation.z = d.rotZ;
                    landmarksGroup.add(arrow);
                    
                    {
                        const scaleOuter = 1.12;
                        const scaleInner = 1.00;

                        const outer = new THREE.Shape();
                        outer.moveTo(0,  (h/2)*scaleOuter);
                        outer.lineTo((w/2)*scaleOuter, 0);
                        outer.lineTo((w/4)*scaleOuter, 0);
                        outer.lineTo((w/4)*scaleOuter, (-h/2)*scaleOuter);
                        outer.lineTo((-w/4)*scaleOuter, (-h/2)*scaleOuter);
                        outer.lineTo((-w/4)*scaleOuter, 0);
                        outer.lineTo((-w/2)*scaleOuter, 0);
                        outer.closePath();

                        const inner = new THREE.Shape();
                        inner.moveTo(0,  (h/2)*scaleInner);
                        inner.lineTo((w/2)*scaleInner, 0);
                        inner.lineTo((w/4)*scaleInner, 0);
                        inner.lineTo((w/4)*scaleInner, (-h/2)*scaleInner);
                        inner.lineTo((-w/4)*scaleInner, (-h/2)*scaleInner);
                        inner.lineTo((-w/4)*scaleInner, 0);
                        inner.lineTo((-w/2)*scaleInner, 0);
                        inner.closePath();

                        outer.holes.push(inner);

                        const haloGeo = new THREE.ShapeGeometry(outer);
                        const glow = new THREE.Mesh(
                            haloGeo,
                            new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                transparent: true,
                                opacity: 0.5,
                                side: THREE.DoubleSide,
                                blending: THREE.AdditiveBlending,
                                fog: false,
                                depthWrite: false,
                                depthTest: false
                            })
                        );
                        glow.position.set(0, 0, -0.003);
                        glow.name = 'arrowGlow';
                        glow.userData.phase = Math.random() * Math.PI * 2;
                        arrow.add(glow);
                    }
                }
            }
            return available;
        }
        
        function createSteeringWheel() {
            const wheelGroup = new THREE.Group();
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7, metalness: 0.1 });
            const gloveMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
            const cuffMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.6 });
            const wheel = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.08, 16, 60), wheelMat);
            wheelGroup.add(wheel);
            const createGlove = (hand = 'left') => {
                const gloveGroup = new THREE.Group();
                const palm = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 12), gloveMat);
                palm.scale.set(1, 1.2, 1);
                gloveGroup.add(palm);
                const thumb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 12, 8), gloveMat);
                const thumbX = (hand === 'left') ? +0.15 : -0.15;
                thumb.position.set(thumbX, 0.1, 0);
                gloveGroup.add(thumb);
                const cuff = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 0.2, 16), cuffMat);
                cuff.position.y = -0.15;
                gloveGroup.add(cuff);
                return gloveGroup;
            };
            const leftHand = createGlove('left');
            leftHand.position.set(-0.45, 0.1, 0);
            leftHand.rotation.z = 0.5;
            wheelGroup.add(leftHand);
            const rightHand = createGlove('right');
            rightHand.position.set(0.45, 0.1, 0);
            rightHand.rotation.z = -0.5;
            wheelGroup.add(rightHand);
            wheelGroup.position.set(0, -1.2, -2);
            wheelGroup.rotation.x = -0.5;
            return wheelGroup;
        }
        
        function createStarField(){
    const starCount = 4500;
    const radius = 500;
    const positions = new Float32Array(starCount * 3);
    let i = 0;
    while (i < starCount) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const y = Math.cos(phi);
        if (y < 0.02) continue;
        const r = radius;
        const x = r * Math.sin(phi) * Math.cos(theta);
        const yy = r * y;
        const z = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 0] = x;
        positions[i * 3 + 1] = yy;
        positions[i * 3 + 2] = z;
        i++;
    }
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.PointsMaterial({
        size: 2.0,
        sizeAttenuation: true,
        color: 0xffffff,
        transparent: true,
        opacity: 0.0,
        depthWrite: false,
        depthTest: true,
        blending: THREE.AdditiveBlending,
        fog: false
    });
    starField = new THREE.Points(geo, mat);
    starField.frustumCulled = false;
    starField.renderOrder = 0;
    scene.add(starField);
}
            function createClassicalLamp() {
            const group = new THREE.Group();
            const postMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.6, metalness: 0.4 });
            const baseGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.2, 8);
            const base = new THREE.Mesh(baseGeo, postMat);
            base.position.y = 0.1;
            group.add(base);
            const postGeo = new THREE.CylinderGeometry(0.15, 0.1, 3.5, 8);
            const post = new THREE.Mesh(postGeo, postMat);
            post.position.y = 1.85;
            group.add(post);
            const holderGeo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const holder = new THREE.Mesh(holderGeo, postMat);
            holder.position.set(0, 3.6, 0.3);
            group.add(holder);
            const lanternGeo = new THREE.SphereGeometry(0.4, 8, 6);
            const lightColors = [0xfffee0, 0xffffff, 0xe0e0ff, 0xffe0e0, 0xffd54f];
            const randomColor = lightColors[Math.floor(Math.random() * lightColors.length)];
            const bulbMat = new THREE.MeshBasicMaterial({ color: randomColor });
            const bulb = new THREE.Mesh(lanternGeo, bulbMat);
            bulb.position.set(0, 3.6, 0.3);
            group.add(bulb);
            const light = new THREE.PointLight(randomColor, 0, TILE_SIZE * 2, 1.5);
            light.name = 'lampLight';
            light.position.copy(bulb.position);
            group.add(light);
            return group;
        }

        function placeRoadsideObjects(grid) {
            const gridHeight = grid.length;
            const gridWidth = grid[0].length;
            for (let z = 0; z < gridHeight; z++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[z][x] === 0) continue;
                    const worldPos = gridToWorld(x, z, grid);
                    if (z > 0 && grid[z - 1][x] === 0) {
                        if (x % 3 === 0) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x, 0, worldPos.z - TILE_SIZE * 0.45);
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (z < gridHeight - 1 && grid[z + 1][x] === 0) {
                       if (x % 3 === 1) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x, 0, worldPos.z + TILE_SIZE * 0.45);
                            lamp.rotation.y = Math.PI;
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (x > 0 && grid[z][x - 1] === 0) {
                        if (z % 3 === 0) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x - TILE_SIZE * 0.45, 0, worldPos.z);
                            lamp.rotation.y = Math.PI / 2;
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (x < gridWidth - 1 && grid[z][x + 1] === 0) {
                        if (z % 3 === 1) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x + TILE_SIZE * 0.45, 0, worldPos.z);
                            lamp.rotation.y = -Math.PI / 2;
                            sceneryGroup.add(lamp);
                        }
                    }
                }
            }
        }

        
function __makeTileTextures(size = 512, innerColor = '#7a2b24', outerColor = '#5a1e1a') {
    const cvs = document.createElement('canvas');
    cvs.width = cvs.height = size;
    const ctx = cvs.getContext('2d');

    const grad = ctx.createRadialGradient(size*0.5, size*0.5, size*0.15, size*0.5, size*0.5, size*0.7);
    grad.addColorStop(0, innerColor);
    grad.addColorStop(1, outerColor);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);

    ctx.globalAlpha = 0.08;
    for (let y = 0; y < size; y += 4) {
        ctx.fillStyle = (y % 8 === 0) ? '#ffffff' : '#000000';
        ctx.fillRect(0, y, size, 1);
    }
    ctx.globalAlpha = 1;

    const baseTex = new THREE.CanvasTexture(cvs);
    baseTex.wrapS = baseTex.wrapT = THREE.RepeatWrapping;
    baseTex.magFilter = THREE.LinearFilter;
    baseTex.minFilter = THREE.LinearMipMapLinearFilter;
    return { baseTex };
}

function createMaterials() {
            const textureLoader = new THREE.TextureLoader();
            wallMaterialNS = new THREE.MeshStandardMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--wall-color-ns').trim()),
                roughness: 0.8,
                metalness: 0.2
            });
            wallMaterialEW = new THREE.MeshStandardMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--wall-color-ew').trim()),
                roughness: 0.8,
                metalness: 0.2
            });
            const floorTexture = textureLoader.load('https://threejs.org/examples/textures/checker.png');
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.magFilter = THREE.NearestFilter;
            floorTexture.minFilter = THREE.NearestFilter;
            const repeatsPerMazeTile = 2;
            const largestMazeDim = 25;
            floorTexture.repeat.set(largestMazeDim * repeatsPerMazeTile, largestMazeDim * repeatsPerMazeTile);
            floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture, metalness: 0.6, roughness: 0.35 });
            landmarkMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--landmark-color').trim()),
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            goalWallMaterial = new THREE.MeshStandardMaterial({ color: 0xff6666, roughness: 0.6, metalness: 0.2, emissive: 0x330000, emissiveIntensity: 0.25 });
        }

        // ====================================================================
        // 小地图 (Minimap)
        // ====================================================================

        let lastPlayerGridPos = { x: -1, z: -1 };

        function drawMinimapBackground(level) {
            if (!level) return;
            const { grid, start, goal } = level;
            const canvas = minimap;
            canvas.width = 500;
            canvas.height = 500;
            const ctx = minimapCtx;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cellWidth = canvas.width / grid[0].length;
            const cellHeight = canvas.height / grid.length;
            for (let z = 0; z < grid.length; z++) {
                for (let x = 0; x < grid[0].length; x++) {
                    const xPos = x * cellWidth;
                    const yPos = z * cellHeight;
                    if (grid[z][x] === 0) {
                        const wallGradient = ctx.createLinearGradient(xPos, yPos, xPos + cellWidth, yPos + cellHeight);
                        wallGradient.addColorStop(0, "#555");
                        wallGradient.addColorStop(0.5, "#222");
                        wallGradient.addColorStop(1, "#555");
                        ctx.fillStyle = wallGradient;
                    } else {
                        const pathGradient = ctx.createLinearGradient(xPos, yPos, xPos + cellWidth, yPos + cellHeight);
                        pathGradient.addColorStop(0, "#eee");
                        pathGradient.addColorStop(0.5, "#fff");
                        pathGradient.addColorStop(1, "#eee");
                        ctx.fillStyle = pathGradient;
                    }
                    ctx.fillRect(xPos, yPos, cellWidth, cellHeight);
                }
            }
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--start-color');
            ctx.fillRect(start.x * cellWidth, start.z * cellHeight, cellWidth, cellHeight);
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--goal-color');
            ctx.fillRect(goal.x * cellWidth, goal.z * cellHeight, cellWidth, cellHeight);
            // Draw landmarks (numbers / collected as stars)
            if (level.landmarks && level.landmarks.length) {
                for (const lm of level.landmarks) {
                    const xPos = lm.x * cellWidth + cellWidth*0.5;
                    const yPos = lm.z * cellHeight + cellHeight*0.5;
                    ctx.save();
                    ctx.translate(xPos, yPos);
                    const r = Math.min(cellWidth, cellHeight) * 0.35;
                    const id = lm.id;
                    const collected = currentHunt && currentHunt.nextId && (id < currentHunt.nextId);
                    if (collected) {
                        // draw star
                        ctx.beginPath();
                        const spikes = 5, outerR = r, innerR = r*0.45;
                        let rot = Math.PI/2 * 3;
                        ctx.moveTo(0, -outerR);
                        for (let i=0;i<spikes;i++){ ctx.lineTo(Math.cos(rot)*outerR, Math.sin(rot)*outerR); rot+=Math.PI/spikes; ctx.lineTo(Math.cos(rot)*innerR, Math.sin(rot)*innerR); rot+=Math.PI/spikes; }
                        ctx.lineTo(0, -outerR);
                        ctx.closePath();
                        ctx.fillStyle = '#ffd700';
                        ctx.fill();
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = '#b8860b';
                        ctx.stroke();
                    } else {
                        ctx.beginPath();
                        ctx.arc(0,0,r,0,Math.PI*2);
                        ctx.fillStyle = '#ffc107';
                        ctx.fill();
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = '#8a6d3b';
                        ctx.stroke();
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 18px sans-serif';
                        ctx.font = 'bold 18px sans-serif';
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(String(id), 0, 1);
                    }
                    ctx.restore();
                }
            }

        }

        function updateMinimapPlayer() {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            if (!level) return;
            const { grid, start, goal } = level;
            const gridPos = worldToGrid(player.position);
            lastPlayerGridPos = { ...gridPos };
            // Hunt: trigger collection when player enters a landmark cell
            if (level.landmarks && level.landmarks.length) {
                handleHuntCollect(gridPos);
            }
            drawMinimapBackground(level);
            const ctx = minimapCtx;
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;
            const cellWidth = ctx.canvas.width / gridWidth;
            const cellHeight = ctx.canvas.height / gridHeight;
            const playerX = (gridPos.x + 0.5) * cellWidth;
            const playerZ = (gridPos.z + 0.5) * cellHeight;
            ctx.save();
            const dirVec = new THREE.Vector3(0, 0, -1).applyEuler(player.rotation);
            const angle = Math.atan2(dirVec.z, dirVec.x);
            ctx.translate(playerX, playerZ);
            ctx.rotate(angle);
            const size = Math.min(cellWidth, cellHeight) * 1.2; 
            const half = size * 0.5;
            const tail = -half * 0.8; 
            ctx.beginPath();
            ctx.moveTo(half, 0);
            ctx.lineTo(tail, -half * 0.6); 
            ctx.lineTo(tail,  half * 0.6); 
            ctx.closePath();
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, half);
            gradient.addColorStop(0, '#ff8080');
            gradient.addColorStop(1, '#c00000');
            ctx.fillStyle = gradient;
            ctx.shadowColor = 'rgba(255, 0, 0, 0.9)';
            ctx.shadowBlur = size * 0.7;
            ctx.fill();
            ctx.lineWidth = Math.max(2, size * 0.1); 
            ctx.strokeStyle = '#006400';
            ctx.stroke();
            ctx.restore();
        }

        // ====================================================================
        // 寻路算法 (Pathfinding - BFS)
        // ====================================================================

        function getNeighbors(x, z, grid) {
            const neighbors = [];
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dx, dz] of dirs) {
                const newX = x + dx;
                const newZ = z + dz;
                if (newZ >= 0 && newZ < grid.length && newX >= 0 && newX < grid[0].length && grid[newZ][newX] === 1) {
                    neighbors.push({ x: newX, z: newZ });
                }
            }
            return neighbors;
        }

        function findShortestPath(level) {
            const { grid, start, goal } = level;
            if (!start.hasOwnProperty('x') || !goal.hasOwnProperty('x')) return null;
            const queue = [{ x: start.x, z: start.z, path: [] }];
            const visited = new Set([`${start.x},${start.z}`]);
            while (queue.length > 0) {
                const { x, z, path } = queue.shift();
                if (x === goal.x && z === goal.z) {
                    return { path, choices: path.length };
                }
                const neighbors = getNeighbors(x, z, grid);
                for (const neighbor of neighbors) {
                    const key = `${neighbor.x},${neighbor.z}`;
                    if (!visited.has(key)) {
                        visited.add(key);
                        const newPath = path.concat([{x, z}]);
                        queue.push({ ...neighbor, path: newPath });
                    }
                }
            }
            return null;
        }
        
        // ====================================================================
        // 菜单与UI逻辑 (Menu & UI Logic)
        // ====================================================================
        
        function showIngameHint(messageKey = 'hint_ingame_controls') {
            const hintEl = document.getElementById('ingame-hint');
            hintEl.textContent = translations[currentLanguage][messageKey];
            hintEl.style.display = 'block';
            hintEl.style.opacity = 1;

            clearTimeout(hintTimeout);
            hintTimeout = setTimeout(() => {
                hintEl.style.opacity = 0;
                setTimeout(() => {
                    hintEl.style.display = 'none';
                }, 500);
            }, 8000);
        }

        function updateHUD() {
            const mapViewCountEl = document.getElementById('map-view-count');
            if (navigationMode === 'limited') {
                mapViewCountEl.style.display = 'block';
                mapViewCountEl.textContent = `${translations[currentLanguage].mapChances}: ${mapViewChances}`;
            } else {
                mapViewCountEl.style.display = 'none';
            }
        }
        
        function updateUIText() {
            document.querySelectorAll('[data-lang-zh]').forEach(el => {
                const key = currentLanguage === 'zh' ? 'langZh' : 'langEn';
                if (el.dataset[key]) {
                    el.textContent = el.dataset[key];
                }
            });
             document.querySelectorAll('select').forEach(select => {
                select.querySelectorAll('option').forEach(option => {
                    const key = currentLanguage === 'zh' ? 'langZh' : 'langEn';
                    if (option.dataset[key]) {
                        option.textContent = option.dataset[key];
                    }
                });
            });
            document.querySelectorAll('[data-lang-placeholder-zh]').forEach(el => {
                const key = currentLanguage === 'zh' ? 'langPlaceholderZh' : 'langPlaceholderEn';
                 if (el.dataset[key]) {
                    el.placeholder = el.dataset[key];
                }
            });
            
            const welcomeMsg = document.getElementById('welcome-message');
            if (welcomeMsg) {
                welcomeMsg.textContent = translations[currentLanguage].welcome(playerInfo.nickname);
            }
            if (gameState === 'AT_INTERSECTION') {
                checkForTurns();
            }

            const ingameHint = document.getElementById('ingame-hint');
            if (ingameHint.style.display !== 'none') {
                showIngameHint();
            }
            updateHUD();
        }

        function togglePauseMenu() {
            const menu = document.getElementById('pause-menu-modal');
            const isPaused = menu.style.display === 'flex';

            if (isPaused) {
                menu.style.display = 'none';
                gameState = previousGameState;
            } else {
                if(!['AT_INTERSECTION', 'DRIVING', 'TURNING', 'BIG_MAP'].includes(gameState)) return;
                previousGameState = gameState;
                gameState = 'PAUSED';
                menu.style.display = 'flex';
            }
        }
        
        function toggleChallengeMap() {
            const container = document.getElementById('minimap-container');
            const isMapViewVisible = container.style.display === 'block' && gameState === 'CHALLENGE_MAP_VIEW';

            if (isMapViewVisible) {
                container.style.display = 'none';
                gameState = previousGameState;
            } else if (['AT_INTERSECTION', 'DRIVING', 'TURNING'].includes(gameState) && mapViewChances > 0) {
                mapViewChances--;
                updateHUD();
                previousGameState = gameState;
                gameState = 'CHALLENGE_MAP_VIEW';
                container.classList.remove('small-map');
                container.classList.add('big-map');
                container.style.display = 'block';
}
        }

        function showLevelSelectModal() {
            const grid = document.getElementById('level-select-grid');
            grid.innerHTML = '';
            const levelCount = (gameMode === 'custom') ? customLevels.filter(l=>l).length : levels.length;
            for (let i = 0; i < levelCount; i++) {
                const button = document.createElement('button');
                button.textContent = i + 1;
                const isUnlocked = gameMode !== 'campaign' || i <= unlockedLevel;
                button.disabled = !isUnlocked;
                if (isUnlocked) {
                    button.onclick = () => {
                        document.getElementById('level-select-modal').style.display = 'none';
                        togglePauseMenu();
                        loadLevel(gameMode === 'custom' ? customLevels[i] : i);
                    };
                }
                grid.appendChild(button);
            }
            document.getElementById('pause-menu-modal').style.display = 'none';
            document.getElementById('level-select-modal').style.display = 'flex';
        }

        function resetGame() {
            unlockedLevel = 0;
            playerInfo = { nickname: 'Driver', gender: 'other' };
            document.getElementById('nickname-input').value = '';
            const modals = document.querySelectorAll('.modal-overlay');
            modals.forEach(modal => {
                if (modal.id !== 'startup-modal') {
                    modal.style.display = 'none';
                }
            });
            document.getElementById('startup-modal').style.display = 'flex';
            gameState = 'STARTUP_MODAL';
            updateUIText();
        }
        
        // ====================================================================
        // 地图编辑器 (Map Editor) & Custom Maps
        // ====================================================================
        
        let editorGridData = [];
        let editorLandmarks = {}; // {1:{x,z}, 2:{x,z}, ...}

        let editorStart = {};
        let userResizing = false;
        let editorGoal = {};
        let currentTool = 'wall';
        let isDrawing = false;
        let selectedCustomMapIndex = 0;
        const DEFAULT_editorSize = 17;
        const MAX_CUSTOM_LEVELS = 15;

        function loadCustomLevels() {
            const savedLevels = localStorage.getItem('customMazeLevels');
            if (savedLevels) {
                customLevels = JSON.parse(savedLevels);
            } else {
                customLevels = new Array(MAX_CUSTOM_LEVELS).fill(null);
            }
        }

        function saveCustomLevels() {
            localStorage.setItem('customMazeLevels', JSON.stringify(customLevels));
        }

        function showEditor(slotIndex = 0) {
            document.getElementById('main-menu-modal').style.display = 'none';
            document.getElementById('custom-maps-modal').style.display = 'none';
            document.getElementById('editor-modal').style.display = 'flex';
            initEditor(slotIndex);
        }

        let editorSize = typeof DEFAULT_editorSize !== 'undefined' ? DEFAULT_editorSize : 15;
        function initEditor(slotIndex) {
            const grid = document.getElementById('editor-grid');
            const slotSelect = document.getElementById('editor-slot-select');
            grid.innerHTML = '';
            slotSelect.innerHTML = '';
            for (let i = 0; i < MAX_CUSTOM_LEVELS; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${translations[currentLanguage].map_slot} ${i + 1}` + (customLevels[i] ? '' : ` (${translations[currentLanguage].empty_slot})`);
                slotSelect.appendChild(option);
            }
            slotSelect.value = slotIndex;
            slotSelect.onchange = () => { initEditor(parseInt(slotSelect.value)); };
            const sizeInput = document.getElementById('editor-size-input');
            if (sizeInput) {
                sizeInput.addEventListener('wheel', (e)=>{ e.preventDefault(); }, {passive:false});
                const applySize = () => {
                    userResizing = true;
                    const v = Math.max(5, Math.min(30, parseInt(sizeInput.value)||15));
                    if (v !== editorSize) { editorSize = v; }
                    loadEditorGrid(parseInt(slotSelect.value));
                    userResizing = false;
                };
                sizeInput.oninput = applySize;
                sizeInput.onchange = applySize;
            }
            loadEditorGrid(slotIndex);
            grid.onmousedown = (e) => {
                isDrawing = true;
                handleGridInteraction(e);
            };
            grid.onmouseover = handleGridInteraction;
            document.onmouseup = () => isDrawing = false;
            grid.onmouseleave = () => isDrawing = false;
            document.getElementById('editor-toolbar').onclick = (e) => {
                if (e.target.tagName === 'BUTTON') {
                    currentTool = e.target.dataset.tool;
                    document.querySelectorAll('#editor-toolbar button').forEach(b => b.classList.remove('selected'));
                    e.target.classList.add('selected');
                }
            };
            document.getElementById('tool-wall').classList.add('selected');


            document.getElementById('editor-save-btn').onclick = saveCustomMap;
            document.getElementById('editor-delete-btn').onclick = deleteCustomMap;
            document.getElementById('editor-back-btn').onclick = () => {
                 document.getElementById('editor-modal').style.display = 'none';
                 showMainMenu();
            };
        }
        
        function loadEditorGrid(slotIndex) {
            const grid = document.getElementById('editor-grid');
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${editorSize}, 1fr)`;
            grid.style.gridTemplateRows = `repeat(${editorSize}, 1fr)`;
            editorGridData = [];
            editorStart = {};
            editorLandmarks = {};
            editorGoal = {};
            const levelToLoad = customLevels[slotIndex];
            const sizeInput = document.getElementById('editor-size-input');
            if (levelToLoad && levelToLoad.grid && !userResizing) {
                editorSize = levelToLoad.grid.length;
                if (sizeInput) sizeInput.value = editorSize;
            }
            for (let z = 0; z < editorSize; z++) {
                const row = [];
                for (let x = 0; x < editorSize; x++) {
                    let cellType = 0;
                    if (levelToLoad) {
                        cellType = levelToLoad.grid[z][x] === 0 ? 1 : 0;
                        if (levelToLoad.start.x === x && levelToLoad.start.z === z) editorStart = {x, z};
                        if (levelToLoad.goal.x === x && levelToLoad.goal.z === z) editorGoal = {x, z};
                    } else {
                        const isBorder = x === 0 || x === editorSize - 1 || z === 0 || z === editorSize - 1;
                        if (isBorder) cellType = 1;
                    }
                    row.push(cellType);
                    const cell = document.createElement('div');
                    cell.classList.add('editor-cell');
                    cell.dataset.x = x;
                    cell.dataset.z = z;
                    if(editorStart.x === x && editorStart.z === z) cell.classList.add('start');
                    else if(editorGoal.x === x && editorGoal.z === z) cell.classList.add('goal');
                    else cell.classList.toggle('wall', cellType === 1);
                    grid.appendChild(cell);
                }
                editorGridData.push(row);
            }
        
            // Paint landmarks if any (after grid built)
            if (levelToLoad && levelToLoad.landmarks && levelToLoad.landmarks.length) {
                levelToLoad.landmarks.forEach(lm => {
                    editorLandmarks[lm.id] = {x: lm.x, z: lm.z};
                    const idx = lm.z * editorSize + lm.x;
                    const cellEl = document.getElementById('editor-grid').children[idx];
                    if (cellEl) {
                        cellEl.className = 'editor-cell lm' + lm.id;
                    }
                });
            }
}
        
        function handleGridInteraction(e) {
            if (!isDrawing || e.buttons !== 1) return;
            const cell = e.target;
            if (!cell.classList.contains('editor-cell')) return;
            const x = parseInt(cell.dataset.x);
            const z = parseInt(cell.dataset.z);
            const grid = document.getElementById('editor-grid');
            if (editorStart.x === x && editorStart.z === z) editorStart = {};
            if (editorGoal.x === x && editorGoal.z === z) editorGoal = {};
            if (currentTool === 'start' && editorStart.x !== undefined) {
                 grid.children[editorStart.z * editorSize + editorStart.x].className = 'editor-cell path';
                 editorGridData[editorStart.z][editorStart.x] = 0;
            }
            if (currentTool === 'goal' && editorGoal.x !== undefined) {
                 grid.children[editorGoal.z * editorSize + editorGoal.x].className = 'editor-cell path';
                 editorGridData[editorGoal.z][editorGoal.x] = 0;
            }
            switch (currentTool) {
                case 'wall':
                    editorGridData[z][x] = 1;
                    cell.className = 'editor-cell wall';
                    break;
                case 'path':
                    editorGridData[z][x] = 0;
                    cell.className = 'editor-cell path';
                    break;
                case 'start':
                    editorGridData[z][x] = 0;
                    editorStart = { x, z };
                    cell.className = 'editor-cell start';
                    isDrawing = false;
                    break;
                case 'goal':
                    editorGridData[z][x] = 0;
                    editorGoal = { x, z };
                    cell.className = 'editor-cell goal';
                    isDrawing = false;
                    break;
                case 'lm1':
                case 'lm2':
                case 'lm3':
                case 'lm4':
                case 'lm5':
                    editorGridData[z][x] = 1; // ensure walkable
                    const lmId = parseInt(currentTool.replace('lm',''));
                    // clear previous of this id
                    if (editorLandmarks[lmId]) {
                        const prev = editorLandmarks[lmId];
                        const prevEl = document.getElementById('editor-grid').children[prev.z * editorSize + prev.x];
                        if (prevEl) prevEl.className = 'editor-cell path';
                    }
                    editorLandmarks[lmId] = {x, z};
                    cell.className = 'editor-cell lm' + lmId;
                    isDrawing = false;
                    break;
            }
        }
        
        function saveCustomMap() {
            const messageEl = document.getElementById('editor-message');
            messageEl.textContent = '';
            const slotIndex = parseInt(document.getElementById('editor-slot-select').value);
            if (!editorStart.hasOwnProperty('x')) {
                messageEl.textContent = translations[currentLanguage].editor_need_start;
                return;
            }
            if (!editorGoal.hasOwnProperty('x')) {
                messageEl.textContent = translations[currentLanguage].editor_need_goal;
                return;
            }
            const mazeDataForSolver = editorGridData.map(row => row.map(cell => cell === 1 ? 0 : 1));
            const tempLevel = { grid: mazeDataForSolver, start: editorStart, goal: editorGoal };
            if (!findShortestPath(tempLevel)) {
                messageEl.textContent = translations[currentLanguage].editor_unsolvable;
                return;
            }
            
            // Landmarks collection (if 2..5 present consecutively -> treat as hunt)
            const lmKeys = Object.keys(editorLandmarks).map(k => parseInt(k,10)).sort((a,b)=>a-b);
            let lmArr = [];
            if (lmKeys.length >= 2) {
                // ensure consecutive from 1..N with no gaps
                let ok = true;
                for (let i=0;i<lmKeys.length;i++){
                    if (lmKeys[i] !== i+1) { ok = false; break; }
                }
                if (ok) {
                    lmArr = lmKeys.map(id => ({x: editorLandmarks[id].x, z: editorLandmarks[id].z, id}));
                }
            }

            const newLevel = {
                grid: mazeDataForSolver,
                start: { ...editorStart, dir: 'S' },
                goal: { ...editorGoal },
                landmarks: lmArr,
                hunt: lmArr.length >= 2
            };
            if (newLevel.start.x === 0) newLevel.start.dir = 'E';
            else if (newLevel.start.x === editorSize - 1) newLevel.start.dir = 'W';
            else if (newLevel.start.z === 0) newLevel.start.dir = 'S';
            else if (newLevel.start.z === editorSize - 1) newLevel.start.dir = 'N';
            customLevels[slotIndex] = newLevel;
            saveCustomLevels();
            const option = document.getElementById('editor-slot-select').options[slotIndex];
            option.textContent = `${translations[currentLanguage].map_slot} ${slotIndex + 1}`;
            messageEl.textContent = `${translations[currentLanguage].map_slot} ${slotIndex + 1} 已保存!`;
            messageEl.style.color = 'green';
            setTimeout(() => {
                messageEl.textContent = '';
                messageEl.style.color = 'red';
            }, 2000);
        }
        
        function deleteCustomMap() {
            const slotIndex = parseInt(document.getElementById('editor-slot-select').value);
            if (customLevels[slotIndex] && confirm(translations[currentLanguage].confirm_delete)) {
                customLevels[slotIndex] = null;
                saveCustomLevels();
                initEditor(slotIndex);
            }
        }
        
        function showCustomMapsModal() {
            document.getElementById('main-menu-modal').style.display = 'none';
            document.getElementById('custom-maps-modal').style.display = 'flex';
            const grid = document.getElementById('custom-maps-grid');
            grid.innerHTML = '';
            selectedCustomMapIndex = -1;
            document.getElementById('custom-play-btn').disabled = true;
            document.getElementById('custom-edit-btn').disabled = true;
            document.getElementById('custom-delete-btn').disabled = true;
            for (let i = 0; i < MAX_CUSTOM_LEVELS; i++) {
                const button = document.createElement('button');
                button.dataset.index = i;
                if (customLevels[i]) {
                    button.textContent = `${translations[currentLanguage].map_slot} ${i + 1}`;
                } else {
                    button.textContent = `${i + 1} (${translations[currentLanguage].empty_slot})`;
                    button.disabled = true;
                }
                grid.appendChild(button);
            }
            grid.onclick = (e) => {
                if (e.target.tagName === 'BUTTON' && !e.target.disabled) {
                    document.querySelectorAll('#custom-maps-grid button').forEach(b => b.classList.remove('selected'));
                    e.target.classList.add('selected');
                    selectedCustomMapIndex = parseInt(e.target.dataset.index);
                    document.getElementById('custom-play-btn').disabled = false;
                    document.getElementById('custom-edit-btn').disabled = false;
                    document.getElementById('custom-delete-btn').disabled = false;
                }
            };
            document.getElementById('custom-play-btn').onclick = () => {
                if(selectedCustomMapIndex !== -1) {
                    document.getElementById('custom-maps-modal').style.display = 'none';
                    document.getElementById('mode-select-modal').style.display = 'flex';
                }
            };
            document.getElementById('custom-edit-btn').onclick = () => {
                if(selectedCustomMapIndex !== -1) showEditor(selectedCustomMapIndex);
            };
            document.getElementById('custom-delete-btn').onclick = () => {
                if(selectedCustomMapIndex !== -1 && confirm(translations[currentLanguage].confirm_delete)) {
                    customLevels[selectedCustomMapIndex] = null;
                    saveCustomLevels();
                    showCustomMapsModal();
                }
            };
            document.getElementById('custom-back-btn').onclick = () => {
                document.getElementById('custom-maps-modal').style.display = 'none';
                showMainMenu();
            };
        }
        
        // ====================================================================
        // 启动 (Boot)
        // ====================================================================
        init();

    </script>
    <script>
    (function(){
      var overlay = document.getElementById('intro-overlay');
      var video   = document.getElementById('intro-video');
      var skip    = document.getElementById('skip-intro-btn');
      var startup = document.getElementById('startup-modal');
      function ensureStartVisible() {
        if (startup && startup.style.display === 'none') {
          startup.style.display = 'flex';
        }
      }
      function endIntro(){
        if (!overlay) return;
        overlay.classList.add('hidden');
        setTimeout(function(){ overlay.remove(); ensureStartVisible(); }, 520);
      }
      if (skip) skip.addEventListener('click', endIntro);
      if (video){
        video.addEventListener('ended', endIntro);
        video.addEventListener('error', endIntro);
        var p = video.play && video.play();
        if (p && typeof p.then === 'function'){
          p.catch(function(){ video.controls = true; });
        }
      }
      if (overlay){
        overlay.addEventListener('click', function once(){
          if (video){
            try{ video.muted = false; video.volume = 0.6; } catch(e){}
          }
          overlay.removeEventListener('click', once);
        });
      }
    })();
    </script>
</body>
</html>
