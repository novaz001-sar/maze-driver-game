<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第一人称迷宫驾驶 First-Person Maze Driver</title>
    <!--
    ============================================================================
    ## README：第一人称迷宫驾驶 (First-Person Maze Driver) - v7.8h 用户修改版 ##
    ============================================================================

    这是根据用户请求修改的版本。

    ### v7.8h 更新内容 (What's New in v7.8h)
    1.  **调整夜空颜色 (Adjusted Night Sky Color)**:
        * 将夜晚的天空背景色修改为深紫色(0x210033)，使星空效果更加突出。
    2.  **优化游戏提示 (Optimized In-Game Hints)**:
        * **箭头说明**: 游戏开始时，提示信息会明确说明黄色箭头仅代表“可选方向”，而非“导航路径”。
        * **死胡同提示**: 当车辆驶入前方和左右都无路可走的死胡同时，会显示专门的提示，并告知玩家可以通过连续按两次转向键来掉头。
        * **终点前提示**: 当车辆距离终点仅剩一格时，会弹出提示“再往前一步就到达目的地了！”。

    ### 玩法说明 (How to Play)
    1.  **路口决策 (Intersection)**:
        * 在迷宫的任何一格，车辆都会停下。此时可以观察前方浮动的黄色箭头来决定方向。
    2.  **选择方向或前进**:
        * 按下 `D` 键，车辆会**平滑地向右转90度**。
        * 按下 `A` 键，车辆会**平滑地向左转90度**。
        * 按下 `空格 (Space)` 键，车辆会沿当前方向**前进一格**。
    
    ### 键位 (Controls)
    * `A`: 向左转90度 (Turn Left)。
    * `D`: 向右转90度 (Turn Right)。
    * `空格 (Space)`: 前进一格 (Move Forward)。
    * `E`: (仅自主导航模式) 打开/关闭大地图 (Toggle Full Map in Autonomous Navigation Mode)。
    * `ESC`: 呼出/关闭菜单 (Toggle Menu)。
    * `鼠标左键`: 点击UI元素 (Click UI Elements)。

    ============================================================================
    -->
    <style>
        :root {
            --bg-color: #f0f8ff; /* AliceBlue - a very light blue sky */
            --text-color: #333333; /* Dark Grey for text */
            --primary-color: #007bff; /* Bright Blue */
            --highlight-color: #28a745; /* Green */
            --danger-color: #dc3545; /* Red */
            --wall-color-ns: #f5deb3; /* Wheat - for North-South walls */
            --wall-color-ew: #faf0e6; /* Linen - slightly lighter for East-West walls */
            --floor-color: #E0E0E0; /* Fallback color, not really used with texture */
            --landmark-color: #ffc107; /* Amber */
            --start-color: #007bff;
            --goal-color: #dc3545; /* Red */
            --font-size-normal: 18px;
            --font-size-large: 22px;
            --font-size-xlarge: 28px;
            --minimap-scale: 1; /* 小地图缩放比例 */
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: var(--font-size-normal);
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        .hud {
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        #top-hud {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
            position: relative; /* For positioning hints */
        }

        #map-view-count {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: var(--font-size-normal);
            font-weight: bold;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: none; /* Hidden by default */
        }

        #bottom-hud {
           text-align: center;
            position: absolute; 
            bottom: 3vh;        
            left: 0;            
            right: 0;           
        }

        /* Shared style for prompts */
        .hud-prompt {
            background-color: rgba(255, 255, 255, 0.85);
            color: var(--text-color);
            padding: 15px 25px;
            border-radius: 15px;
            border: 2px solid var(--primary-color);
            font-size: var(--font-size-large);
            font-weight: bold;
            display: none; /* Initially hidden */
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 90%;
        }
        
        #big-map-prompt {
             border-color: var(--highlight-color);
        }

        #minimap-container {
            position: fixed;
            background-color: rgba(255, 255, 255, 0.8);
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            transition: all 0.5s ease-in-out;
            z-index: 10;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.5);
        }

        #minimap-container.big-map {
            /* MODIFIED: Centering is now handled by a flex container */
            position: relative;
            width: 60vmin;
            height: 60vmin;
            cursor: pointer;
        }

        #minimap-container.small-map {
            top: 20px;
            right: 20px;
            width: calc(25vmin * var(--minimap-scale));
            height: calc(25vmin * var(--minimap-scale));
            max-width: calc(250px * var(--minimap-scale));
            max-height: calc(250px * var(--minimap-scale));
            cursor: default;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        
        #ingame-hint {
            position: absolute;
            top: 80px; /* Positioned below the settings button */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: var(--font-size-normal);
            z-index: 5;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }

        /* Modals and Menus */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background-color: white;
            color: var(--text-color);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid var(--primary-color);
            text-align: center;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 0 25px rgba(0, 123, 255, 0.5);
        }
        
        #editor-modal .modal-content, #custom-maps-modal .modal-content {
            max-width: 95vmin;
        }

        .modal-content h2 {
            font-size: var(--font-size-xlarge);
            margin-top: 0;
            margin-bottom: 30px;
            color: var(--primary-color);
        }
        
        .modal-content p {
            font-size: var(--font-size-normal);
            margin-bottom: 20px;
        }

        .modal-content input, .modal-content select {
            width: 80%;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 10px;
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            color: var(--text-color);
            font-size: var(--font-size-normal);
            min-height: 44px;
        }

        .modal-content button {
            padding: 15px 0;
            border-radius: 10px;
            border: none;
            background-color: var(--primary-color);
            color: white;
            font-size: var(--font-size-large);
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 80%;
            max-width: 300px;
            min-height: 50px;
            margin: 10px auto;
            display: block;
        }
        
        .modal-content .button-row {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .modal-content .button-row button {
            width: 45%;
            max-width: 150px;
        }

        .modal-content button.danger {
            background-color: var(--danger-color);
        }
        .modal-content button.secondary {
            background-color: #6c757d;
        }

        .modal-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.4);
        }
        .modal-content button.danger:hover {
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
        }
        .modal-content button.secondary:hover {
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.4);
        }
        
        .modal-content button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        #results-medal {
            font-size: 80px;
            margin: 20px 0;
        }
        
        #results-title {
            color: var(--highlight-color);
        }

        #dev-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 20;
            pointer-events: auto;
            display: none;
        }
        #dev-panel h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        #dev-panel select {
            min-height: 44px;
        }

        #settings-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.1);
            border: none;
            color: var(--text-color);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #settings-panel {
            display: none;
        }

        .settings-group {
            text-align: left;
            margin-bottom: 20px;
        }
        .settings-group label {
            display: block;
            margin-bottom: 10px;
        }
        .settings-group select, .settings-group input[type="range"] {
            width: 100%;
        }

        #level-select-grid, #custom-maps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
            max-height: 50vh;
            overflow-y: auto;
        }

        #level-select-grid button, #custom-maps-grid button {
            min-width: 60px;
            width: 100%;
            padding: 10px;
        }

        #level-select-grid button:disabled, #custom-maps-grid button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        #custom-maps-grid button.selected {
            border: 3px solid var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }

        /* Editor Styles */
        #editor-toolbar {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        #editor-toolbar button, #editor-toolbar select {
            width: auto;
            min-width: 80px;
            padding: 10px 15px;
            font-size: var(--font-size-normal);
            min-height: 44px;
            margin: 5px;
        }
        #editor-toolbar button.selected {
            background-color: var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }
        #editor-grid {
            display: grid;
            grid-template-columns: repeat(17, 1fr);
            grid-template-rows: repeat(17, 1fr);
            width: 80vmin;
            height: 80vmin;
            max-width: 450px;
            max-height: 450px;
            margin: 0 auto 20px;
            border: 2px solid var(--primary-color);
            background-color: #e9ecef;
        }
        .editor-cell {
            border: 1px solid #dee2e6;
            transition: background-color: 0.1s;
        }
        .editor-cell:hover {
            background-color: #ced4da;
        }
        .editor-cell.wall { background-color: #343a40; }
        .editor-cell.path { background-color: #f8f9fa; }
        .editor-cell.start { background-color: var(--start-color); }
        .editor-cell.goal { background-color: var(--goal-color); }
        
        .lang-en { display: none; }

        /* Intro Video Overlay */
        .intro-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            opacity: 1;
            transition: opacity .5s ease;
        }
        .intro-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #intro-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #skip-intro-btn {
            position: absolute;
            right: 20px;
            bottom: 20px;
            padding: 12px 18px;
            border: 0;
            border-radius: 999px;
            font-size: 16px;
            font-weight: 700;
            background: rgba(255, 255, 255, .15);
            color: #fff;
            backdrop-filter: blur(6px);
            cursor: pointer;
        }
        #skip-intro-btn:hover {
            background: rgba(255, 255, 255, .3);
        }

        /* Animated Info Box for Menus */
        .menu-info-box {
            margin-top: 20px;
            padding: 15px;
            min-height: 80px;
            width: 85%;
            background-color: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #dee2e6;
            color: #495057;
            font-size: var(--font-size-normal);
            text-align: left;
            overflow: hidden;
            white-space: normal;
        }

        .menu-info-box p {
            margin: 0;
            opacity: 0;
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Big map layout styles */
        .big-map-flex-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            width: 95vw;
            height: 95vh;
        }

        #map-instructions-panel h3 {
            margin-top: 0;
            color: var(--primary-color);
        }
        
        /* NEW: Styles for the detailed map legend */
        #map-instructions-panel ul {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }

        #map-instructions-panel li {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            font-size: 17px;
        }

        .map-legend-swatch {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 5px;
            margin-right: 12px;
            border: 1px solid rgba(0,0,0,0.2);
        }

        .swatch-player {
            background: #c00000;
        }
        .swatch-start {
            background-color: var(--start-color);
        }
        .swatch-goal {
            background-color: var(--goal-color);
        }
        
        #map-instructions-panel .instruction-text {
            margin-top: 15px;
            font-weight: bold;
        }



        .legend-icon{width:24px;height:24px;margin-right:12px;display:inline-block;vertical-align:middle;}
        .legend-icon path{vector-effect:non-scaling-stroke;}

        @media (max-width: 800px) {
            .big-map-flex-container {
                flex-direction: column;
                gap: 15px;
                justify-content: center;
            }
            #map-instructions-panel {
                max-width: 90vw;
                order: 2; /* Instructions below map */
                padding: 20px;
                font-size: 16px;
            }
            #big-map-container-wrapper {
                order: 1; /* Map above instructions */
            }
            #minimap-container.big-map {
                width: 80vw;
                height: 80vw;
            }
        }
    </style>
</head>
<body>
    <!-- Intro video overlay -->
    <div id="intro-overlay" class="intro-overlay" aria-label="开场视频" role="dialog" aria-modal="true">
        <video id="intro-video" src="intro.mp4" autoplay muted playsinline webkit-playsinline preload="auto"></video>
        <button id="skip-intro-btn" aria-label="跳过视频">跳过</button>
    </div>

    <div id="game-container"></div>

    <div id="ui-container">
        <div id="top-hud" class="hud">
             <div id="map-view-count"></div>
             <div id="ingame-hint" style="display: none;"></div>
        </div>
        <div id="bottom-hud" class="hud">
            <div id="big-map-prompt" class="hud-prompt"></div>
            <div id="choice-prompt" class="hud-prompt"></div>
        </div>
    </div>

    <div id="minimap-container">
        <canvas id="minimap-canvas"></canvas>
    </div>
    
    <button id="settings-button">⚙️</button>

    <div id="startup-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 data-lang-zh="欢迎来到快乐驾驶" data-lang-en="Welcome to Happy Drive">欢迎来到快乐驾驶</h2>
            <div class="settings-group">
                <label for="initial-language-select" data-lang-zh="语言 / Language" data-lang-en="语言 / Language">语言 / Language</label>
                <select id="initial-language-select">
                    <option value="zh">中文</option>
                    <option value="en">English</option>
                </select>
            </div>
            <p data-lang-zh="为了更好地称呼您，请输入您的信息：" data-lang-en="To get started, please enter your info:">为了更好地称呼您，请输入您的信息：</p>
            <input type="text" id="nickname-input" data-lang-placeholder-zh="请输入您的昵称" data-lang-placeholder-en="Enter your nickname">
            <select id="gender-select">
                <option value="male" data-lang-zh="男" data-lang-en="Male">男</option>
                <option value="female" data-lang-zh="女" data-lang-en="Female">女</option>
                <option value="other" data-lang-zh="其他" data-lang-en="Other">其他</option>
            </select>
            <button id="start-game-btn" data-lang-zh="开始游戏" data-lang-en="Start Game">开始游戏</button>
        </div>
    </div>

    <div id="main-menu-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="welcome-message"></h2>
            <button id="campaign-mode-btn" data-lang-zh="通关模式" data-lang-en="Campaign Mode">通关模式</button>
            <button id="free-mode-btn" data-lang-zh="自由模式" data-lang-en="Free Mode">自由模式</button>
            <button id="custom-mode-btn" data-lang-zh="自定义模式" data-lang-en="Custom Mode" disabled>自定义模式</button>
            <button id="editor-mode-btn" data-lang-zh="地图编辑器" data-lang-en="Map Editor">地图编辑器</button>
            <div id="main-menu-info-box" class="menu-info-box"></div>
        </div>
    </div>
    
    <div id="level-complete-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="results-title"></h2>
            <div id="results-medal"></div>
            <p id="results-stats"></p>
            <p id="results-quote"></p>
            <button id="next-level-btn" data-lang-zh="下一关" data-lang-en="Next Level">下一关</button>
            <button id="main-menu-btn" data-lang-zh="返回主菜单" data-lang-en="Main Menu">返回主菜单</button>
        </div>
    </div>

    <div id="settings-panel" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="设置" data-lang-en="Settings">设置</h2>
            <div class="settings-group">
                <label for="language-select" data-lang-zh="语言" data-lang-en="Language">语言</label>
                <select id="language-select">
                    <option value="zh">中文</option>
                    <option value="en">English</option>
                </select>
            </div>
            <div class="settings-group">
                <label for="font-size-slider" data-lang-zh="字体大小" data-lang-en="Font Size">字体大小</label>
                <input type="range" id="font-size-slider" min="0.8" max="1.5" step="0.1" value="1">
            </div>
            <div class="settings-group">
                <label for="minimap-size-slider" data-lang-zh="小地图大小" data-lang-en="Minimap Size">小地图大小</label>
                <input type="range" id="minimap-size-slider" min="1" max="1.414" step="0.01" value="1">
            </div>
            <div class="settings-group">
                <label for="helper-text-toggle" data-lang-zh="辅助文字" data-lang-en="Helper Text">辅助文字</label>
                <select id="helper-text-toggle">
                    <option value="on" data-lang-zh="开启" data-lang-en="On">开启</option>
                    <option value="off" data-lang-zh="关闭" data-lang-en="Off">关闭</option>
                </select>
            </div>
            <button id="close-settings-btn" data-lang-zh="关闭" data-lang-en="Close">关闭</button>
        </div>
    </div>

    <div id="pause-menu-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="暂停菜单" data-lang-en="Pause Menu">暂停菜单</h2>
            <button id="resume-game-btn" data-lang-zh="返回游戏" data-lang-en="Resume Game">返回游戏</button>
            <button id="level-select-btn" data-lang-zh="选择关卡" data-lang-en="Select Level">选择关卡</button>
            <button id="reset-game-btn" data-lang-zh="重置游戏" data-lang-en="Reset Game">重置游戏</button>
            <button id="pause-to-main-menu-btn" data-lang-zh="返回主菜单" data-lang-en="Main Menu">返回主菜单</button>
        </div>
    </div>

    <div id="level-select-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="选择关卡" data-lang-en="Select Level">选择关卡</h2>
            <div id="level-select-grid"></div>
            <button id="close-level-select-btn" data-lang-zh="返回" data-lang-en="Back">返回</button>
        </div>
    </div>
    
    <div id="editor-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="地图编辑器" data-lang-en="Map Editor">地图编辑器</h2>
            <div id="editor-toolbar">
                <select id="editor-slot-select"></select>
                <button id="tool-wall" data-tool="wall" data-lang-zh="墙" data-lang-en="Wall">墙</button>
                <button id="tool-path" data-tool="path" data-lang-zh="路" data-lang-en="Path">路</button>
                <button id="tool-start" data-tool="start" data-lang-zh="起点" data-lang-en="Start">起点</button>
                <button id="tool-goal" data-tool="goal" data-lang-zh="终点" data-lang-en="Goal">终点</button>
            </div>
            <div id="editor-grid"></div>
            <p id="editor-message" style="color: red; min-height: 1.2em;"></p>
            <button id="editor-save-btn" data-lang-zh="保存地图" data-lang-en="Save Map">保存地图</button>
            <button id="editor-delete-btn" data-lang-zh="删除此地图" data-lang-en="Delete Map" class="danger">删除此地图</button>
            <button id="editor-back-btn" data-lang-zh="返回主菜单" data-lang-en="Back to Menu">返回主菜单</button>
        </div>
    </div>
    
    <div id="custom-maps-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="自定义地图" data-lang-en="Custom Maps">自定义地图</h2>
            <div id="custom-maps-grid"></div>
            <p data-lang-zh="选择一张地图进行操作。" data-lang-en="Select a map to continue.">选择一张地图进行操作。</p>
            <button id="custom-play-btn" data-lang-zh="游玩" data-lang-en="Play" disabled>游玩</button>
            <button id="custom-edit-btn" data-lang-zh="编辑" data-lang-en="Edit" disabled>编辑</button>
            <button id="custom-delete-btn" data-lang-zh="删除" data-lang-en="Delete" disabled class="danger">删除</button>
            <button id="custom-back-btn" data-lang-zh="返回主菜单" data-lang-en="Back to Menu">返回主菜单</button>
        </div>
    </div>

    <!-- MODIFIED: Modal for Big Map View with detailed legend -->
    <div id="big-map-view-modal" class="modal-overlay" style="display: none;">
        <div class="big-map-flex-container">
            <div id="map-instructions-panel" class="modal-content" style="width: auto; max-width: 350px; text-align: left; padding: 30px;">
                <h3 id="map-instructions-title" data-lang-zh="地图说明" data-lang-en="Map Instructions">地图说明</h3>
                <ul>
                    <li>
                        
<svg class="legend-icon" viewBox="0 0 24 24" aria-label="您的位置箭头">
    <defs>
        <radialGradient id="legendPlayerGrad" cx="50%" cy="50%" r="50%">
            <stop offset="0%" stop-color="#ff8080"/>
            <stop offset="100%" stop-color="#c00000"/>
        </radialGradient>
    </defs>
    <path d="M4 12 L16 4 L16 9 L21 9 L21 15 L16 15 L16 20 Z"
          fill="url(#legendPlayerGrad)" stroke="#006400" stroke-width="2" stroke-linejoin="round"/>
</svg>

                        <span data-lang-zh="您的位置 (红色箭头)" data-lang-en="Your Position (Red Arrow)">您的位置 (红色箭头)</span>
                    </li>
                    <li>
                        <span class="map-legend-swatch swatch-start"></span>
                        <span data-lang-zh="起点 (蓝色方块)" data-lang-en="Start Point (Blue Square)">起点 (蓝色方块)</span>
                    </li>
                    <li>
                        <span class="map-legend-swatch swatch-goal"></span>
                        <span data-lang-zh="终点 (红色方块)" data-lang-en="Goal (Red Square)">终点 (红色方块)</span>
                    </li>
                </ul>
                <p class="instruction-text" data-lang-zh="请仔细规划路线，准备好后，用鼠标左键点击大地图开始驾驶。" data-lang-en="Plan your route carefully. When ready, click the big map to start driving.">
                    请仔细规划路线，准备好后，用鼠标左键点击大地图开始驾驶。
                </p>
            </div>
            <div id="big-map-container-wrapper">
                <!-- The minimap canvas container will be moved here by JS -->
            </div>
        </div>
    </div>

    <div id="mode-select-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="选择导航模式" data-lang-en="Select Navigation Mode">选择导航模式</h2>
            <button id="mode-select-minimap-btn" data-lang-zh="小地图导航" data-lang-en="Minimap Navigation">小地图导航</button>
            <button id="mode-select-challenge-btn" data-lang-zh="自主导航" data-lang-en="Autonomous Navigation">自主导航</button>
            <div id="nav-mode-info-box" class="menu-info-box"></div>
        </div>
    </div>
    
    <div id="confirm-reset-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="确认重置" data-lang-en="Confirm Reset">确认重置</h2>
            <p data-lang-zh="您确定要重置所有游戏数据吗？此操作无法撤销。" data-lang-en="Are you sure you want to reset all game data? This action cannot be undone.">您确定要重置所有游戏数据吗？此操作无法撤销。</p>
            <div class="button-row">
                <button id="confirm-reset-btn" class="danger" data-lang-zh="确认" data-lang-en="Confirm">确认</button>
                <button id="cancel-reset-btn" class="secondary" data-lang-zh="取消" data-lang-en="Cancel">取消</button>
            </div>
        </div>
    </div>


    <div id="dev-panel">
        <h4 data-lang-zh="关卡快速切换" data-lang-en="Quick Level Select">关卡快速切换</h4>
        <select id="level-select"></select>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // ====================================================================
        // 全局变量和状态机 (Global Variables & State Machine)
        // ====================================================================
        
        const TILE_SIZE = 10;
        const WALL_HEIGHT = 5;
        const MOVE_SPEED = 15;
        const TURN_SPEED = Math.PI * 2;

        
        const LUCKY_CAT = {
            WAVE_CENTER_DEG: 30,
            WAVE_AMPL_DEG: 10,
            WAVE_SPEED: 5.0,
            WRIST_AMPL_DEG: 8,
            WRIST_SPEED: 10.0
        };
        let scene, camera, renderer, clock;
        let starField;
        let player, mazeGroup, landmarksGroup, goalMarker, sceneryGroup, steeringWheel;
        let minimap, minimapCtx;
        
        let gameState = 'STARTUP_MODAL';
        let gameMode = 'campaign';
        let navigationMode = 'minimap';
        let currentLevelIndex = 0;
        let playerInfo = { nickname: 'Driver', gender: 'other' };

        let playerChoices = 0;
        let optimalChoices = 0;
        let mapViewChances = 3;
        
        let targetPosition = new THREE.Vector3();
        let targetRotation = new THREE.Euler();
        let previousGameState = '';
        let unlockedLevel = 0;

        const keyState = { 'a': false, 'd': false, 'e': false, 'space': false, 'escape': false };
        let keyDebounce = false;

        let wallMaterialNS, wallMaterialEW, floorMaterial, landmarkMaterial, goalWallMaterial;
        let hemisphereLight, dirLight;
        
        let customLevels = [];
        let luckyCatArm, luckyCatWrist, floatingHeart;

        let currentLanguage = 'zh';
        let promptTimeout;
        let hintTimeout;

        // ====================================================================
        // 语言翻译数据 (Language Translation Data)
        // ====================================================================
        const translations = {
            zh: {
                welcome: (nickname) => `你好, ${nickname}!`,
                levelComplete: "关卡完成！",
                drivingGenius: "驾驶天才",
                greatDriver: "优秀司机",
                newDriver: "新手上路",
                quoteGenius: "完美！你就是这座城市的传奇！",
                quoteGreat: "干得漂亮！路线规划得非常出色。",
                quoteNew: "安全到达！经验丰富的选择。",
                stats: (p, o, r) => `你的步数: ${p} | 最优步数: ${o} | R值: ${r}`,
                freeModeComplete: "自由模式练习完成。",
                nextLevel: "下一关",
                finalResults: "查看最终结果",
                select: "选择",
                forward: "向前",
                turnLeft: "向左",
                turnRight: "向右",
                turnAround: "掉头",
                helperText: "按 A/D 转向, 空格前进",
                level: "关卡",
                confirmReset: "您确定要重置所有游戏数据吗？此操作无法撤销。",
                allLevelsCleared: "恭喜你！已通关所有关卡！",
                mapChances: "查看地图次数",
                editor_need_start: "地图需要一个起点。",
                editor_need_goal: "地图需要一个终点。",
                editor_unsolvable: "地图无解！请确保起点和终点连通。",
                map_slot: "地图槽",
                empty_slot: "空槽位",
                confirm_delete: "您确定要删除这张地图吗？",
                desc_campaign: "挑战一系列精心设计的关卡，从易到难，解锁全部地图并成为驾驶大师。",
                desc_free: "自由选择任何已解锁的关卡进行练习，没有步数和成绩的压力。",
                desc_custom: "游玩、编辑或删除您在地图编辑器中创作的地图。",
                desc_editor: "发挥你的创造力！设计、建造并保存属于你自己的迷宫地图。",
                desc_minimap: "屏幕上会始终显示一个小地图，帮助您轻松定位和规划路线。",
                desc_challenge: "挑战模式！地图不会一直显示，您只有有限的几次查看地图的机会。",
                prompt_wall: "前方是墙壁，请选择其他方向。",
                prompt_options: (options) => `可选方向: ${options.join(' | ')}`,
                hint_ingame_controls: "提示：点击左上角 ⚙️ 更改设置，按 [ESC] 可打开菜单。",
                // NEW HINTS (v7.8h)
                hint_driving_start: "提示：黄色箭头指的是没有墙阻挡的可选方向，不是导航方向。",
                prompt_dead_end: "遇到死胡同！连续按两次 [A] 或 [D] 键可以掉头。",
                prompt_near_goal: "再往前一步就到达目的地了！"
            },
            en: {
                welcome: (nickname) => `Hello, ${nickname}!`,
                levelComplete: "Level Complete!",
                drivingGenius: "Driving Genius",
                greatDriver: "Great Driver",
                newDriver: "New Driver",
                quoteGenius: "Perfect! You are a legend in this city!",
                quoteGreat: "Well done! An excellent route plan.",
                quoteNew: "Arrived safely! A solid choice.",
                stats: (p, o, r) => `Your Steps: ${p} | Optimal: ${o} | R-Value: ${r}`,
                freeModeComplete: "Free mode practice complete.",
                nextLevel: "Next Level",
                finalResults: "View Final Results",
                select: "Select",
                forward: "Forward",
                turnLeft: "Turn Left",
                turnRight: "Turn Right",
                turnAround: "Turn Around",
                helperText: "Use A/D to turn, Space to move",
                level: "Level",
                confirmReset: "Are you sure you want to reset all game data? This action cannot be undone.",
                allLevelsCleared: "Congratulations! You have cleared all levels!",
                mapChances: "Map Views Left",
                editor_need_start: "Map needs a starting point.",
                editor_need_goal: "Map needs a goal point.",
                editor_unsolvable: "Map is unsolvable! Make sure the start and goal are connected.",
                map_slot: "Map Slot",
                empty_slot: "Empty Slot",
                confirm_delete: "Are you sure you want to delete this map?",
                desc_campaign: "Challenge a series of designed levels, from easy to hard, unlock all maps and become a master driver.",
                desc_free: "Freely select any unlocked level for practice without the pressure of steps and scores.",
                desc_custom: "Play, edit, or delete the maps you've created in the map editor.",
                desc_editor: "Unleash your creativity! Design, build, and save your own maze maps.",
                desc_minimap: "A small map will always be displayed on the screen to help you easily locate and plan your route.",
                desc_challenge: "Challenge mode! The map is not always visible, and you have limited chances to view it.",
                prompt_wall: "There is a wall ahead, please choose another direction.",
                prompt_options: (options) => `Available moves: ${options.join(' | ')}`,
                hint_ingame_controls: "Hint: Click the ⚙️ in the top-left to change settings. Press [ESC] to open the menu.",
                // NEW HINTS (v7.8h)
                hint_driving_start: "Hint: Yellow arrows indicate available directions without walls, not a navigation path.",
                prompt_dead_end: "Dead end! Press [A] or [D] twice to turn around.",
                prompt_near_goal: "One more step to the destination!"
            }
        };

        // ====================================================================
        // 关卡数据 (Level Data)
        // ====================================================================
// ===== New: 5 easier intro levels (7x7 .. 11x11), each has ≥2 branches & ≥1 dead end =====
const INTRO_MAZES = [
    // Intro 1 (7x7)
    [[1,1,1,1,1,1,1],
     [1,0,0,0,1,'E',1],
     [1,0,1,0,1,0,1],
     [1,0,1,0,0,0,1],
     [1,0,1,1,1,0,1],
     [1,'S',0,0,1,0,1],
     [1,1,1,1,1,1,1]],
    // Intro 2 (8x8)
    [[1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,0,1],
     [1,0,1,1,1,1,0,1],
     [1,0,1,0,0,1,0,1],
     [1,0,1,0,0,1,0,1],
     [1,0,0,0,1,0,0,1],
     [1,0,1,0,1,0,'E',1],
     [1,1,1,1,1,1,1,1]],
    // Intro 3 (9x9)
    [[1,1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,1,0,0,1],
     [1,0,1,1,0,1,0,1,1],
     [1,0,0,1,0,0,0,0,1],
     [1,1,0,1,1,1,1,0,1],
     [1,0,0,0,0,0,1,0,1],
     [1,0,1,1,1,0,1,0,1],
     [1,0,0,0,1,0,0,'E',1],
     [1,1,1,1,1,1,1,1,1]],
    // Intro 4 (10x10)
    [[1,1,1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,0,1,0,1],
     [1,0,1,1,1,1,0,1,0,1],
     [1,0,0,0,0,1,0,0,0,1],
     [1,1,1,1,0,1,1,1,0,1],
     [1,0,0,1,0,0,0,1,0,1],
     [1,0,0,1,1,1,0,1,0,1],
     [1,0,1,0,0,0,0,1,0,1],
     [1,0,1,0,1,1,0,'E',0,1],
     [1,1,1,1,1,1,1,1,1,1]],
    // Intro 5 (11x11)
    [[1,1,1,1,1,1,1,1,1,1,1],
     [1,'S',0,0,0,0,1,0,0,0,1],
     [1,0,1,1,1,0,1,0,1,0,1],
     [1,0,0,0,1,0,0,0,1,0,1],
     [1,1,1,0,1,1,1,0,1,0,1],
     [1,0,0,0,0,0,1,0,0,0,1],
     [1,0,1,1,1,0,1,1,1,0,1],
     [1,0,0,0,1,0,0,0,1,0,1],
     [1,1,0,0,1,1,1,0,1,0,1],
     [1,0,0,0,0,0,0,0,0,'E',1],
     [1,1,1,1,1,1,1,1,1,1,1]]
];
        const MAZE_DATA = [...INTRO_MAZES, 
            // Level 1 (15x15)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',1,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1],[1,0,0,0,1,0,1,0,1,0,1,0,0,'S',1],[1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,0,1,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,1,1],[1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 2 (15x15)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,0,1,0,1,0,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,1,'S',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 3 (15x15)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,'S',1,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 4 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',1,0,0,'S',1,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1],[1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 5 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1],[1,0,1,0,0,0,0,0,0,0,1,0,1,'E',0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 6 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,1],[1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1],[1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 7 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,'E',1],[1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1],[1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 8 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],[1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1],[1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1],[1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],[1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1],[1,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1],[1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 9 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],[1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1],[1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1],[1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1],[1,0,0,0,0,1,0,0,0,1,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,0,1,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 10 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 11 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1],[1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 12 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],[1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1],[1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,0,1],[1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1],[1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,0,1],[1,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,1],[1,0,1,1,1,1,0,1,'S',1,0,1,1,1,0,1,1],[1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,1],[1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1],[1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1],[1,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,1,0,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 13 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1],[1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1],[1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1],[1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1],[1,'E',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 14 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1],[1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 15 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,1,'S',0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1],[1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1,'E',0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
        ];
        
        const levels = MAZE_DATA.map(mazeData => {
            const grid = [];
            let start = {};
            let goal = {};
            const height = mazeData.length;
            const width = mazeData[0].length;

            for(let z = 0; z < height; z++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    const cell = mazeData[z][x];
                    if (cell === 'S') {
                        start = { x, z, dir: 'S' };
                        row.push(1);
                    } else if (cell === 'E') {
                        goal = { x, z };
                        row.push(1);
                    } else {
                        row.push(cell === 1 ? 0 : 1);
                    }
                }
                grid.push(row);
            }
            
            if (start.x === 0) start.dir = 'E';
            else if (start.x === width - 1) start.dir = 'W';
            else if (start.z === 0) start.dir = 'S';
            else if (start.z === height - 1) start.dir = 'N';

            return { grid, start, goal };
        });

        // ====================================================================
        // 初始化函数 (Initialization)
        // ====================================================================
        
        function init() {
            scene = new THREE.Scene();
            
            // === DEBUG: Resilient Skybox Loader ===
            // The original code was trying to load local files (e.g., 'px.jpg'),
            // which is blocked by browser CORS policy when opening an HTML file directly.
            // This function is modified to always use the gradient fallback,
            // avoiding the CORS errors. The original skybox loading is commented out.
         function setupSkyBackground() {
  const loader = new THREE.TextureLoader();
  loader.load(
    'assets/sky_gradient_starry.png',
    function (texture) {
      // 使用 equirectangular 映射，使全景天空正确显示
      texture.mapping = THREE.EquirectangularReflectionMapping;
      // 设置场景背景和环境贴图为星空纹理
      scene.background = texture;
      scene.environment = texture;
    },
    undefined,
    function (err) {
      console.warn('Failed to load sky texture', err);
      // 如果加载失败，可设置备用颜色或简易渐变
      if (typeof renderer !== 'undefined' && renderer.setClearColor) {
        renderer.setClearColor(0x0a152b, 1); // 备用深色天空
      }
    }
  );
}


            setupSkyBackground();
            
            scene.fog = new THREE.Fog(0x87ceeb, TILE_SIZE * 7, TILE_SIZE * 28);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);
            renderer.setClearColor(scene.fog.color, 1);
            clock = new THREE.Clock();

            hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
            hemisphereLight.position.set(0, 20, 0);
            scene.add(hemisphereLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
            dirLight.position.set(-1, 1.75, 1);
            dirLight.position.multiplyScalar(30);
            scene.add(dirLight);

            player = new THREE.Object3D();
            scene.add(player);
            player.add(camera);

            camera.position.set(0, WALL_HEIGHT * 0.4, 0);
            camera.rotation.x = THREE.MathUtils.degToRad(-8);

            const headLight = new THREE.SpotLight(0xffffff, 10, 8 * TILE_SIZE, Math.PI / 4, 0.5, 1.5);
            headLight.position.set(0, 0, 1);
            camera.add(headLight);

            mazeGroup = new THREE.Group();
            sceneryGroup = new THREE.Group();
            scene.add(mazeGroup);
            scene.add(sceneryGroup);
            
            landmarksGroup = new THREE.Group();
            camera.add(landmarksGroup);
            
            steeringWheel = createSteeringWheel();
            camera.add(steeringWheel);
            
            minimap = document.getElementById('minimap-canvas');
            minimapCtx = minimap.getContext('2d');

            createMaterials();
            loadCustomLevels();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            setupUI();
            updateUIText();
            
            createStarField();
            
            animate();
        }

        function setupUI() {
            document.getElementById('initial-language-select').addEventListener('change', (e) => {
                currentLanguage = e.target.value;
                updateUIText();
            });

            document.getElementById('start-game-btn').addEventListener('click', () => {
                currentLanguage = document.getElementById('initial-language-select').value;
                document.getElementById('language-select').value = currentLanguage;

                const nickname = document.getElementById('nickname-input').value.trim();
                playerInfo.nickname = nickname || (currentLanguage === 'zh' ? '司机' : 'Driver');
                playerInfo.gender = document.getElementById('gender-select').value;

                document.getElementById('startup-modal').style.display = 'none';
                document.getElementById('main-menu-modal').style.display = 'flex';
                updateUIText();
                gameState = 'MAIN_MENU';
            });

            const setupMenuInfo = (buttonId, infoBoxId, descriptionKey) => {
                const button = document.getElementById(buttonId);
                const infoBox = document.getElementById(infoBoxId);
                if (button && infoBox) {
                    button.addEventListener('mouseover', () => {
                        infoBox.innerHTML = `<p>${translations[currentLanguage][descriptionKey]}</p>`;
                    });
                    button.addEventListener('mouseout', () => {
                        infoBox.innerHTML = '';
                    });
                }
            };

            setupMenuInfo('campaign-mode-btn', 'main-menu-info-box', 'desc_campaign');
            setupMenuInfo('free-mode-btn', 'main-menu-info-box', 'desc_free');
            setupMenuInfo('custom-mode-btn', 'main-menu-info-box', 'desc_custom');
            setupMenuInfo('editor-mode-btn', 'main-menu-info-box', 'desc_editor');
            setupMenuInfo('mode-select-minimap-btn', 'nav-mode-info-box', 'desc_minimap');
            setupMenuInfo('mode-select-challenge-btn', 'nav-mode-info-box', 'desc_challenge');


            document.getElementById('campaign-mode-btn').addEventListener('click', () => {
                gameMode = 'campaign';
                document.getElementById('main-menu-modal').style.display = 'none';
                document.getElementById('mode-select-modal').style.display = 'flex';
            });

            document.getElementById('free-mode-btn').addEventListener('click', () => {
                gameMode = 'free'; 
                document.getElementById('main-menu-modal').style.display = 'none';
                document.getElementById('mode-select-modal').style.display = 'flex';
            });
            
            document.getElementById('editor-mode-btn').addEventListener('click', () => showEditor());
            
            document.getElementById('custom-mode-btn').addEventListener('click', () => {
                if (customLevels.some(level => level !== null)) {
                    gameMode = 'custom';
                    showCustomMapsModal();
                }
            });
            
            function startGameFromModeSelect() {
                document.getElementById('mode-select-modal').style.display = 'none';
                
                if (gameMode === 'free') {
                    setupDevPanel();
                    document.getElementById('dev-panel').style.display = 'block';
                    loadLevel(0);
                } else if (gameMode === 'custom') {
                    loadLevel(customLevels[selectedCustomMapIndex]);
                } else if (gameMode === 'campaign') {
                    document.getElementById('dev-panel').style.display = 'none';
                    loadLevel(0);
                }
            }

            document.getElementById('mode-select-minimap-btn').addEventListener('click', () => {
                navigationMode = 'minimap';
                startGameFromModeSelect();
            });
            
            document.getElementById('mode-select-challenge-btn').addEventListener('click', () => {
                navigationMode = 'limited';
                startGameFromModeSelect();
            });

            document.getElementById('next-level-btn').addEventListener('click', () => {
                document.getElementById('level-complete-modal').style.display = 'none';
                if (currentLevelIndex !== -1) {
                    currentLevelIndex++;
                    if (currentLevelIndex < levels.length) {
                        loadLevel(currentLevelIndex);
                    } else {
                        alert(translations[currentLanguage].allLevelsCleared);
                        showMainMenu();
                    }
                }
            });
            document.getElementById('main-menu-btn').addEventListener('click', () => {
                document.getElementById('level-complete-modal').style.display = 'none';
                showMainMenu();
            });

            document.getElementById('minimap-container').addEventListener('click', () => {
                if (gameState === 'BIG_MAP') {
                    const bigMapViewModal = document.getElementById('big-map-view-modal');
                    const minimapContainer = document.getElementById('minimap-container');
                    bigMapViewModal.style.display = 'none';
                    document.body.appendChild(minimapContainer); 
                    
                    const container = document.getElementById('minimap-container');
                    if (navigationMode === 'limited') {
                        container.style.display = 'none';
                    } else {
                        container.classList.remove('big-map');
                        container.classList.add('small-map');
                    }
                    gameState = 'AT_INTERSECTION';
                    checkForTurns();
                    
                    showIngameHint('hint_driving_start'); // MODIFIED: Show specific hint

                } else if (gameState === 'CHALLENGE_MAP_VIEW') {
                    toggleChallengeMap();
                }
            });

            document.getElementById('settings-button').addEventListener('click', () => {
                document.getElementById('settings-panel').style.display = 'flex';
            });
            document.getElementById('close-settings-btn').addEventListener('click', () => {
                document.getElementById('settings-panel').style.display = 'none';
            });
            document.getElementById('font-size-slider').addEventListener('input', (e) => {
                document.body.style.fontSize = `calc(${getComputedStyle(document.body).getPropertyValue('--font-size-normal')} * ${e.target.value})`;
            });
            document.getElementById('minimap-size-slider').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--minimap-scale', e.target.value);
            });
            document.getElementById('language-select').addEventListener('change', (e) => {
                currentLanguage = e.target.value;
                document.getElementById('initial-language-select').value = currentLanguage;
                updateUIText();
            });
            
            document.getElementById('resume-game-btn').addEventListener('click', togglePauseMenu);
            document.getElementById('pause-to-main-menu-btn').addEventListener('click', () => {
                togglePauseMenu();
                showMainMenu();
            });
            document.getElementById('level-select-btn').addEventListener('click', showLevelSelectModal);
            
            document.getElementById('reset-game-btn').addEventListener('click', () => {
                document.getElementById('confirm-reset-modal').style.display = 'flex';
            });
            
            document.getElementById('confirm-reset-btn').addEventListener('click', () => {
                document.getElementById('confirm-reset-modal').style.display = 'none';
                resetGame();
            });

            document.getElementById('cancel-reset-btn').addEventListener('click', () => {
                document.getElementById('confirm-reset-modal').style.display = 'none';
            });

            document.getElementById('close-level-select-btn').addEventListener('click', () => {
                document.getElementById('level-select-modal').style.display = 'none';
                document.getElementById('pause-menu-modal').style.display = 'flex';
            });
        }

        function setupDevPanel() {
            const select = document.getElementById('level-select');
            select.innerHTML = '';
            levels.forEach((_, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${translations[currentLanguage].level} ${index + 1}`;
                select.appendChild(option);
            });
            select.addEventListener('change', (e) => {
                loadLevel(parseInt(e.target.value));
            });
            // 让下拉保持与当前关卡同步
            select.value = String(currentLevelIndex);
        }
        
        function showMainMenu() {
            gameState = 'MAIN_MENU';
            document.getElementById('main-menu-modal').style.display = 'flex';
            document.getElementById('custom-mode-btn').disabled = !customLevels.some(level => level !== null);

            document.getElementById('main-menu-info-box').innerHTML = '';
            document.getElementById('nav-mode-info-box').innerHTML = '';

            while(mazeGroup.children.length > 0){ mazeGroup.remove(mazeGroup.children[0]); }
            while(landmarksGroup.children.length > 0){ landmarksGroup.remove(landmarksGroup.children[0]); }
            while(sceneryGroup.children.length > 0){ sceneryGroup.remove(sceneryGroup.children[0]); }
            if(goalMarker) scene.remove(goalMarker);

            document.getElementById('minimap-container').style.display = 'none';
            document.getElementById('map-view-count').style.display = 'none';
            document.getElementById('big-map-prompt').style.display = 'none';
            document.getElementById('ingame-hint').style.display = 'none';
            clearTimeout(hintTimeout);
        }

        // ====================================================================
        // 游戏核心逻辑 (Core Game Logic)
        // ====================================================================
        
        function loadLevel(levelData) {
            let level;
            if (typeof levelData === 'number') {
                if (levelData >= levels.length) {
                    console.error(`Level index ${levelData} out of bounds!`);
                    showMainMenu();
                    return;
                }
                currentLevelIndex = levelData;
                level = levels[levelData];
            } else {
                level = levelData;
                currentLevelIndex = -1;
            }
            
            clearTimeout(hintTimeout);
            document.getElementById('ingame-hint').style.display = 'none';

            playerChoices = 0;
            document.getElementById('choice-prompt').style.display = 'none';

            while(mazeGroup.children.length > 0){ mazeGroup.remove(mazeGroup.children[0]); }
            while(landmarksGroup.children.length > 0){ camera.remove(landmarksGroup); landmarksGroup = new THREE.Group(); camera.add(landmarksGroup); }
            while(sceneryGroup.children.length > 0){ sceneryGroup.remove(sceneryGroup.children[0]); }
            if(goalMarker) scene.remove(goalMarker);

            createMazeMesh(level.grid, level.goal);
            placeRoadsideObjects(level.grid);
            createGoalMarker(level.goal);
            
            const startPos = gridToWorld(level.start.x, level.start.z, level.grid);
            player.position.set(startPos.x, 0, startPos.z);
            player.rotation.y = dirToAngle(level.start.dir);
            targetRotation.y = player.rotation.y;

            const pathInfo = findShortestPath(level);
            // 同步开发者面板选择状态（自由模式）
            const dev = document.getElementById('level-select');
            if (dev && getComputedStyle(document.getElementById('dev-panel')).display === 'block' && currentLevelIndex >= 0) {
                dev.value = String(currentLevelIndex);
            }
            if (!pathInfo) {
                const message = `Level ${currentLevelIndex >= 0 ? currentLevelIndex + 1 : 'Custom'} is unsolvable!`;
                alert(message);
                console.error(message, level);
                showMainMenu();
                return;
            }
            optimalChoices = pathInfo.choices;
            console.log(`Level ${currentLevelIndex >= 0 ? currentLevelIndex + 1 : 'Custom'}: Optimal Steps = ${optimalChoices}`);
            
            if (navigationMode === 'limited') {
                mapViewChances = 3;
            }
            updateHUD();
            
            lastPlayerGridPos = { x: -1, z: -1 }; 
            updateMinimapPlayer();
            
            gameState = 'BIG_MAP';
            
            const bigMapViewModal = document.getElementById('big-map-view-modal');
            const bigMapWrapper = document.getElementById('big-map-container-wrapper');
            const minimapContainer = document.getElementById('minimap-container');

            bigMapWrapper.appendChild(minimapContainer);
            minimapContainer.style.display = 'block';
            minimapContainer.classList.remove('small-map');
            minimapContainer.classList.add('big-map');
            
            // The text is now part of the HTML, so we just need to ensure it's translated
            updateUIText();
            
            bigMapViewModal.style.display = 'flex';
            document.getElementById('big-map-prompt').style.display = 'none'; 
        }

        function gridToWorld(x, z, grid) {
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;
            return new THREE.Vector3(
                (x - gridWidth / 2 + 0.5) * TILE_SIZE,
                0,
                (z - gridHeight / 2 + 0.5) * TILE_SIZE
            );
        }
        
        function worldToGrid(position) {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            if (!level) return {x:0, z:0};
            const gridWidth = level.grid[0].length;
            const gridHeight = level.grid.length;
            return {
                x: Math.round(position.x / TILE_SIZE + gridWidth / 2 - 0.5),
                z: Math.round(position.z / TILE_SIZE + gridHeight / 2 - 0.5)
            };
        }
        
        function dirToAngle(dir) {
            switch (dir) {
                case 'N': return Math.PI;
                case 'E': return -Math.PI / 2;
                case 'S': return 0;
                case 'W': return Math.PI / 2;
            }
            return 0;
        }

        function checkForTurns() {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            const gridPos = worldToGrid(player.position);
            const { goal } = level;

            if (gridPos.x === goal.x && gridPos.z === goal.z) {
                gameState = 'LEVEL_COMPLETE';
                showLevelComplete();
                return;
            }
            
            const availableTurns = createDirectionalHelpers();
            updateChoicePrompt(availableTurns);
            gameState = 'AT_INTERSECTION';
        }

        function cameraShake() {
            const shakeIntensity = 0.05;
            let shakeDuration = 200;
            const startTime = Date.now();

            function shake() {
                const elapsedTime = Date.now() - startTime;
                if (elapsedTime > shakeDuration) {
                    camera.position.set(0, WALL_HEIGHT * 0.4, 0);
                    return;
                }
                const progress = elapsedTime / shakeDuration;
                const shakeAmount = shakeIntensity * (1 - progress);
                const shakeX = (Math.random() - 0.5) * shakeAmount;
                const shakeY = (Math.random() - 0.5) * shakeAmount;
                camera.position.set(shakeX, WALL_HEIGHT * 0.4 + shakeY, 0);
                requestAnimationFrame(shake);
            }
            shake();
        }
        
        function showTemporaryMessage(message, duration = 2000) {
            const prompt = document.getElementById('choice-prompt');
            prompt.textContent = message;
            prompt.style.display = 'inline-block';

            clearTimeout(promptTimeout);
            promptTimeout = setTimeout(() => {
                if (gameState === 'AT_INTERSECTION') {
                    checkForTurns();
                }
            }, duration);
        }

        function updateChoicePrompt(availableTurns) {
            const prompt = document.getElementById('choice-prompt');
            const helperToggle = document.getElementById('helper-text-toggle').value;
            const lang = translations[currentLanguage];

            if (gameState !== 'AT_INTERSECTION' || helperToggle === 'off') {
                prompt.style.display = 'none';
                return;
            }
            
            prompt.style.display = 'inline-block';
            
            const options = [];
            if (availableTurns.forward) options.push(`${lang.forward} [空格]`);
            if (availableTurns.left) options.push(`${lang.turnLeft} [A]`);
            if (availableTurns.right) options.push(`${lang.turnRight} [D]`);

            // MODIFIED (v7.8h): Dead-end check
            if (!availableTurns.forward && !availableTurns.left && !availableTurns.right) {
                prompt.textContent = lang.prompt_dead_end;
            } else if (options.length > 0) {
                prompt.textContent = lang.prompt_options(options);
            } else {
                // This case should now be covered by the dead-end check.
                prompt.textContent = lang.turnAround; 
            }
        }

        function setupMove() {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            const gridPos = worldToGrid(player.position);
            const moveVector = new THREE.Vector3(0, 0, -1).applyEuler(player.rotation);
            const nextGridX = gridPos.x + Math.round(moveVector.x);
            const nextGridZ = gridPos.z + Math.round(moveVector.z);

            // MODIFIED (v7.8h): Goal hint check
            if (nextGridX === level.goal.x && nextGridZ === level.goal.z) {
                showTemporaryMessage(translations[currentLanguage].prompt_near_goal, 2500);
            }

            if (nextGridZ < 0 || nextGridZ >= level.grid.length || nextGridX < 0 || nextGridX >= level.grid[0].length || level.grid[nextGridZ][nextGridX] === 0) {
                cameraShake();
                showTemporaryMessage(translations[currentLanguage].prompt_wall);
            } else {
                playerChoices++;
                document.getElementById('choice-prompt').style.display = 'none';
                while (landmarksGroup.children.length > 0) {
                    landmarksGroup.remove(landmarksGroup.children[0]);
                }
                targetPosition.copy(gridToWorld(nextGridX, nextGridZ, level.grid));
                gameState = 'DRIVING';
            }
        }
        
        function showLevelComplete() {
            const modal = document.getElementById('level-complete-modal');
            const stats = document.getElementById('results-stats');
            const medalEl = document.getElementById('results-medal');
            const quoteEl = document.getElementById('results-quote');
            const nextBtn = document.getElementById('next-level-btn');
            const lang = translations[currentLanguage];
            
            nextBtn.style.display = 'none';

            if (gameMode === 'campaign') {
                unlockedLevel = Math.max(unlockedLevel, currentLevelIndex + 1);
                const R = optimalChoices > 0 ? playerChoices / optimalChoices : 1;
                let medal = '';
                let title = '';
                let quote = '';

                if (R <= 1.0) {
                    medal = '🥇';
                    title = lang.drivingGenius;
                    quote = lang.quoteGenius;
                } else if (R <= 1.5) {
                    medal = '🥈';
                    title = lang.greatDriver;
                    quote = lang.quoteGreat;
                } else {
                    medal = '🥉';
                    title = lang.newDriver;
                    quote = lang.quoteNew;
                }
                
                medalEl.textContent = medal;
                document.getElementById('results-title').textContent = title;
                stats.textContent = lang.stats(playerChoices, optimalChoices, R.toFixed(2));
                quoteEl.textContent = quote;
                
                stats.style.display = 'block';
                medalEl.style.display = 'block';
                quoteEl.style.display = 'block';

                if (currentLevelIndex !== -1 && currentLevelIndex < levels.length - 1) {
                    nextBtn.textContent = lang.nextLevel;
                    nextBtn.style.display = 'inline-block';
                }

            } else {
                document.getElementById('results-title').textContent = lang.levelComplete;
                stats.style.display = 'none';
                medalEl.style.display = 'none';
                quoteEl.textContent = lang.freeModeComplete;
            }
            
            modal.style.display = 'flex';
        }

        // ====================================================================
        // 渲染和动画 (Rendering & Animation)
        // ====================================================================
        
        function animate() {
            requestAnimationFrame(animate);
            if(gameState === 'PAUSED' || gameState === 'CHALLENGE_MAP_VIEW') return;
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            // --- MODIFIED: Day/Night Cycle Logic ---
            const dayNightCycle = (Math.sin(elapsedTime * (0.1 / 3)) + 1) / 2; // 1 for day, 0 for night
            const skyDay = new THREE.Color(0x87ceeb);
            const skyNight = new THREE.Color(0x210033); // MODIFIED (v7.8h): Deep purple night sky

            // Interpolate colors based on the cycle
            const visualColor = skyNight.clone().lerp(skyDay, dayNightCycle);

            // Apply colors for visual effect
            if (scene.fog) {
                scene.fog.color.copy(visualColor);
            }
            // If there's no skybox, the background should be the calculated color.
            // If there IS a skybox, the fog will tint the scene, which is the desired effect.
            if (!scene.background || !scene.background.isCubeTexture) {
                 scene.background = visualColor;
            }
            // Always update the renderer's clear color to match the fog, preventing grey flashes.
            renderer.setClearColor(visualColor, 1);

            // Apply light intensity changes
            hemisphereLight.intensity = dayNightCycle * 2.0 + 0.4;
            dirLight.intensity = dayNightCycle * 2.5 + 0.3;

            const nightIntensity = Math.max(0, 1 - dayNightCycle * 3);
            // --- END MODIFICATION ---

            sceneryGroup.children.forEach(sceneryObject => {
                const light = sceneryObject.getObjectByName('lampLight');
                if (light) {
                    light.intensity = nightIntensity * 8;
                }
            });


            if (goalMarker) {
                goalMarker.position.y = WALL_HEIGHT/2 - 1.5 + Math.sin(elapsedTime) * 0.2;
                goalMarker.rotation.y += delta * 0.4;
                if (luckyCatArm) {
                    const toRad = THREE.MathUtils.degToRad;
                    const c  = toRad(LUCKY_CAT.WAVE_CENTER_DEG);
                    const a  = toRad(LUCKY_CAT.WAVE_AMPL_DEG);
                    const w1 = LUCKY_CAT.WAVE_SPEED;

                    luckyCatArm.rotation.x = c + Math.sin(elapsedTime * w1) * a;

                    if (typeof luckyCatWrist !== 'undefined' && luckyCatWrist) {
                        const a2 = toRad(LUCKY_CAT.WRIST_AMPL_DEG);
                        const w2 = LUCKY_CAT.WRIST_SPEED;
                        luckyCatWrist.rotation.x = Math.sin(elapsedTime * w2) * a2;
                    }
                }
            }
            if (typeof floatingHeart !== 'undefined' && floatingHeart) {
                const t = elapsedTime * 1.5;
                floatingHeart.position.y = floatingHeart.userData.baseY + Math.sin(t) * 0.18;
                const s = 1.0 + Math.sin(t * 2.0) * 0.06;
                floatingHeart.scale.set(s, s, s);
                floatingHeart.rotation.y += delta * 0.6;
            }

            if (gameState === 'TURNING') {
                let angleDiff = targetRotation.y - player.rotation.y;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

                if (Math.abs(angleDiff) > 0.01) {
                    const turnStep = Math.sign(angleDiff) * TURN_SPEED * delta;
                    if (Math.abs(turnStep) >= Math.abs(angleDiff)) {
                        player.rotation.y = targetRotation.y;
                    } else {
                        player.rotation.y += turnStep;
                    }
                } else {
                    player.rotation.y = targetRotation.y;
                    gameState = 'AT_INTERSECTION';
                    checkForTurns();
                }
            }
            
            if (gameState === 'DRIVING') {
                const distanceToTarget = player.position.distanceTo(targetPosition);
                if (distanceToTarget > 0.01) {
                    const moveVector = targetPosition.clone().sub(player.position).normalize();
                    const moveDistance = Math.min(distanceToTarget, MOVE_SPEED * delta);
                    player.position.add(moveVector.multiplyScalar(moveDistance));
                } else {
                    player.position.copy(targetPosition);
                    gameState = 'AT_INTERSECTION';
                    checkForTurns();
                }
            }
            
            if (steeringWheel) {
                steeringWheel.rotation.z = (player.rotation.y - targetRotation.y) * 2;
            }
            
            if (['DRIVING', 'TURNING', 'AT_INTERSECTION', 'BIG_MAP'].includes(gameState)) {
                updateMinimapPlayer();
            }

            // --- MODIFIED: Arrow glow pulse ---
            landmarksGroup.traverse(child => {
                if (child.name === 'arrowGlow') {
                    // Pulsating effect for the red arrow halo
                    child.material.opacity = (Math.sin(elapsedTime * 6 + child.userData.phase) + 1) / 2 * 0.6 + 0.1; // Pulse between 0.1 and 0.7
                }
            });
            // --- END MODIFICATION ---

            // Night stars visibility (brighter at night, a bit visible at dusk)
            if (typeof starField !== 'undefined' && starField && starField.material) {
                const nightFactor = Math.max(0, 1 - dayNightCycle * 1.15);
                starField.material.opacity = Math.min(1.0, Math.pow(nightFactor, 0.6) * 1.2);
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ====================================================================
        // 输入处理 (Input Handling)
        // ====================================================================
        
        function onKeyDown(event) {
            if (!event || !event.key) return;
            const key = event.key.toLowerCase();
            if (keyState[key]) return;
            keyState[key] = true;

            if (key === 'escape') {
                togglePauseMenu();
                return;
            }
            
            if (key === 'e') {
                if (navigationMode === 'limited') {
                    toggleChallengeMap();
                }
                return;
            }

            if (gameState !== 'AT_INTERSECTION') return;
            
            if (key === 'a' || key === 'd') {
                if (keyDebounce) return;
                keyDebounce = true;
                setTimeout(() => { keyDebounce = false; }, 100);

                if (key === 'd') {
                    targetRotation.y -= Math.PI / 2;
                } else if (key === 'a') {
                    targetRotation.y += Math.PI / 2;
                }
                gameState = 'TURNING';
                
            } else if (key === ' ' || key === 'spacebar') {
                setupMove();
            }
        }
        
        function onKeyUp(event) {
            if (!event || !event.key) return;
            const key = event.key.toLowerCase();
            keyState[key] = false;
        }

        // ====================================================================
        // 3D迷宫与视觉生成 (3D Maze & Visuals Generation)
        // ====================================================================

        function createMazeMesh(grid, goal) {
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;

            const floorPlane = new THREE.PlaneGeometry(gridWidth * TILE_SIZE, gridHeight * TILE_SIZE);
            const floor = new THREE.Mesh(floorPlane, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            mazeGroup.add(floor);
            // Make the floor textures repeat exactly once per maze tile
            if (floor.material && floor.material.map) {
                floor.material.map.repeat.set(gridWidth, gridHeight);
                floor.material.map.needsUpdate = true;
            }
            if (floor.material && floor.material.emissiveMap) {
                floor.material.emissiveMap.repeat.set(gridWidth, gridHeight);
                floor.material.emissiveMap.needsUpdate = true;
            }

            const wallGeo = new THREE.PlaneGeometry(TILE_SIZE, WALL_HEIGHT);

            for (let z = 0; z < gridHeight; z++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[z][x] === 1) {
                        const worldPos = gridToWorld(x, z, grid);
                        const isNearGoal = Math.abs(x - goal.x) <= 1 && Math.abs(z - goal.z) <= 1 && !(x === goal.x && z === goal.z);

                        if (z > 0 && grid[z - 1][x] === 0) {
                             const material = isNearGoal && z - 1 === goal.z ? goalWallMaterial : wallMaterialNS;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x, WALL_HEIGHT / 2, worldPos.z - TILE_SIZE / 2);
                             mazeGroup.add(wall);
                        }
                        if (z < gridHeight - 1 && grid[z + 1][x] === 0) {
                             const material = isNearGoal && z + 1 === goal.z ? goalWallMaterial : wallMaterialNS;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x, WALL_HEIGHT / 2, worldPos.z + TILE_SIZE / 2);
                             wall.rotation.y = Math.PI;
                             mazeGroup.add(wall);
                        }
                        if (x > 0 && grid[z][x - 1] === 0) {
                             const material = isNearGoal && x - 1 === goal.x ? goalWallMaterial : wallMaterialEW;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x - TILE_SIZE / 2, WALL_HEIGHT / 2, worldPos.z);
                             wall.rotation.y = Math.PI / 2;
                             mazeGroup.add(wall);
                        }
                        if (x < gridWidth - 1 && grid[z][x + 1] === 0) {
                             const material = isNearGoal && x + 1 === goal.x ? goalWallMaterial : wallMaterialEW;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x + TILE_SIZE / 2, WALL_HEIGHT / 2, worldPos.z);
                             wall.rotation.y = -Math.PI / 2;
                             mazeGroup.add(wall);
                        }
                    }
                }
            }
        }
        
        function createLuckyCat() {
            const catGroup = new THREE.Group();
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.25, metalness: 0.1 });
            const redMat   = new THREE.MeshStandardMaterial({ color: 0xaa2222, roughness: 0.35, metalness: 0.1 });
            const goldMat  = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.1,  metalness: 0.5 });
            const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
            const pinkMat  = new THREE.MeshStandardMaterial({ color: 0xffc0cb, roughness: 0.4 });
            const body = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 16), whiteMat);
            body.scale.y = 0.8;
            catGroup.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(1.2, 32, 16), whiteMat);
            head.position.y = 1.8;
            catGroup.add(head);
            const eyeGeo = new THREE.SphereGeometry(0.1, 12, 8);
            const leftEye  = new THREE.Mesh(eyeGeo, blackMat); leftEye.position.set(-0.4, 0.2, 1.11); head.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, blackMat); rightEye.position.set( 0.4, 0.2, 1.11); head.add(rightEye);
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), blackMat);
            nose.position.set(0, 0, 1.18); nose.scale.set(1.5, 1, 1); head.add(nose);
            const lineMat = new THREE.LineBasicMaterial({ color: 0x111111, linewidth: 2 });
            for (let i = 0; i < 3; i++) {
                const whiskerL = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-0.2, -0.1, 1.15), new THREE.Vector3(-1.2, -i * 0.15, 0.8)
                ]), lineMat);
                const whiskerR = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3( 0.2, -0.1, 1.15), new THREE.Vector3( 1.2, -i * 0.15, 0.8)
                ]), lineMat);
                head.add(whiskerL, whiskerR);
            }
            const earOuterGeo = new THREE.ConeGeometry(0.4, 0.8, 12);
            const earInnerGeo = new THREE.ConeGeometry(0.28, 0.5, 12);
            const leftEar = new THREE.Mesh(earOuterGeo, whiteMat);
            leftEar.position.set(-0.8, 2.8, 0.06); leftEar.rotation.z = Math.PI / 10;
            catGroup.add(leftEar);
            const leftInner = new THREE.Mesh(earInnerGeo, pinkMat);
            leftInner.position.set(0, -0.05, 0.15); leftInner.rotation.x = -Math.PI / 12;
            leftEar.add(leftInner);
            const rightEar = new THREE.Mesh(earOuterGeo, whiteMat);
            rightEar.position.set( 0.8, 2.8, 0.06); rightEar.rotation.z = -Math.PI / 10;
            catGroup.add(rightEar);
            const rightInner = new THREE.Mesh(earInnerGeo, pinkMat);
            rightInner.position.set(0, -0.05, 0.15); rightInner.rotation.x = -Math.PI / 12;
            rightEar.add(rightInner);
            const collar = new THREE.Mesh(new THREE.TorusGeometry(1.3, 0.1, 8, 32), redMat);
            collar.position.y = 1.2; collar.rotation.x = Math.PI / 2; catGroup.add(collar);
            const bell = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 8), goldMat);
            bell.position.set(0, 1.2, 1.3); catGroup.add(bell);
            luckyCatArm = new THREE.Object3D();
            luckyCatArm.position.set(-1.05, 1.1, 0.35);
            catGroup.add(luckyCatArm);
            const armCurvePoints = [
                new THREE.Vector3(0,   0.0, 0.0),
                new THREE.Vector3(0,   0.75, 0.25),
                new THREE.Vector3(0,   1.35, 0.40)
            ];
            const armCurve = new THREE.CatmullRomCurve3(armCurvePoints);
            const arm = new THREE.Mesh(new THREE.TubeGeometry(armCurve, 20, 0.30, 8, false), whiteMat);
            luckyCatArm.add(arm);
            luckyCatWrist = new THREE.Object3D();
            luckyCatWrist.position.copy(armCurvePoints[armCurvePoints.length - 1]);
            luckyCatArm.add(luckyCatWrist);
            const paw = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 12), whiteMat);
            paw.scale.set(1, 0.8, 1);
            paw.position.set(0, 0, 0);
            paw.rotation.y = 0;
            luckyCatWrist.add(paw);
            const mainPad = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 8), pinkMat);
            mainPad.position.set(0, -0.1, 0.30); mainPad.scale.set(1.2, 1, 0.5); paw.add(mainPad);
            for (let i = 0; i < 3; i++) {
                const pad = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), pinkMat);
                pad.position.set(-0.2 + i * 0.2, 0.1, 0.35); pad.scale.z = 0.5; paw.add(pad);
            }
            return catGroup;
        }

        function createGoalMarker(goalCoords) {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            const goalPos = gridToWorld(goalCoords.x, goalCoords.z, level.grid);
            goalMarker = new THREE.Group();
            const cat = createLuckyCat();
            cat.scale.set(1.5, 1.5, 1.5);
            goalMarker.add(cat);
            const heartShape = new THREE.Shape();
            const x = 0, y = 0, s = 0.6;
            heartShape.moveTo( x + 0.5*s, y + 0.5*s );
            heartShape.bezierCurveTo( x + 0.5*s, y + 0.5*s, x + 0.4*s, y + 0.0*s, x + 0.0*s, y + 0.0*s );
            heartShape.bezierCurveTo( x - 0.6*s, y + 0.0*s, x - 0.6*s, y + 0.7*s, x - 0.6*s, y + 0.7*s );
            heartShape.bezierCurveTo( x - 0.6*s, y + 1.1*s, x - 0.3*s, y + 1.54*s, x + 0.5*s, y + 1.9*s );
            heartShape.bezierCurveTo( x + 1.2*s, y + 1.54*s, x + 1.6*s, y + 1.1*s, x + 1.6*s, y + 0.7*s );
            heartShape.bezierCurveTo( x + 1.6*s, y + 0.7*s, x + 1.6*s, y + 0.0*s, x + 1.0*s, y + 0.0*s );
            heartShape.bezierCurveTo( x + 0.7*s, y + 0.0*s, x + 0.5*s, y + 0.5*s, x + 0.5*s, y + 0.5*s );
            const extrudeSettings = { depth: 0.25, bevelEnabled: true, bevelSegments: 2, steps: 1, bevelSize: 0.08, bevelThickness: 0.08 };
            const heartGeo = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            const heartMat = new THREE.MeshBasicMaterial({ color: 0xff4d6d, depthTest: true, depthWrite: true });
            const heart = new THREE.Mesh(heartGeo, heartMat);
            heart.position.set(0, 6.2, 0.2);
            heart.rotation.x = Math.PI;
            heart.scale.set(0.9, 0.9, 0.9);
            // renderOrder removed to respect depth testing so the heart won't show through walls
goalMarker.add(heart);
            floatingHeart = heart;
            floatingHeart.userData.baseY = heart.position.y;
            goalMarker.position.copy(goalPos);
            goalMarker.position.y = WALL_HEIGHT/2 - 1.5;
            scene.add(goalMarker);
        }
        
        function createDirectionalHelpers() {
            while (landmarksGroup.children.length > 0) {
                landmarksGroup.remove(landmarksGroup.children[0]);
            }
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            if (!level) return { forward: false, left: false, right: false };
            const gridPos = worldToGrid(player.position);

            const available = { forward: false, left: false, right: false };

            const arrowShape = new THREE.Shape();
            const w = 0.50;
            const h = 0.72;
            arrowShape.moveTo(0,  h/2);
            arrowShape.lineTo(w/2, 0);
            arrowShape.lineTo(w/4, 0);
            arrowShape.lineTo(w/4, -h/2);
            arrowShape.lineTo(-w/4, -h/2);
            arrowShape.lineTo(-w/4, 0);
            arrowShape.lineTo(-w/2, 0);
            arrowShape.closePath();
            const arrowGeo = new THREE.ShapeGeometry(arrowShape);

            const arrowMat = new THREE.MeshBasicMaterial({
                color: 0xffc107,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
            });
            
            function quantizeYaw(y) {
                return Math.round(y / (Math.PI / 2)) * (Math.PI / 2);
            }
            const baseYaw = quantizeYaw(player.rotation.y);
            
            function stepFromYaw(yaw) {
                const dirVec = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, yaw, 0));
                return { sx: Math.round(dirVec.x), sz: Math.round(dirVec.z) };
            }
            
            function isPath(x, z) {
                return z >= 0 && z < level.grid.length && x >= 0 && x < level.grid[0].length && level.grid[z][x] === 1;
            }
            
            const dirs = [
                {name:'forward', yaw: baseYaw,             pos: new THREE.Vector3( 0.0, 0.0, -4.0), rotZ:  0.0},
                {name:'left',    yaw: baseYaw + Math.PI/2, pos: new THREE.Vector3(-1.6, 0.0, -4.0), rotZ:  Math.PI/2},
                {name:'right',   yaw: baseYaw - Math.PI/2, pos: new THREE.Vector3( 1.6, 0.0, -4.0), rotZ: -Math.PI/2}
            ];
            
            for (const d of dirs) {
                const { sx, sz } = stepFromYaw(d.yaw);
                const nx = gridPos.x + sx;
                const nz = gridPos.z + sz;
                if (isPath(nx, nz)) {
                    available[d.name] = true;
                    const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                    arrow.position.copy(d.pos);
                    arrow.rotation.z = d.rotZ;
                    landmarksGroup.add(arrow);
                    
                    // --- MODIFIED: Red pulsating ARROW-SHAPED halo that wraps the yellow arrow ---
                    {
                        // Build outer and inner arrow shapes to create a thin outline band
                        const scaleOuter = 1.12;
                        const scaleInner = 1.00;

                        const outer = new THREE.Shape();
                        outer.moveTo(0,  (h/2)*scaleOuter);
                        outer.lineTo((w/2)*scaleOuter, 0);
                        outer.lineTo((w/4)*scaleOuter, 0);
                        outer.lineTo((w/4)*scaleOuter, (-h/2)*scaleOuter);
                        outer.lineTo((-w/4)*scaleOuter, (-h/2)*scaleOuter);
                        outer.lineTo((-w/4)*scaleOuter, 0);
                        outer.lineTo((-w/2)*scaleOuter, 0);
                        outer.closePath();

                        const inner = new THREE.Shape();
                        inner.moveTo(0,  (h/2)*scaleInner);
                        inner.lineTo((w/2)*scaleInner, 0);
                        inner.lineTo((w/4)*scaleInner, 0);
                        inner.lineTo((w/4)*scaleInner, (-h/2)*scaleInner);
                        inner.lineTo((-w/4)*scaleInner, (-h/2)*scaleInner);
                        inner.lineTo((-w/4)*scaleInner, 0);
                        inner.lineTo((-w/2)*scaleInner, 0);
                        inner.closePath();

                        outer.holes.push(inner);

                        const haloGeo = new THREE.ShapeGeometry(outer);
                        const glow = new THREE.Mesh(
                            haloGeo,
                            new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                transparent: true,
                                opacity: 0.5, // Initial opacity, will be animated
                                side: THREE.DoubleSide,
                                blending: THREE.AdditiveBlending,
                                fog: false,
                                depthWrite: false,
                                depthTest: false
                            })
                        );
                        // slight offset behind the yellow arrow
                        glow.position.set(0, 0, -0.003);
                        glow.name = 'arrowGlow';
                        glow.userData.phase = Math.random() * Math.PI * 2; // Random phase for desynchronized flashing
                        arrow.add(glow);
                    }
                    // --- END MODIFICATION ---
                }
            }
            return available;
        }
        
        function createSteeringWheel() {
            const wheelGroup = new THREE.Group();
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7, metalness: 0.1 });
            const gloveMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
            const cuffMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.6 });
            const wheel = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.08, 16, 60), wheelMat);
            wheelGroup.add(wheel);
            const createGlove = (hand = 'left') => {
                const gloveGroup = new THREE.Group();
                const palm = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 12), gloveMat);
                palm.scale.set(1, 1.2, 1);
                gloveGroup.add(palm);
                const thumb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 12, 8), gloveMat);
                const thumbX = (hand === 'left') ? +0.15 : -0.15;
                thumb.position.set(thumbX, 0.1, 0);
                gloveGroup.add(thumb);
                const cuff = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 0.2, 16), cuffMat);
                cuff.position.y = -0.15;
                gloveGroup.add(cuff);
                return gloveGroup;
            };
            const leftHand = createGlove('left');
            leftHand.position.set(-0.45, 0.1, 0);
            leftHand.rotation.z = 0.5;
            wheelGroup.add(leftHand);
            const rightHand = createGlove('right');
            rightHand.position.set(0.45, 0.1, 0);
            rightHand.rotation.z = -0.5;
            wheelGroup.add(rightHand);
            wheelGroup.position.set(0, -1.2, -2);
            wheelGroup.rotation.x = -0.5;
            return wheelGroup;
        }
        
        // === Night Sky: Stars ===
        function createStarField(){
    const starCount = 4500;
    const radius = 500;
    const positions = new Float32Array(starCount * 3);
    let i = 0;
    while (i < starCount) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1); // 0..pi
        const y = Math.cos(phi);
        // Only upper hemisphere so stars stay in the "sky"
        if (y < 0.02) continue;
        const r = radius;
        const x = r * Math.sin(phi) * Math.cos(theta);
        const yy = r * y;
        const z = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 0] = x;
        positions[i * 3 + 1] = yy;
        positions[i * 3 + 2] = z;
        i++;
    }
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.PointsMaterial({
        size: 2.0,
        sizeAttenuation: true,
        color: 0xffffff,
        transparent: true,
        opacity: 0.0,
        depthWrite: false,
        depthTest: true,        // stars occluded by walls
        blending: THREE.AdditiveBlending,
        fog: false
    });
    starField = new THREE.Points(geo, mat);
    starField.frustumCulled = false;
    starField.renderOrder = 0;
    scene.add(starField);
}
            function createClassicalLamp() {
            const group = new THREE.Group();
            const postMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.6, metalness: 0.4 });
            const baseGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.2, 8);
            const base = new THREE.Mesh(baseGeo, postMat);
            base.position.y = 0.1;
            group.add(base);
            const postGeo = new THREE.CylinderGeometry(0.15, 0.1, 3.5, 8);
            const post = new THREE.Mesh(postGeo, postMat);
            post.position.y = 1.85;
            group.add(post);
            const holderGeo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const holder = new THREE.Mesh(holderGeo, postMat);
            holder.position.set(0, 3.6, 0.3);
            group.add(holder);
            const lanternGeo = new THREE.SphereGeometry(0.4, 8, 6);
            const lightColors = [0xfffee0, 0xffffff, 0xe0e0ff, 0xffe0e0, 0xffd54f];
            const randomColor = lightColors[Math.floor(Math.random() * lightColors.length)];
            const bulbMat = new THREE.MeshBasicMaterial({ color: randomColor });
            const bulb = new THREE.Mesh(lanternGeo, bulbMat);
            bulb.position.set(0, 3.6, 0.3);
            group.add(bulb);
            const light = new THREE.PointLight(randomColor, 0, TILE_SIZE * 2, 1.5);
            light.name = 'lampLight';
            light.position.copy(bulb.position);
            group.add(light);
            return group;
        }

        function placeRoadsideObjects(grid) {
            const gridHeight = grid.length;
            const gridWidth = grid[0].length;
            for (let z = 0; z < gridHeight; z++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[z][x] === 0) continue;
                    const worldPos = gridToWorld(x, z, grid);
                    if (z > 0 && grid[z - 1][x] === 0) {
                        if (x % 3 === 0) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x, 0, worldPos.z - TILE_SIZE * 0.45);
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (z < gridHeight - 1 && grid[z + 1][x] === 0) {
                       if (x % 3 === 1) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x, 0, worldPos.z + TILE_SIZE * 0.45);
                            lamp.rotation.y = Math.PI;
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (x > 0 && grid[z][x - 1] === 0) {
                        if (z % 3 === 0) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x - TILE_SIZE * 0.45, 0, worldPos.z);
                            lamp.rotation.y = Math.PI / 2;
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (x < gridWidth - 1 && grid[z][x + 1] === 0) {
                        if (z % 3 === 1) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x + TILE_SIZE * 0.45, 0, worldPos.z);
                            lamp.rotation.y = -Math.PI / 2;
                            sceneryGroup.add(lamp);
                        }
                    }
                }
            }
        }

        
// === Procedural floor textures: reddish-brown metal tiles + incandescent strips between tiles ===
function __makeTileTextures(size = 512, stripe = 6) {
    const cvs = document.createElement('canvas');
    cvs.width = cvs.height = size;
    const ctx = cvs.getContext('2d');

    // base: reddish-brown metal with a subtle radial gradient
    const grad = ctx.createRadialGradient(size*0.5, size*0.5, size*0.15, size*0.5, size*0.5, size*0.7);
    grad.addColorStop(0, '#7a2b24');  // 中心较亮
    grad.addColorStop(1, '#5a1e1a');  // 外圈较暗
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);

    // faint brushed lines (simulate metallic sheen)
    ctx.globalAlpha = 0.08;
    for (let y = 0; y < size; y += 4) {
        ctx.fillStyle = (y % 8 === 0) ? '#ffffff' : '#000000';
        ctx.fillRect(0, y, size, 1);
    }
    ctx.globalAlpha = 1;

    // border "incandescent light strip" around the tile
    const glowColor = '#ffff00'; // 淡黄色灯带
    ctx.fillStyle = glowColor;
    ctx.fillRect(0, 0, size, stripe);                    // top
    ctx.fillRect(0, size - stripe, size, stripe);        // bottom
    ctx.fillRect(0, 0, stripe, size);                    // left
    ctx.fillRect(size - stripe, 0, stripe, size);        // right

    const baseTex = new THREE.CanvasTexture(cvs);
    baseTex.wrapS = baseTex.wrapT = THREE.RepeatWrapping;
    baseTex.magFilter = THREE.LinearFilter;
    baseTex.minFilter = THREE.LinearMipMapLinearFilter;

    // emissive map: glow only on borders
    const cvsE = document.createElement('canvas');
    cvsE.width = cvsE.height = size;
    const ctxE = cvsE.getContext('2d');
    ctxE.fillStyle = '#000';
    ctxE.fillRect(0, 0, size, size);
    ctxE.fillStyle = '#ffffff';
    ctxE.fillRect(0, 0, size, stripe);
    ctxE.fillRect(0, size - stripe, size, stripe);
    ctxE.fillRect(0, 0, stripe, size);
    ctxE.fillRect(size - stripe, 0, stripe, size);
    const emisTex = new THREE.CanvasTexture(cvsE);
    emisTex.wrapS = emisTex.wrapT = THREE.RepeatWrapping;
    emisTex.magFilter = THREE.LinearFilter;
    emisTex.minFilter = THREE.LinearMipMapLinearFilter;

    return { baseTex: baseTex, emisTex: emisTex };
}

function createMaterials() {
            const textureLoader = new THREE.TextureLoader();

// === Sky fallback: programmatic gradient + star field as equirectangular texture ===
function __makeSkyFallback(size = 2048, stars = 1200) {
    const c = document.createElement('canvas');
    c.width = size; c.height = size/2; // equirectangular ratio 2:1
    const g = c.getContext('2d');

    // gradient from deep blue to purple-black
    const grad = g.createLinearGradient(0, 0, 0, c.height);
    grad.addColorStop(0, '#3a6fd8');  // top blue
    grad.addColorStop(0.6, '#1b2a4a');
    grad.addColorStop(1, '#130a1f');  // bottom purple-black
    g.fillStyle = grad;
    g.fillRect(0, 0, c.width, c.height);

    // star field (brighter near top)
    for (let i=0;i<stars;i++) {
        const x = Math.random() * c.width;
        const y = Math.random() * c.height * (0.85 + 0.15*Math.random());
        const r = Math.random() * 1.6 + 0.2;
        const a = 0.55 + Math.random()*0.45;
        g.fillStyle = `rgba(255,255,255,${a})`;
        g.beginPath();
        g.arc(x, y, r, 0, Math.PI*2);
        g.fill();
    }

    const tex = new THREE.CanvasTexture(c);
    tex.mapping = THREE.EquirectangularReflectionMapping;
    tex.needsUpdate = true;
    return tex;
}

            wallMaterialNS = new THREE.MeshStandardMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--wall-color-ns').trim()),
                roughness: 0.8,
                metalness: 0.2
            });
            wallMaterialEW = new THREE.MeshStandardMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--wall-color-ew').trim()),
                roughness: 0.8,
                metalness: 0.2
            });
            const floorTexture = textureLoader.load('https://threejs.org/examples/textures/checker.png');
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.magFilter = THREE.NearestFilter;
            floorTexture.minFilter = THREE.NearestFilter;
            const repeatsPerMazeTile = 2;
            const largestMazeDim = 25;
            floorTexture.repeat.set(largestMazeDim * repeatsPerMazeTile, largestMazeDim * repeatsPerMazeTile);
            const __tileTex = __makeTileTextures();
floorMaterial = new THREE.MeshStandardMaterial({
  map: __tileTex.baseTex,
  metalness: 0.8,
  roughness: 0.25,
  emissive: 0xffffff,
  emissiveMap: __tileTex.emisTex,
  emissiveIntensity: 2.0
});
            landmarkMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--landmark-color').trim()),
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            goalWallMaterial = new THREE.MeshStandardMaterial({ color: 0xff6666, roughness: 0.6, metalness: 0.2, emissive: 0x330000, emissiveIntensity: 0.25 });
        }

        // ====================================================================
        // 小地图 (Minimap)
        // ====================================================================

        let lastPlayerGridPos = { x: -1, z: -1 };

        function drawMinimapBackground(grid, start, goal) {
            const canvas = minimap;
            canvas.width = 500;
            canvas.height = 500;
            const ctx = minimapCtx;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cellWidth = canvas.width / grid[0].length;
            const cellHeight = canvas.height / grid.length;
            for (let z = 0; z < grid.length; z++) {
                for (let x = 0; x < grid[0].length; x++) {
                    const xPos = x * cellWidth;
                    const yPos = z * cellHeight;
                    if (grid[z][x] === 0) {
                        const wallGradient = ctx.createLinearGradient(xPos, yPos, xPos + cellWidth, yPos + cellHeight);
                        wallGradient.addColorStop(0, "#555");
                        wallGradient.addColorStop(0.5, "#222");
                        wallGradient.addColorStop(1, "#555");
                        ctx.fillStyle = wallGradient;
                    } else {
                        const pathGradient = ctx.createLinearGradient(xPos, yPos, xPos + cellWidth, yPos + cellHeight);
                        pathGradient.addColorStop(0, "#eee");
                        pathGradient.addColorStop(0.5, "#fff");
                        pathGradient.addColorStop(1, "#eee");
                        ctx.fillStyle = pathGradient;
                    }
                    ctx.fillRect(xPos, yPos, cellWidth, cellHeight);
                }
            }
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--start-color');
            ctx.fillRect(start.x * cellWidth, start.z * cellHeight, cellWidth, cellHeight);
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--goal-color');
            ctx.fillRect(goal.x * cellWidth, goal.z * cellHeight, cellWidth, cellHeight);
        }

        function updateMinimapPlayer() {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            if (!level) return;
            const { grid, start, goal } = level;
            const gridPos = worldToGrid(player.position);
            lastPlayerGridPos = { ...gridPos };
            drawMinimapBackground(grid, start, goal);
            const ctx = minimapCtx;
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;
            const cellWidth = ctx.canvas.width / gridWidth;
            const cellHeight = ctx.canvas.height / gridHeight;
            const playerX = (gridPos.x + 0.5) * cellWidth;
            const playerZ = (gridPos.z + 0.5) * cellHeight;
            ctx.save();
            const dirVec = new THREE.Vector3(0, 0, -1).applyEuler(player.rotation);
            const angle = Math.atan2(dirVec.z, dirVec.x);
            ctx.translate(playerX, playerZ);
            ctx.rotate(angle);
            const size = Math.min(cellWidth, cellHeight) * 1.2; 
            const half = size * 0.5;
            const tail = -half * 0.8; 
            ctx.beginPath();
            ctx.moveTo(half, 0);
            ctx.lineTo(tail, -half * 0.6); 
            ctx.lineTo(tail,  half * 0.6); 
            ctx.closePath();
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, half);
            gradient.addColorStop(0, '#ff8080');
            gradient.addColorStop(1, '#c00000');
            ctx.fillStyle = gradient;
            ctx.shadowColor = 'rgba(255, 0, 0, 0.9)';
            ctx.shadowBlur = size * 0.7;
            ctx.fill();
            ctx.lineWidth = Math.max(2, size * 0.1); 
            ctx.strokeStyle = '#006400';
            ctx.stroke();
            ctx.restore();
        }

        // ====================================================================
        // 寻路算法 (Pathfinding - BFS)
        // ====================================================================

        function getNeighbors(x, z, grid) {
            const neighbors = [];
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dx, dz] of dirs) {
                const newX = x + dx;
                const newZ = z + dz;
                if (newZ >= 0 && newZ < grid.length && newX >= 0 && newX < grid[0].length && grid[newZ][newX] === 1) {
                    neighbors.push({ x: newX, z: newZ });
                }
            }
            return neighbors;
        }

        function findShortestPath(level) {
            const { grid, start, goal } = level;
            if (!start.hasOwnProperty('x') || !goal.hasOwnProperty('x')) return null;
            const queue = [{ x: start.x, z: start.z, path: [] }];
            const visited = new Set([`${start.x},${start.z}`]);
            while (queue.length > 0) {
                const { x, z, path } = queue.shift();
                if (x === goal.x && z === goal.z) {
                    return { path, choices: path.length };
                }
                const neighbors = getNeighbors(x, z, grid);
                for (const neighbor of neighbors) {
                    const key = `${neighbor.x},${neighbor.z}`;
                    if (!visited.has(key)) {
                        visited.add(key);
                        const newPath = path.concat([{x, z}]);
                        queue.push({ ...neighbor, path: newPath });
                    }
                }
            }
            return null;
        }
        
        // ====================================================================
        // 菜单与UI逻辑 (Menu & UI Logic)
        // ====================================================================
        
        function showIngameHint(messageKey = 'hint_ingame_controls') {
            const hintEl = document.getElementById('ingame-hint');
            hintEl.textContent = translations[currentLanguage][messageKey];
            hintEl.style.display = 'block';
            hintEl.style.opacity = 1;

            clearTimeout(hintTimeout);
            hintTimeout = setTimeout(() => {
                hintEl.style.opacity = 0;
                setTimeout(() => {
                    hintEl.style.display = 'none';
                }, 500); // Match CSS transition duration
            }, 8000); // MODIFIED: Show hint for 8 seconds
        }

        function updateHUD() {
            const mapViewCountEl = document.getElementById('map-view-count');
            if (navigationMode === 'limited') {
                mapViewCountEl.style.display = 'block';
                mapViewCountEl.textContent = `${translations[currentLanguage].mapChances}: ${mapViewChances}`;
            } else {
                mapViewCountEl.style.display = 'none';
            }
        }
        
        function updateUIText() {
            document.querySelectorAll('[data-lang-zh]').forEach(el => {
                const key = currentLanguage === 'zh' ? 'langZh' : 'langEn';
                if (el.dataset[key]) {
                    el.textContent = el.dataset[key];
                }
            });
             document.querySelectorAll('select').forEach(select => {
                select.querySelectorAll('option').forEach(option => {
                    const key = currentLanguage === 'zh' ? 'langZh' : 'langEn';
                    if (option.dataset[key]) {
                        option.textContent = option.dataset[key];
                    }
                });
            });
            document.querySelectorAll('[data-lang-placeholder-zh]').forEach(el => {
                const key = currentLanguage === 'zh' ? 'langPlaceholderZh' : 'langPlaceholderEn';
                 if (el.dataset[key]) {
                    el.placeholder = el.dataset[key];
                }
            });
            
            const welcomeMsg = document.getElementById('welcome-message');
            if (welcomeMsg) {
                welcomeMsg.textContent = translations[currentLanguage].welcome(playerInfo.nickname);
            }
            if (gameState === 'AT_INTERSECTION') {
                checkForTurns();
            }
            // 保留玩家当前关卡选择，不要在此处重建开发者面板以避免重置为第一关。

            const ingameHint = document.getElementById('ingame-hint');
            if (ingameHint.style.display !== 'none') {
                // When language changes, the hint might be visible, so update it.
                // It will default to the controls hint if no specific one is active.
                showIngameHint();
            }
            updateHUD();
        }

        function togglePauseMenu() {
            const menu = document.getElementById('pause-menu-modal');
            const isPaused = menu.style.display === 'flex';

            if (isPaused) {
                menu.style.display = 'none';
                gameState = previousGameState;
            } else {
                if(!['AT_INTERSECTION', 'DRIVING', 'TURNING', 'BIG_MAP'].includes(gameState)) return;
                previousGameState = gameState;
                gameState = 'PAUSED';
                menu.style.display = 'flex';
            }
        }
        
        function toggleChallengeMap() {
            const container = document.getElementById('minimap-container');
            const isMapViewVisible = container.style.display === 'block' && gameState === 'CHALLENGE_MAP_VIEW';

            if (isMapViewVisible) {
                container.style.display = 'none';
                gameState = previousGameState;
            } else if (['AT_INTERSECTION', 'DRIVING', 'TURNING'].includes(gameState) && mapViewChances > 0) {
                mapViewChances--;
                updateHUD();
                previousGameState = gameState;
                gameState = 'CHALLENGE_MAP_VIEW';
                container.classList.remove('small-map');
                container.classList.add('big-map');
                container.style.display = 'block';
}
        }

        function showLevelSelectModal() {
            const grid = document.getElementById('level-select-grid');
            grid.innerHTML = '';
            const levelCount = (gameMode === 'custom') ? customLevels.filter(l=>l).length : levels.length;
            for (let i = 0; i < levelCount; i++) {
                const button = document.createElement('button');
                button.textContent = i + 1;
                const isUnlocked = gameMode !== 'campaign' || i <= unlockedLevel;
                button.disabled = !isUnlocked;
                if (isUnlocked) {
                    button.onclick = () => {
                        document.getElementById('level-select-modal').style.display = 'none';
                        togglePauseMenu();
                        loadLevel(gameMode === 'custom' ? customLevels[i] : i);
                    };
                }
                grid.appendChild(button);
            }
            document.getElementById('pause-menu-modal').style.display = 'none';
            document.getElementById('level-select-modal').style.display = 'flex';
        }

        function resetGame() {
            unlockedLevel = 0;
            playerInfo = { nickname: 'Driver', gender: 'other' };
            document.getElementById('nickname-input').value = '';
            const modals = document.querySelectorAll('.modal-overlay');
            modals.forEach(modal => {
                if (modal.id !== 'startup-modal') {
                    modal.style.display = 'none';
                }
            });
            document.getElementById('startup-modal').style.display = 'flex';
            gameState = 'STARTUP_MODAL';
            updateUIText();
        }
        
        // ====================================================================
        // 地图编辑器 (Map Editor) & Custom Maps
        // ====================================================================
        
        let editorGridData = [];
        let editorStart = {};
        let editorGoal = {};
        let currentTool = 'wall';
        let isDrawing = false;
        let selectedCustomMapIndex = 0;
        const EDITOR_SIZE = 17;
        const MAX_CUSTOM_LEVELS = 15;

        function loadCustomLevels() {
            const savedLevels = localStorage.getItem('customMazeLevels');
            if (savedLevels) {
                customLevels = JSON.parse(savedLevels);
            } else {
                customLevels = new Array(MAX_CUSTOM_LEVELS).fill(null);
            }
        }

        function saveCustomLevels() {
            localStorage.setItem('customMazeLevels', JSON.stringify(customLevels));
        }

        function showEditor(slotIndex = 0) {
            document.getElementById('main-menu-modal').style.display = 'none';
            document.getElementById('custom-maps-modal').style.display = 'none';
            document.getElementById('editor-modal').style.display = 'flex';
            initEditor(slotIndex);
        }

        function initEditor(slotIndex) {
            const grid = document.getElementById('editor-grid');
            const slotSelect = document.getElementById('editor-slot-select');
            grid.innerHTML = '';
            slotSelect.innerHTML = '';
            for (let i = 0; i < MAX_CUSTOM_LEVELS; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${translations[currentLanguage].map_slot} ${i + 1}` + (customLevels[i] ? '' : ` (${translations[currentLanguage].empty_slot})`);
                slotSelect.appendChild(option);
            }
            slotSelect.value = slotIndex;
            slotSelect.onchange = () => {
                initEditor(parseInt(slotSelect.value));
            };
            loadEditorGrid(slotIndex);
            grid.onmousedown = (e) => {
                isDrawing = true;
                handleGridInteraction(e);
            };
            grid.onmouseover = handleGridInteraction;
            document.onmouseup = () => isDrawing = false;
            grid.onmouseleave = () => isDrawing = false;
            document.getElementById('editor-toolbar').onclick = (e) => {
                if (e.target.tagName === 'BUTTON') {
                    currentTool = e.target.dataset.tool;
                    document.querySelectorAll('#editor-toolbar button').forEach(b => b.classList.remove('selected'));
                    e.target.classList.add('selected');
                }
            };
            document.getElementById('tool-wall').classList.add('selected');
            document.getElementById('editor-save-btn').onclick = saveCustomMap;
            document.getElementById('editor-delete-btn').onclick = deleteCustomMap;
            document.getElementById('editor-back-btn').onclick = () => {
                 document.getElementById('editor-modal').style.display = 'none';
                 showMainMenu();
            };
        }
        
        function loadEditorGrid(slotIndex) {
            const grid = document.getElementById('editor-grid');
            grid.innerHTML = '';
            editorGridData = [];
            editorStart = {};
            editorGoal = {};
            const levelToLoad = customLevels[slotIndex];
            for (let z = 0; z < EDITOR_SIZE; z++) {
                const row = [];
                for (let x = 0; x < EDITOR_SIZE; x++) {
                    let cellType = 0;
                    if (levelToLoad) {
                        cellType = levelToLoad.grid[z][x] === 0 ? 1 : 0;
                        if (levelToLoad.start.x === x && levelToLoad.start.z === z) editorStart = {x, z};
                        if (levelToLoad.goal.x === x && levelToLoad.goal.z === z) editorGoal = {x, z};
                    } else {
                        const isBorder = x === 0 || x === EDITOR_SIZE - 1 || z === 0 || z === EDITOR_SIZE - 1;
                        if (isBorder) cellType = 1;
                    }
                    row.push(cellType);
                    const cell = document.createElement('div');
                    cell.classList.add('editor-cell');
                    cell.dataset.x = x;
                    cell.dataset.z = z;
                    if(editorStart.x === x && editorStart.z === z) cell.classList.add('start');
                    else if(editorGoal.x === x && editorGoal.z === z) cell.classList.add('goal');
                    else cell.classList.toggle('wall', cellType === 1);
                    grid.appendChild(cell);
                }
                editorGridData.push(row);
            }
        }
        
        function handleGridInteraction(e) {
            if (!isDrawing || e.buttons !== 1) return;
            const cell = e.target;
            if (!cell.classList.contains('editor-cell')) return;
            const x = parseInt(cell.dataset.x);
            const z = parseInt(cell.dataset.z);
            const grid = document.getElementById('editor-grid');
            if (editorStart.x === x && editorStart.z === z) editorStart = {};
            if (editorGoal.x === x && editorGoal.z === z) editorGoal = {};
            if (currentTool === 'start' && editorStart.x !== undefined) {
                 grid.children[editorStart.z * EDITOR_SIZE + editorStart.x].className = 'editor-cell path';
                 editorGridData[editorStart.z][editorStart.x] = 0;
            }
            if (currentTool === 'goal' && editorGoal.x !== undefined) {
                 grid.children[editorGoal.z * EDITOR_SIZE + editorGoal.x].className = 'editor-cell path';
                 editorGridData[editorGoal.z][editorGoal.x] = 0;
            }
            switch (currentTool) {
                case 'wall':
                    editorGridData[z][x] = 1;
                    cell.className = 'editor-cell wall';
                    break;
                case 'path':
                    editorGridData[z][x] = 0;
                    cell.className = 'editor-cell path';
                    break;
                case 'start':
                    editorGridData[z][x] = 0;
                    editorStart = { x, z };
                    cell.className = 'editor-cell start';
                    isDrawing = false;
                    break;
                case 'goal':
                    editorGridData[z][x] = 0;
                    editorGoal = { x, z };
                    cell.className = 'editor-cell goal';
                    isDrawing = false;
                    break;
            }
        }
        
        function saveCustomMap() {
            const messageEl = document.getElementById('editor-message');
            messageEl.textContent = '';
            const slotIndex = parseInt(document.getElementById('editor-slot-select').value);
            if (!editorStart.hasOwnProperty('x')) {
                messageEl.textContent = translations[currentLanguage].editor_need_start;
                return;
            }
            if (!editorGoal.hasOwnProperty('x')) {
                messageEl.textContent = translations[currentLanguage].editor_need_goal;
                return;
            }
            const mazeDataForSolver = editorGridData.map(row => row.map(cell => cell === 1 ? 0 : 1));
            const tempLevel = { grid: mazeDataForSolver, start: editorStart, goal: editorGoal };
            if (!findShortestPath(tempLevel)) {
                messageEl.textContent = translations[currentLanguage].editor_unsolvable;
                return;
            }
            const newLevel = {
                grid: mazeDataForSolver,
                start: { ...editorStart, dir: 'S' },
                goal: { ...editorGoal }
            };
            if (newLevel.start.x === 0) newLevel.start.dir = 'E';
            else if (newLevel.start.x === EDITOR_SIZE - 1) newLevel.start.dir = 'W';
            else if (newLevel.start.z === 0) newLevel.start.dir = 'S';
            else if (newLevel.start.z === EDITOR_SIZE - 1) newLevel.start.dir = 'N';
            customLevels[slotIndex] = newLevel;
            saveCustomLevels();
            const option = document.getElementById('editor-slot-select').options[slotIndex];
            option.textContent = `${translations[currentLanguage].map_slot} ${slotIndex + 1}`;
            messageEl.textContent = `${translations[currentLanguage].map_slot} ${slotIndex + 1} 已保存!`;
            messageEl.style.color = 'green';
            setTimeout(() => {
                messageEl.textContent = '';
                messageEl.style.color = 'red';
            }, 2000);
        }
        
        function deleteCustomMap() {
            const slotIndex = parseInt(document.getElementById('editor-slot-select').value);
            if (customLevels[slotIndex] && confirm(translations[currentLanguage].confirm_delete)) {
                customLevels[slotIndex] = null;
                saveCustomLevels();
                initEditor(slotIndex);
            }
        }
        
        function showCustomMapsModal() {
            document.getElementById('main-menu-modal').style.display = 'none';
            document.getElementById('custom-maps-modal').style.display = 'flex';
            const grid = document.getElementById('custom-maps-grid');
            grid.innerHTML = '';
            selectedCustomMapIndex = -1;
            document.getElementById('custom-play-btn').disabled = true;
            document.getElementById('custom-edit-btn').disabled = true;
            document.getElementById('custom-delete-btn').disabled = true;
            for (let i = 0; i < MAX_CUSTOM_LEVELS; i++) {
                const button = document.createElement('button');
                button.dataset.index = i;
                if (customLevels[i]) {
                    button.textContent = `${translations[currentLanguage].map_slot} ${i + 1}`;
                } else {
                    button.textContent = `${i + 1} (${translations[currentLanguage].empty_slot})`;
                    button.disabled = true;
                }
                grid.appendChild(button);
            }
            grid.onclick = (e) => {
                if (e.target.tagName === 'BUTTON' && !e.target.disabled) {
                    document.querySelectorAll('#custom-maps-grid button').forEach(b => b.classList.remove('selected'));
                    e.target.classList.add('selected');
                    selectedCustomMapIndex = parseInt(e.target.dataset.index);
                    document.getElementById('custom-play-btn').disabled = false;
                    document.getElementById('custom-edit-btn').disabled = false;
                    document.getElementById('custom-delete-btn').disabled = false;
                }
            };
            document.getElementById('custom-play-btn').onclick = () => {
                if(selectedCustomMapIndex !== -1) {
                    document.getElementById('custom-maps-modal').style.display = 'none';
                    document.getElementById('mode-select-modal').style.display = 'flex';
                }
            };
            document.getElementById('custom-edit-btn').onclick = () => {
                if(selectedCustomMapIndex !== -1) showEditor(selectedCustomMapIndex);
            };
            document.getElementById('custom-delete-btn').onclick = () => {
                if(selectedCustomMapIndex !== -1 && confirm(translations[currentLanguage].confirm_delete)) {
                    customLevels[selectedCustomMapIndex] = null;
                    saveCustomLevels();
                    showCustomMapsModal();
                }
            };
            document.getElementById('custom-back-btn').onclick = () => {
                document.getElementById('custom-maps-modal').style.display = 'none';
                showMainMenu();
            };
        }
        
        // ====================================================================
        // 启动 (Boot)
        // ====================================================================
        init();

    </script>
    <script>
    (function(){
      var overlay = document.getElementById('intro-overlay');
      var video   = document.getElementById('intro-video');
      var skip    = document.getElementById('skip-intro-btn');
      var startup = document.getElementById('startup-modal');
      function ensureStartVisible() {
        if (startup && startup.style.display === 'none') {
          startup.style.display = 'flex';
        }
      }
      function endIntro(){
        if (!overlay) return;
        overlay.classList.add('hidden');
        setTimeout(function(){ overlay.remove(); ensureStartVisible(); }, 520);
      }
      if (skip) skip.addEventListener('click', endIntro);
      if (video){
        video.addEventListener('ended', endIntro);
        video.addEventListener('error', endIntro);
        var p = video.play && video.play();
        if (p && typeof p.then === 'function'){
          p.catch(function(){ video.controls = true; });
        }
      }
      if (overlay){
        overlay.addEventListener('click', function once(){
          if (video){
            try{ video.muted = false; video.volume = 0.6; } catch(e){}
          }
          overlay.removeEventListener('click', once);
        });
      }
    })();
    </script>
</body>
</html>
