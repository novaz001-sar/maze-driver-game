<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第一人称迷宫驾驶 First-Person Maze Driver</title>
    <!--
    ============================================================================
    ## README：第一人称迷宫驾驶 (First-Person Maze Driver) - v7.0 动画微调版 ##
    ============================================================================

    这是一款面向中老年用户的、极简交互的第一人称3D迷宫驾驶游戏。
    v7.0 版本根据用户反馈，微调了终点招财猫模型的动画效果。

    ### v7.0 更新内容 (What's New in v7.0)
    1.  **微调招财猫动画 (Adjusted Lucky Cat Animation)**:
        * 将招财猫手臂向前挥动的最大幅度从90度调整为60度，使其摇摆动作更加自然、含蓄，并确保动作完全在身体前方。
    2.  **保留所有核心功能**:
        * 保留了修复后的HUD箭头逻辑、方向盘、手部模型等所有沉浸式视觉元素。
        * 保留了所有游戏模式（通关、自由、自定义、编辑器）和导航模式（小地图/自主导航）。

    ### 玩法说明 (How to Play)
    1.  **路口决策 (Intersection)**:
        * 在迷宫的任何一格，车辆都会停下。此时可以观察前方浮动的箭头来决定方向。
    2.  **选择方向或前进**:
        * 按下 `D` 键，车辆会**平滑地向右转90度**。
        * 按下 `A` 键，车辆会**平滑地向左转90度**。
        * 按下 `空格 (Space)` 键，车辆会沿当前方向**前进一格**。
    
    ### 键位 (Controls)
    * `A`: 向左转90度 (Turn Left)。
    * `D`: 向右转90度 (Turn Right)。
    * `空格 (Space)`: 前进一格 (Move Forward)。
    * `E`: (仅自主导航模式) 打开/关闭大地图 (Toggle Full Map in Autonomous Navigation Mode)。
    * `ESC`: 呼出/关闭菜单 (Toggle Menu)。
    * `鼠标左键`: 点击UI元素 (Click UI Elements)。

    ============================================================================
    -->
    <style>
        :root {
            --bg-color: #f0f8ff; /* AliceBlue - a very light blue sky */
            --text-color: #333333; /* Dark Grey for text */
            --primary-color: #007bff; /* Bright Blue */
            --highlight-color: #28a745; /* Green */
            --danger-color: #dc3545; /* Red */
            --wall-color-ns: #f5deb3; /* Wheat - for North-South walls */
            --wall-color-ew: #faf0e6; /* Linen - slightly lighter for East-West walls */
            --floor-color: #E0E0E0; /* Fallback color, not really used with texture */
            --landmark-color: #ffc107; /* Amber */
            --start-color: #007bff;
            --goal-color: #dc3545; /* Red */
            --font-size-normal: 18px;
            --font-size-large: 22px;
            --font-size-xlarge: 28px;
            --minimap-scale: 1; /* 小地图缩放比例 */
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: var(--font-size-normal);
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        .hud {
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        #top-hud {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
        }

        #map-view-count {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: var(--font-size-normal);
            font-weight: bold;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: none; /* Hidden by default */
        }

        #bottom-hud {
            text-align: center;
            padding-bottom: 40px;
        }

        #choice-prompt {
            background-color: rgba(255, 255, 255, 0.8);
            color: var(--text-color);
            padding: 15px 25px;
            border-radius: 15px;
            border: 2px solid var(--primary-color);
            font-size: var(--font-size-large);
            font-weight: bold;
            display: none; /* Initially hidden */
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        #minimap-container {
            position: fixed;
            background-color: rgba(255, 255, 255, 0.8);
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            transition: all 0.5s ease-in-out;
            z-index: 10;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.5);
        }

        #minimap-container.big-map {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80vmin;
            height: 80vmin;
            cursor: pointer;
        }

        #minimap-container.small-map {
            top: 20px;
            right: 20px;
            width: calc(25vmin * var(--minimap-scale));
            height: calc(25vmin * var(--minimap-scale));
            max-width: calc(250px * var(--minimap-scale));
            max-height: calc(250px * var(--minimap-scale));
            cursor: default;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        /* Modals and Menus */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background-color: white;
            color: var(--text-color);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid var(--primary-color);
            text-align: center;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 0 25px rgba(0, 123, 255, 0.5);
        }
        
        #editor-modal .modal-content, #custom-maps-modal .modal-content {
            max-width: 95vmin;
        }

        .modal-content h2 {
            font-size: var(--font-size-xlarge);
            margin-top: 0;
            margin-bottom: 30px;
            color: var(--primary-color);
        }
        
        .modal-content p {
            font-size: var(--font-size-normal);
            margin-bottom: 20px;
        }

        .modal-content input, .modal-content select {
            width: 80%;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 10px;
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            color: var(--text-color);
            font-size: var(--font-size-normal);
            min-height: 44px;
        }

        .modal-content button {
            padding: 15px 0;
            border-radius: 10px;
            border: none;
            background-color: var(--primary-color);
            color: white;
            font-size: var(--font-size-large);
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 80%;
            max-width: 300px;
            min-height: 50px;
            margin: 10px auto;
            display: block;
        }
        
        .modal-content .button-row {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .modal-content .button-row button {
            width: 45%;
            max-width: 150px;
        }

        .modal-content button.danger {
            background-color: var(--danger-color);
        }
        .modal-content button.secondary {
            background-color: #6c757d;
        }

        .modal-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.4);
        }
        .modal-content button.danger:hover {
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
        }
        .modal-content button.secondary:hover {
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.4);
        }
        
        .modal-content button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        #results-medal {
            font-size: 80px;
            margin: 20px 0;
        }
        
        #results-title {
            color: var(--highlight-color);
        }

        #dev-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 20;
            pointer-events: auto;
            display: none;
        }
        #dev-panel h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        #dev-panel select {
            min-height: 44px;
        }

        #settings-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.1);
            border: none;
            color: var(--text-color);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #settings-panel {
            display: none;
        }

        .settings-group {
            text-align: left;
            margin-bottom: 20px;
        }
        .settings-group label {
            display: block;
            margin-bottom: 10px;
        }
        .settings-group select, .settings-group input[type="range"] {
            width: 100%;
        }

        #level-select-grid, #custom-maps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
            max-height: 50vh;
            overflow-y: auto;
        }

        #level-select-grid button, #custom-maps-grid button {
            min-width: 60px;
            width: 100%;
            padding: 10px;
        }

        #level-select-grid button:disabled, #custom-maps-grid button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        #custom-maps-grid button.selected {
            border: 3px solid var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }

        /* Editor Styles */
        #editor-toolbar {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        #editor-toolbar button, #editor-toolbar select {
            width: auto;
            min-width: 80px;
            padding: 10px 15px;
            font-size: var(--font-size-normal);
            min-height: 44px;
            margin: 5px;
        }
        #editor-toolbar button.selected {
            background-color: var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }
        #editor-grid {
            display: grid;
            grid-template-columns: repeat(17, 1fr);
            grid-template-rows: repeat(17, 1fr);
            width: 80vmin;
            height: 80vmin;
            max-width: 450px;
            max-height: 450px;
            margin: 0 auto 20px;
            border: 2px solid var(--primary-color);
            background-color: #e9ecef;
        }
        .editor-cell {
            border: 1px solid #dee2e6;
            transition: background-color: 0.1s;
        }
        .editor-cell:hover {
            background-color: #ced4da;
        }
        .editor-cell.wall { background-color: #343a40; }
        .editor-cell.path { background-color: #f8f9fa; }
        .editor-cell.start { background-color: var(--start-color); }
        .editor-cell.goal { background-color: var(--goal-color); }
        
        .lang-en { display: none; }

    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-container">
        <div id="top-hud" class="hud">
             <div id="map-view-count"></div>
        </div>
        <div id="bottom-hud" class="hud">
            <div id="choice-prompt"></div>
        </div>
    </div>

    <div id="minimap-container">
        <canvas id="minimap-canvas"></canvas>
    </div>
    
    <button id="settings-button">⚙️</button>

    <div id="startup-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 data-lang-zh="欢迎来到迷宫驾驶" data-lang-en="Welcome to Maze Driver">欢迎来到迷宫驾驶</h2>
            <div class="settings-group">
                <label for="initial-language-select" data-lang-zh="语言 / Language" data-lang-en="语言 / Language">语言 / Language</label>
                <select id="initial-language-select">
                    <option value="zh">中文</option>
                    <option value="en">English</option>
                </select>
            </div>
            <p data-lang-zh="为了更好地称呼您，请输入您的信息：" data-lang-en="To get started, please enter your info:">为了更好地称呼您，请输入您的信息：</p>
            <input type="text" id="nickname-input" data-lang-placeholder-zh="请输入您的昵称" data-lang-placeholder-en="Enter your nickname">
            <select id="gender-select">
                <option value="male" data-lang-zh="男" data-lang-en="Male">男</option>
                <option value="female" data-lang-zh="女" data-lang-en="Female">女</option>
                <option value="other" data-lang-zh="其他" data-lang-en="Other">其他</option>
            </select>
            <button id="start-game-btn" data-lang-zh="开始游戏" data-lang-en="Start Game">开始游戏</button>
        </div>
    </div>

    <div id="main-menu-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="welcome-message"></h2>
            <button id="campaign-mode-btn" data-lang-zh="通关模式" data-lang-en="Campaign Mode">通关模式</button>
            <button id="free-mode-btn" data-lang-zh="自由模式" data-lang-en="Free Mode">自由模式</button>
            <button id="custom-mode-btn" data-lang-zh="自定义模式" data-lang-en="Custom Mode" disabled>自定义模式</button>
            <button id="editor-mode-btn" data-lang-zh="地图编辑器" data-lang-en="Map Editor">地图编辑器</button>
        </div>
    </div>
    
    <div id="level-complete-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="results-title"></h2>
            <div id="results-medal"></div>
            <p id="results-stats"></p>
            <p id="results-quote"></p>
            <button id="next-level-btn" data-lang-zh="下一关" data-lang-en="Next Level">下一关</button>
            <button id="main-menu-btn" data-lang-zh="返回主菜单" data-lang-en="Main Menu">返回主菜单</button>
        </div>
    </div>

    <div id="settings-panel" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="设置" data-lang-en="Settings">设置</h2>
            <div class="settings-group">
                <label for="language-select" data-lang-zh="语言" data-lang-en="Language">语言</label>
                <select id="language-select">
                    <option value="zh">中文</option>
                    <option value="en">English</option>
                </select>
            </div>
            <div class="settings-group">
                <label for="font-size-slider" data-lang-zh="字体大小" data-lang-en="Font Size">字体大小</label>
                <input type="range" id="font-size-slider" min="0.8" max="1.5" step="0.1" value="1">
            </div>
            <div class="settings-group">
                <label for="minimap-size-slider" data-lang-zh="小地图大小" data-lang-en="Minimap Size">小地图大小</label>
                <input type="range" id="minimap-size-slider" min="1" max="1.414" step="0.01" value="1">
            </div>
            <div class="settings-group">
                <label for="helper-text-toggle" data-lang-zh="辅助文字" data-lang-en="Helper Text">辅助文字</label>
                <select id="helper-text-toggle">
                    <option value="on" data-lang-zh="开启" data-lang-en="On">开启</option>
                    <option value="off" data-lang-zh="关闭" data-lang-en="Off">关闭</option>
                </select>
            </div>
            <button id="close-settings-btn" data-lang-zh="关闭" data-lang-en="Close">关闭</button>
        </div>
    </div>

    <div id="pause-menu-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="暂停菜单" data-lang-en="Pause Menu">暂停菜单</h2>
            <button id="resume-game-btn" data-lang-zh="返回游戏" data-lang-en="Resume Game">返回游戏</button>
            <button id="level-select-btn" data-lang-zh="选择关卡" data-lang-en="Select Level">选择关卡</button>
            <button id="reset-game-btn" data-lang-zh="重置游戏" data-lang-en="Reset Game">重置游戏</button>
            <button id="pause-to-main-menu-btn" data-lang-zh="返回主菜单" data-lang-en="Main Menu">返回主菜单</button>
        </div>
    </div>

    <div id="level-select-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="选择关卡" data-lang-en="Select Level">选择关卡</h2>
            <div id="level-select-grid"></div>
            <button id="close-level-select-btn" data-lang-zh="返回" data-lang-en="Back">返回</button>
        </div>
    </div>
    
    <div id="editor-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="地图编辑器" data-lang-en="Map Editor">地图编辑器</h2>
            <div id="editor-toolbar">
                <select id="editor-slot-select"></select>
                <button id="tool-wall" data-tool="wall" data-lang-zh="墙" data-lang-en="Wall">墙</button>
                <button id="tool-path" data-tool="path" data-lang-zh="路" data-lang-en="Path">路</button>
                <button id="tool-start" data-tool="start" data-lang-zh="起点" data-lang-en="Start">起点</button>
                <button id="tool-goal" data-tool="goal" data-lang-zh="终点" data-lang-en="Goal">终点</button>
            </div>
            <div id="editor-grid"></div>
            <p id="editor-message" style="color: red; min-height: 1.2em;"></p>
            <button id="editor-save-btn" data-lang-zh="保存地图" data-lang-en="Save Map">保存地图</button>
            <button id="editor-delete-btn" data-lang-zh="删除此地图" data-lang-en="Delete Map" class="danger">删除此地图</button>
            <button id="editor-back-btn" data-lang-zh="返回主菜单" data-lang-en="Back to Menu">返回主菜单</button>
        </div>
    </div>
    
    <div id="custom-maps-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="自定义地图" data-lang-en="Custom Maps">自定义地图</h2>
            <div id="custom-maps-grid"></div>
            <p data-lang-zh="选择一张地图进行操作。" data-lang-en="Select a map to continue.">选择一张地图进行操作。</p>
            <button id="custom-play-btn" data-lang-zh="游玩" data-lang-en="Play" disabled>游玩</button>
            <button id="custom-edit-btn" data-lang-zh="编辑" data-lang-en="Edit" disabled>编辑</button>
            <button id="custom-delete-btn" data-lang-zh="删除" data-lang-en="Delete" disabled class="danger">删除</button>
            <button id="custom-back-btn" data-lang-zh="返回主菜单" data-lang-en="Back to Menu">返回主菜单</button>
        </div>
    </div>

    <div id="mode-select-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="选择导航模式" data-lang-en="Select Navigation Mode">选择导航模式</h2>
            <button id="mode-select-minimap-btn" data-lang-zh="小地图导航" data-lang-en="Minimap Navigation">小地图导航</button>
            <button id="mode-select-challenge-btn" data-lang-zh="自主导航" data-lang-en="Autonomous Navigation">自主导航</button>
        </div>
    </div>
    
    <div id="confirm-reset-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 data-lang-zh="确认重置" data-lang-en="Confirm Reset">确认重置</h2>
            <p data-lang-zh="您确定要重置所有游戏数据吗？此操作无法撤销。" data-lang-en="Are you sure you want to reset all game data? This action cannot be undone.">您确定要重置所有游戏数据吗？此操作无法撤销。</p>
            <div class="button-row">
                <button id="confirm-reset-btn" class="danger" data-lang-zh="确认" data-lang-en="Confirm">确认</button>
                <button id="cancel-reset-btn" class="secondary" data-lang-zh="取消" data-lang-en="Cancel">取消</button>
            </div>
        </div>
    </div>


    <div id="dev-panel">
        <h4 data-lang-zh="关卡快速切换" data-lang-en="Quick Level Select">关卡快速切换</h4>
        <select id="level-select"></select>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // ====================================================================
        // 全局变量和状态机 (Global Variables & State Machine)
        // ====================================================================
        
        const TILE_SIZE = 10;
        const WALL_HEIGHT = 5;
        const MOVE_SPEED = 15;
        const TURN_SPEED = Math.PI * 2;

        
// 招财猫动画参数（角度为度，速度为弧度/秒）
const LUCKY_CAT = {
    WAVE_CENTER_DEG: 30, // 肩关节中心前倾角
    WAVE_AMPL_DEG: 10,   // 肩关节摆幅（±）
    WAVE_SPEED: 5.0,     // 肩关节摆动速度（rad/s）
    WRIST_AMPL_DEG: 8,   // 腕部小幅“勾手”摆幅（±）
    WRIST_SPEED: 10.0    // 腕部摆动速度（rad/s）
};
let scene, camera, renderer, clock;
        let player, mazeGroup, landmarksGroup, goalMarker, sceneryGroup, steeringWheel;
        let minimap, minimapCtx;
        
        let gameState = 'STARTUP_MODAL';
        let gameMode = 'campaign'; // campaign, free, custom
        let navigationMode = 'minimap'; // minimap, limited
        let currentLevelIndex = 0;
        let playerInfo = { nickname: 'Driver', gender: 'other' };

        let playerChoices = 0;
        let optimalChoices = 0;
        let mapViewChances = 3;
        
        let targetPosition = new THREE.Vector3();
        let targetRotation = new THREE.Euler();
        let previousGameState = '';
        let unlockedLevel = 0;

        const keyState = { 'a': false, 'd': false, 'e': false, 'space': false, 'escape': false };
        let keyDebounce = false;

        let wallMaterialNS, wallMaterialEW, floorMaterial, landmarkMaterial, goalWallMaterial;
        let hemisphereLight, dirLight;
        
        let customLevels = [];
        let luckyCatArm, luckyCatWrist;

        let currentLanguage = 'zh';

        // ====================================================================
        // 语言翻译数据 (Language Translation Data)
        // ====================================================================
        const translations = {
            zh: {
                welcome: (nickname) => `你好, ${nickname}!`,
                levelComplete: "关卡完成！",
                drivingGenius: "驾驶天才",
                greatDriver: "优秀司机",
                newDriver: "新手上路",
                quoteGenius: "完美！你就是这座城市的传奇！",
                quoteGreat: "干得漂亮！路线规划得非常出色。",
                quoteNew: "安全到达！经验丰富的选择。",
                stats: (p, o, r) => `你的步数: ${p} | 最优步数: ${o} | R值: ${r}`,
                freeModeComplete: "自由模式练习完成。",
                nextLevel: "下一关",
                finalResults: "查看最终结果",
                select: "选择",
                forward: "向前",
                turnLeft: "向左",
                turnRight: "向右",
                turnAround: "掉头",
                helperText: "按 A/D 转向, 空格前进",
                level: "关卡",
                confirmReset: "您确定要重置所有游戏数据吗？此操作无法撤销。",
                allLevelsCleared: "恭喜你！已通关所有关卡！",
                mapChances: "查看地图次数",
                editor_need_start: "地图需要一个起点。",
                editor_need_goal: "地图需要一个终点。",
                editor_unsolvable: "地图无解！请确保起点和终点连通。",
                map_slot: "地图槽",
                empty_slot: "空槽位",
                confirm_delete: "您确定要删除这张地图吗？"
            },
            en: {
                welcome: (nickname) => `Hello, ${nickname}!`,
                levelComplete: "Level Complete!",
                drivingGenius: "Driving Genius",
                greatDriver: "Great Driver",
                newDriver: "New Driver",
                quoteGenius: "Perfect! You are a legend in this city!",
                quoteGreat: "Well done! An excellent route plan.",
                quoteNew: "Arrived safely! A solid choice.",
                stats: (p, o, r) => `Your Steps: ${p} | Optimal: ${o} | R-Value: ${r}`,
                freeModeComplete: "Free mode practice complete.",
                nextLevel: "Next Level",
                finalResults: "View Final Results",
                select: "Select",
                forward: "Forward",
                turnLeft: "Turn Left",
                turnRight: "Turn Right",
                turnAround: "Turn Around",
                helperText: "Use A/D to turn, Space to move",
                level: "Level",
                confirmReset: "Are you sure you want to reset all game data? This action cannot be undone.",
                allLevelsCleared: "Congratulations! You have cleared all levels!",
                mapChances: "Map Views Left",
                editor_need_start: "Map needs a starting point.",
                editor_need_goal: "Map needs a goal point.",
                editor_unsolvable: "Map is unsolvable! Make sure the start and goal are connected.",
                map_slot: "Map Slot",
                empty_slot: "Empty Slot",
                confirm_delete: "Are you sure you want to delete this map?"
            }
        };

        // ====================================================================
        // 关卡数据 (Level Data) - v5.5
        // ====================================================================
        const MAZE_DATA = [
            // Level 1 (15x15)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',1,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1],[1,0,0,0,1,0,1,0,1,0,1,0,0,'S',1],[1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,0,1,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,1,1],[1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 2 (15x15)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,0,1,0,1,0,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,1,'S',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 3 (15x15)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,'S',1,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 4 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',1,0,0,'S',1,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1],[1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 5 (17x17)
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1],[1,0,1,0,0,0,0,0,0,0,1,0,1,'E',0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 6 (17x17) - Simplified
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,1],[1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1],[1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1],[1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 7 (17x17) - Simplified
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,'E',1],[1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1],[1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 8 (17x17) - Redesigned and Solvable
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],[1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1],[1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1],[1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],[1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1],[1,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1],[1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 9 (17x17) - Redesigned and Solvable
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],[1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1],[1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1],[1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1],[1,0,0,0,0,1,0,0,0,1,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,0,1,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 10 (17x17) - Simplified
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 11 (17x17) - Simplified
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1],[1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 12 (17x17) - Redesigned and Solvable
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'E',0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],[1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1],[1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,0,1],[1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1],[1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,0,1],[1,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,1],[1,0,1,1,1,1,0,1,'S',1,0,1,1,1,0,1,1],[1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,1],[1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1],[1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1],[1,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,1],[1,1,1,0,1,0,1,0,1,1,1,1,0,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 13 (17x17) - Simplified
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1],[1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1],[1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1],[1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1],[1,'E',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 14 (17x17) - Redesigned and Solvable
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1],[1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,'E',1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            // Level 15 (17x17) - Simplified
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,1,'S',0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1],[1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1],[1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1,'E',0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
        ];
        
        const levels = MAZE_DATA.map(mazeData => {
            const grid = [];
            let start = {};
            let goal = {};
            const height = mazeData.length;
            const width = mazeData[0].length;

            for(let z = 0; z < height; z++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    const cell = mazeData[z][x];
                    if (cell === 'S') {
                        start = { x, z, dir: 'S' }; // Default dir, can be changed
                        row.push(1); // Path
                    } else if (cell === 'E') {
                        goal = { x, z };
                        row.push(1); // Path
                    } else {
                        // In my game, 1 is path and 0 is wall.
                        // In MAZE_DATA, 1 is wall and 0 is path. So I flip it.
                        row.push(cell === 1 ? 0 : 1);
                    }
                }
                grid.push(row);
            }
            
            if (start.x === 0) start.dir = 'E';
            else if (start.x === width - 1) start.dir = 'W';
            else if (start.z === 0) start.dir = 'S';
            else if (start.z === height - 1) start.dir = 'N';

            return { grid, start, goal };
        });

        // ====================================================================
        // 初始化函数 (Initialization)
        // ====================================================================
        
        function init() {
            scene = new THREE.Scene();
            const loader = new THREE.CubeTextureLoader();
            const texture = loader.load([
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/px.jpg',
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/nx.jpg',
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/py.jpg',
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/ny.jpg',
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/pz.jpg',
                'https://threejs.org/examples/textures/cube/skyboxsun25deg/nz.jpg',
            ]);
            scene.background = texture;
            scene.fog = new THREE.Fog(0xcccccc, TILE_SIZE * 5, TILE_SIZE * 20);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);
            clock = new THREE.Clock();

            hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
            hemisphereLight.position.set(0, 20, 0);
            scene.add(hemisphereLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
            dirLight.position.set(-1, 1.75, 1);
            dirLight.position.multiplyScalar(30);
            scene.add(dirLight);

            player = new THREE.Object3D();
            scene.add(player);
            player.add(camera);

            camera.position.set(0, WALL_HEIGHT * 0.4, 0);
            camera.rotation.x = THREE.MathUtils.degToRad(-8);

            const headLight = new THREE.SpotLight(0xffffff, 10, 8 * TILE_SIZE, Math.PI / 4, 0.5, 1.5);
            headLight.position.set(0, 0, 1);
            camera.add(headLight);

            mazeGroup = new THREE.Group();
            sceneryGroup = new THREE.Group();
            scene.add(mazeGroup);
            scene.add(sceneryGroup);
            
            landmarksGroup = new THREE.Group();
            camera.add(landmarksGroup);
            
            steeringWheel = createSteeringWheel();
            camera.add(steeringWheel);
            
            minimap = document.getElementById('minimap-canvas');
            minimapCtx = minimap.getContext('2d');

            createMaterials();
            loadCustomLevels();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            setupUI();
            updateUIText();
            
            animate();
        }

        function setupUI() {
            document.getElementById('initial-language-select').addEventListener('change', (e) => {
                currentLanguage = e.target.value;
                updateUIText();
            });

            document.getElementById('start-game-btn').addEventListener('click', () => {
                currentLanguage = document.getElementById('initial-language-select').value;
                document.getElementById('language-select').value = currentLanguage;

                const nickname = document.getElementById('nickname-input').value.trim();
                playerInfo.nickname = nickname || (currentLanguage === 'zh' ? '司机' : 'Driver');
                playerInfo.gender = document.getElementById('gender-select').value;

                document.getElementById('startup-modal').style.display = 'none';
                document.getElementById('main-menu-modal').style.display = 'flex';
                updateUIText();
                gameState = 'MAIN_MENU';
            });

            document.getElementById('campaign-mode-btn').addEventListener('click', () => {
                gameMode = 'campaign';
                document.getElementById('main-menu-modal').style.display = 'none';
                document.getElementById('mode-select-modal').style.display = 'flex';
            });

            document.getElementById('free-mode-btn').addEventListener('click', () => {
                gameMode = 'free'; 
                document.getElementById('main-menu-modal').style.display = 'none';
                document.getElementById('mode-select-modal').style.display = 'flex';
            });
            
            document.getElementById('editor-mode-btn').addEventListener('click', () => showEditor());
            
            document.getElementById('custom-mode-btn').addEventListener('click', () => {
                if (customLevels.some(level => level !== null)) {
                    gameMode = 'custom';
                    showCustomMapsModal();
                }
            });
            
            function startGameFromModeSelect() {
                document.getElementById('mode-select-modal').style.display = 'none';
                
                if (gameMode === 'free') {
                    setupDevPanel();
                    document.getElementById('dev-panel').style.display = 'block';
                    loadLevel(0);
                } else if (gameMode === 'custom') {
                    loadLevel(customLevels[selectedCustomMapIndex]);
                } else if (gameMode === 'campaign') {
                    document.getElementById('dev-panel').style.display = 'none';
                    loadLevel(0);
                }
            }

            document.getElementById('mode-select-minimap-btn').addEventListener('click', () => {
                navigationMode = 'minimap';
                startGameFromModeSelect();
            });
            
            document.getElementById('mode-select-challenge-btn').addEventListener('click', () => {
                navigationMode = 'limited';
                startGameFromModeSelect();
            });

            document.getElementById('next-level-btn').addEventListener('click', () => {
                document.getElementById('level-complete-modal').style.display = 'none';
                if (currentLevelIndex !== -1) {
                    currentLevelIndex++;
                    if (currentLevelIndex < levels.length) {
                        loadLevel(currentLevelIndex);
                    } else {
                        alert(translations[currentLanguage].allLevelsCleared);
                        showMainMenu();
                    }
                }
            });
            document.getElementById('main-menu-btn').addEventListener('click', () => {
                document.getElementById('level-complete-modal').style.display = 'none';
                showMainMenu();
            });

            document.getElementById('minimap-container').addEventListener('click', () => {
                if (gameState === 'BIG_MAP') {
                    const container = document.getElementById('minimap-container');
                    if (navigationMode === 'limited') {
                        container.style.display = 'none';
                    } else {
                        container.classList.remove('big-map');
                        container.classList.add('small-map');
                    }
                    gameState = 'AT_INTERSECTION';
                    checkForTurns();
                } else if (gameState === 'CHALLENGE_MAP_VIEW') {
                    toggleChallengeMap();
                }
            });

            document.getElementById('settings-button').addEventListener('click', () => {
                document.getElementById('settings-panel').style.display = 'flex';
            });
            document.getElementById('close-settings-btn').addEventListener('click', () => {
                document.getElementById('settings-panel').style.display = 'none';
            });
            document.getElementById('font-size-slider').addEventListener('input', (e) => {
                document.body.style.fontSize = `calc(${getComputedStyle(document.body).getPropertyValue('--font-size-normal')} * ${e.target.value})`;
            });
            document.getElementById('minimap-size-slider').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--minimap-scale', e.target.value);
            });
            document.getElementById('language-select').addEventListener('change', (e) => {
                currentLanguage = e.target.value;
                document.getElementById('initial-language-select').value = currentLanguage;
                updateUIText();
            });
            
            document.getElementById('resume-game-btn').addEventListener('click', togglePauseMenu);
            document.getElementById('pause-to-main-menu-btn').addEventListener('click', () => {
                togglePauseMenu();
                showMainMenu();
            });
            document.getElementById('level-select-btn').addEventListener('click', showLevelSelectModal);
            
            document.getElementById('reset-game-btn').addEventListener('click', () => {
                document.getElementById('confirm-reset-modal').style.display = 'flex';
            });
            
            document.getElementById('confirm-reset-btn').addEventListener('click', () => {
                document.getElementById('confirm-reset-modal').style.display = 'none';
                resetGame();
            });

            document.getElementById('cancel-reset-btn').addEventListener('click', () => {
                document.getElementById('confirm-reset-modal').style.display = 'none';
            });

            document.getElementById('close-level-select-btn').addEventListener('click', () => {
                document.getElementById('level-select-modal').style.display = 'none';
                document.getElementById('pause-menu-modal').style.display = 'flex';
            });
        }

        function setupDevPanel() {
            const select = document.getElementById('level-select');
            select.innerHTML = '';
            levels.forEach((_, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${translations[currentLanguage].level} ${index + 1}`;
                select.appendChild(option);
            });
            select.addEventListener('change', (e) => {
                loadLevel(parseInt(e.target.value));
            });
        }
        
        function showMainMenu() {
            gameState = 'MAIN_MENU';
            document.getElementById('main-menu-modal').style.display = 'flex';
            document.getElementById('custom-mode-btn').disabled = !customLevels.some(level => level !== null);

            while(mazeGroup.children.length > 0){ mazeGroup.remove(mazeGroup.children[0]); }
            while(landmarksGroup.children.length > 0){ landmarksGroup.remove(landmarksGroup.children[0]); }
            while(sceneryGroup.children.length > 0){ sceneryGroup.remove(sceneryGroup.children[0]); }
            if(goalMarker) scene.remove(goalMarker);

            document.getElementById('minimap-container').style.display = 'none';
            document.getElementById('map-view-count').style.display = 'none';
        }

        // ====================================================================
        // 游戏核心逻辑 (Core Game Logic)
        // ====================================================================
        
        function loadLevel(levelData) {
            let level;
            if (typeof levelData === 'number') {
                if (levelData >= levels.length) {
                    console.error(`Level index ${levelData} out of bounds!`);
                    showMainMenu();
                    return;
                }
                currentLevelIndex = levelData;
                level = levels[levelData];
            } else {
                level = levelData;
                currentLevelIndex = -1; // Indicates a custom level
            }

            playerChoices = 0;
            document.getElementById('choice-prompt').style.display = 'none';

            while(mazeGroup.children.length > 0){ mazeGroup.remove(mazeGroup.children[0]); }
            while(landmarksGroup.children.length > 0){ camera.remove(landmarksGroup); landmarksGroup = new THREE.Group(); camera.add(landmarksGroup); }
            while(sceneryGroup.children.length > 0){ sceneryGroup.remove(sceneryGroup.children[0]); }
            if(goalMarker) scene.remove(goalMarker);

            createMazeMesh(level.grid, level.goal);
            placeRoadsideObjects(level.grid);
            createGoalMarker(level.goal);
            
            const startPos = gridToWorld(level.start.x, level.start.z, level.grid);
            player.position.set(startPos.x, 0, startPos.z);
            player.rotation.y = dirToAngle(level.start.dir);
            targetRotation.y = player.rotation.y;

            const pathInfo = findShortestPath(level);
            if (!pathInfo) {
                const message = `Level ${currentLevelIndex >= 0 ? currentLevelIndex + 1 : 'Custom'} is unsolvable!`;
                alert(message);
                console.error(message, level);
                showMainMenu();
                return;
            }
            optimalChoices = pathInfo.choices;
            console.log(`Level ${currentLevelIndex >= 0 ? currentLevelIndex + 1 : 'Custom'}: Optimal Steps = ${optimalChoices}`);
            
            const minimapContainer = document.getElementById('minimap-container');
            minimapContainer.style.display = 'block';
            minimapContainer.classList.remove('small-map');
            minimapContainer.classList.add('big-map');
            
            if (navigationMode === 'limited') {
                mapViewChances = 3;
            }
            updateHUD();
            
            lastPlayerGridPos = { x: -1, z: -1 }; 
            updateMinimapPlayer();
            
            gameState = 'BIG_MAP';
        }

        function gridToWorld(x, z, grid) {
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;
            return new THREE.Vector3(
                (x - gridWidth / 2 + 0.5) * TILE_SIZE,
                0,
                (z - gridHeight / 2 + 0.5) * TILE_SIZE
            );
        }
        
        function worldToGrid(position) {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            if (!level) return {x:0, z:0};
            const gridWidth = level.grid[0].length;
            const gridHeight = level.grid.length;
            return {
                x: Math.round(position.x / TILE_SIZE + gridWidth / 2 - 0.5),
                z: Math.round(position.z / TILE_SIZE + gridHeight / 2 - 0.5)
            };
        }
        
        function dirToAngle(dir) {
            switch (dir) {
                case 'N': return Math.PI;
                case 'E': return -Math.PI / 2;
                case 'S': return 0;
                case 'W': return Math.PI / 2;
            }
            return 0;
        }

        function checkForTurns() {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            const gridPos = worldToGrid(player.position);
            const { goal } = level;

            if (gridPos.x === goal.x && gridPos.z === goal.z) {
                gameState = 'LEVEL_COMPLETE';
                showLevelComplete();
                return;
            }
            
            createDirectionalHelpers();
            updateChoicePrompt();
            gameState = 'AT_INTERSECTION';
        }

        function cameraShake() {
            const shakeIntensity = 0.05;
            let shakeDuration = 200; // ms
            const startTime = Date.now();

            function shake() {
                const elapsedTime = Date.now() - startTime;
                if (elapsedTime > shakeDuration) {
                    camera.position.set(0, WALL_HEIGHT * 0.4, 0);
                    return;
                }
                const progress = elapsedTime / shakeDuration;
                const shakeAmount = shakeIntensity * (1 - progress);
                const shakeX = (Math.random() - 0.5) * shakeAmount;
                const shakeY = (Math.random() - 0.5) * shakeAmount;
                camera.position.set(shakeX, WALL_HEIGHT * 0.4 + shakeY, 0);
                requestAnimationFrame(shake);
            }
            shake();
        }
        
        function updateChoicePrompt() {
            const prompt = document.getElementById('choice-prompt');
            const helperToggle = document.getElementById('helper-text-toggle').value;
            const lang = translations[currentLanguage];

            if (gameState !== 'AT_INTERSECTION' || helperToggle === 'off') {
                prompt.style.display = 'none';
                return;
            }
            
            prompt.style.display = 'inline-block';
            prompt.innerHTML = `<span style="font-size: 0.8em;">${lang.helperText}</span>`;
        }

        function setupMove() {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            const gridPos = worldToGrid(player.position);
            const moveVector = new THREE.Vector3(0, 0, -1).applyEuler(player.rotation);
            const nextGridX = gridPos.x + Math.round(moveVector.x);
            const nextGridZ = gridPos.z + Math.round(moveVector.z);

            if (nextGridZ < 0 || nextGridZ >= level.grid.length || nextGridX < 0 || nextGridX >= level.grid[0].length || level.grid[nextGridZ][nextGridX] === 0) {
                cameraShake();
            } else {
                playerChoices++;
                document.getElementById('choice-prompt').style.display = 'none';
                while (landmarksGroup.children.length > 0) {
                    landmarksGroup.remove(landmarksGroup.children[0]);
                }
                targetPosition.copy(gridToWorld(nextGridX, nextGridZ, level.grid));
                gameState = 'DRIVING';
            }
        }
        
        function showLevelComplete() {
            const modal = document.getElementById('level-complete-modal');
            const stats = document.getElementById('results-stats');
            const medalEl = document.getElementById('results-medal');
            const quoteEl = document.getElementById('results-quote');
            const nextBtn = document.getElementById('next-level-btn');
            const lang = translations[currentLanguage];
            
            nextBtn.style.display = 'none';

            if (gameMode === 'campaign') {
                unlockedLevel = Math.max(unlockedLevel, currentLevelIndex + 1);
                const R = optimalChoices > 0 ? playerChoices / optimalChoices : 1;
                let medal = '';
                let title = '';
                let quote = '';

                if (R <= 1.0) {
                    medal = '🥇';
                    title = lang.drivingGenius;
                    quote = lang.quoteGenius;
                } else if (R <= 1.5) {
                    medal = '🥈';
                    title = lang.greatDriver;
                    quote = lang.quoteGreat;
                } else {
                    medal = '🥉';
                    title = lang.newDriver;
                    quote = lang.quoteNew;
                }
                
                medalEl.textContent = medal;
                document.getElementById('results-title').textContent = title;
                stats.textContent = lang.stats(playerChoices, optimalChoices, R.toFixed(2));
                quoteEl.textContent = quote;
                
                stats.style.display = 'block';
                medalEl.style.display = 'block';
                quoteEl.style.display = 'block';

                if (currentLevelIndex !== -1 && currentLevelIndex < levels.length - 1) {
                    nextBtn.textContent = lang.nextLevel;
                    nextBtn.style.display = 'inline-block';
                }

            } else { // Free mode or Custom
                document.getElementById('results-title').textContent = lang.levelComplete;
                stats.style.display = 'none';
                medalEl.style.display = 'none';
                quoteEl.textContent = lang.freeModeComplete;
            }
            
            modal.style.display = 'flex';
        }

        // ====================================================================
        // 渲染和动画 (Rendering & Animation)
        // ====================================================================
        
        function animate() {
            requestAnimationFrame(animate);
            if(gameState === 'PAUSED' || gameState === 'CHALLENGE_MAP_VIEW') return;
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            const dayNightCycle = (Math.sin(elapsedTime * 0.1) + 1) / 2;
            const nightIntensity = Math.max(0, 1 - dayNightCycle * 4);
            
            if (scene.background.isCubeTexture) {
                hemisphereLight.intensity = dayNightCycle * 1.5 + 0.2;
                dirLight.intensity = dayNightCycle * 2.0 + 0.2;
            } else {
                scene.background.setHSL(0.6, 0.7, dayNightCycle * 0.4 + 0.3);
                hemisphereLight.intensity = dayNightCycle * 2.5 + 0.5;
            }
            
            sceneryGroup.children.forEach(sceneryObject => {
                const light = sceneryObject.getObjectByName('lampLight');
                if (light) {
                    light.intensity = nightIntensity * 8;
                }
            });


            if (goalMarker) {
                goalMarker.position.y = WALL_HEIGHT/2 - 1.5 + Math.sin(elapsedTime) * 0.2;
                goalMarker.rotation.y += delta * 0.2;
                if (luckyCatArm) {
                    const toRad = THREE.MathUtils.degToRad;
                    const c  = toRad(LUCKY_CAT.WAVE_CENTER_DEG);
                    const a  = toRad(LUCKY_CAT.WAVE_AMPL_DEG);
                    const w1 = LUCKY_CAT.WAVE_SPEED;

                    // 肩关节：保持在身体前方 [c-a, c+a]
                    luckyCatArm.rotation.x = c + Math.sin(elapsedTime * w1) * a;

                    // 腕关节：更快的小幅“勾手”
                    if (typeof luckyCatWrist !== 'undefined' && luckyCatWrist) {
                        const a2 = toRad(LUCKY_CAT.WRIST_AMPL_DEG);
                        const w2 = LUCKY_CAT.WRIST_SPEED;
                        luckyCatWrist.rotation.x = Math.sin(elapsedTime * w2) * a2;
                    }
                }
            }

            if (gameState === 'TURNING') {
                let angleDiff = targetRotation.y - player.rotation.y;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

                if (Math.abs(angleDiff) > 0.01) {
                    const turnStep = Math.sign(angleDiff) * TURN_SPEED * delta;
                    if (Math.abs(turnStep) >= Math.abs(angleDiff)) {
                        player.rotation.y = targetRotation.y;
                    } else {
                        player.rotation.y += turnStep;
                    }
                } else {
                    player.rotation.y = targetRotation.y;
                    gameState = 'AT_INTERSECTION';
                    checkForTurns();
                }
            }
            
            if (gameState === 'DRIVING') {
                const distanceToTarget = player.position.distanceTo(targetPosition);
                if (distanceToTarget > 0.01) {
                    const moveVector = targetPosition.clone().sub(player.position).normalize();
                    const moveDistance = Math.min(distanceToTarget, MOVE_SPEED * delta);
                    player.position.add(moveVector.multiplyScalar(moveDistance));
                } else {
                    player.position.copy(targetPosition);
                    gameState = 'AT_INTERSECTION';
                    checkForTurns();
                }
            }
            
            if (steeringWheel) {
                steeringWheel.rotation.z = (player.rotation.y - targetRotation.y) * 2;
            }
            
            if (['DRIVING', 'TURNING', 'AT_INTERSECTION', 'BIG_MAP'].includes(gameState)) {
                updateMinimapPlayer();
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ====================================================================
        // 输入处理 (Input Handling)
        // ====================================================================
        
        function onKeyDown(event) {
            if (!event || !event.key) return;
            const key = event.key.toLowerCase();
            if (keyState[key]) return;
            keyState[key] = true;

            if (key === 'escape') {
                togglePauseMenu();
                return;
            }
            
            if (key === 'e') {
                if (navigationMode === 'limited') {
                    toggleChallengeMap();
                }
                return;
            }

            if (gameState !== 'AT_INTERSECTION') return;
            
            if (key === 'a' || key === 'd') {
                if (keyDebounce) return;
                keyDebounce = true;
                setTimeout(() => { keyDebounce = false; }, 100);

                if (key === 'd') {
                    targetRotation.y -= Math.PI / 2;
                } else if (key === 'a') {
                    targetRotation.y += Math.PI / 2;
                }
                gameState = 'TURNING';
                
            } else if (key === ' ' || key === 'spacebar') {
                setupMove();
            }
        }
        
        function onKeyUp(event) {
            if (!event || !event.key) return;
            const key = event.key.toLowerCase();
            keyState[key] = false;
        }

        // ====================================================================
        // 3D迷宫与视觉生成 (3D Maze & Visuals Generation)
        // ====================================================================

        function createMazeMesh(grid, goal) {
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;

            const floorPlane = new THREE.PlaneGeometry(gridWidth * TILE_SIZE, gridHeight * TILE_SIZE);
            const floor = new THREE.Mesh(floorPlane, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            mazeGroup.add(floor);

            const wallGeo = new THREE.PlaneGeometry(TILE_SIZE, WALL_HEIGHT);

            for (let z = 0; z < gridHeight; z++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[z][x] === 1) { // Only check from path cells
                        const worldPos = gridToWorld(x, z, grid);
                        const isNearGoal = Math.abs(x - goal.x) <= 1 && Math.abs(z - goal.z) <= 1 && !(x === goal.x && z === goal.z);

                        // Check North
                        if (z > 0 && grid[z - 1][x] === 0) {
                             const material = isNearGoal && z - 1 === goal.z ? goalWallMaterial : wallMaterialNS;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x, WALL_HEIGHT / 2, worldPos.z - TILE_SIZE / 2);
                             mazeGroup.add(wall);
                        }
                        // Check South
                        if (z < gridHeight - 1 && grid[z + 1][x] === 0) {
                             const material = isNearGoal && z + 1 === goal.z ? goalWallMaterial : wallMaterialNS;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x, WALL_HEIGHT / 2, worldPos.z + TILE_SIZE / 2);
                             wall.rotation.y = Math.PI;
                             mazeGroup.add(wall);
                        }
                        // Check West
                        if (x > 0 && grid[z][x - 1] === 0) {
                             const material = isNearGoal && x - 1 === goal.x ? goalWallMaterial : wallMaterialEW;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x - TILE_SIZE / 2, WALL_HEIGHT / 2, worldPos.z);
                             wall.rotation.y = Math.PI / 2;
                             mazeGroup.add(wall);
                        }
                        // Check East
                        if (x < gridWidth - 1 && grid[z][x + 1] === 0) {
                             const material = isNearGoal && x + 1 === goal.x ? goalWallMaterial : wallMaterialEW;
                             const wall = new THREE.Mesh(wallGeo, material);
                             wall.position.set(worldPos.x + TILE_SIZE / 2, WALL_HEIGHT / 2, worldPos.z);
                             wall.rotation.y = -Math.PI / 2;
                             mazeGroup.add(wall);
                        }
                    }
                }
            }
        }
        
        function createLuckyCat() {
    const catGroup = new THREE.Group();

    // --- 材质 ---
    const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.25, metalness: 0.1 });
    const redMat   = new THREE.MeshStandardMaterial({ color: 0xaa2222, roughness: 0.35, metalness: 0.1 });
    const goldMat  = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.1,  metalness: 0.5 });
    const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
    const pinkMat  = new THREE.MeshStandardMaterial({ color: 0xffc0cb, roughness: 0.4 });

    // --- 身体 ---
    const body = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 16), whiteMat);
    body.scale.y = 0.8;
    catGroup.add(body);

    // --- 头部 ---
    const head = new THREE.Mesh(new THREE.SphereGeometry(1.2, 32, 16), whiteMat);
    head.position.y = 1.8;
    catGroup.add(head);

    // 眼睛/鼻子
    const eyeGeo = new THREE.SphereGeometry(0.1, 12, 8);
    const leftEye  = new THREE.Mesh(eyeGeo, blackMat); leftEye.position.set(-0.4, 0.2, 1.11); head.add(leftEye);
    const rightEye = new THREE.Mesh(eyeGeo, blackMat); rightEye.position.set( 0.4, 0.2, 1.11); head.add(rightEye);

    const nose = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), blackMat);
    nose.position.set(0, 0, 1.18); nose.scale.set(1.5, 1, 1); head.add(nose);

    // 胡须
    const lineMat = new THREE.LineBasicMaterial({ color: 0x111111, linewidth: 2 });
    for (let i = 0; i < 3; i++) {
        const whiskerL = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-0.2, -0.1, 1.15), new THREE.Vector3(-1.2, -i * 0.15, 0.8)
        ]), lineMat);
        const whiskerR = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3( 0.2, -0.1, 1.15), new THREE.Vector3( 1.2, -i * 0.15, 0.8)
        ]), lineMat);
        head.add(whiskerL, whiskerR);
    }

    // --- 耳朵：白色外耳 + 粉色内耳 ---
    const earOuterGeo = new THREE.ConeGeometry(0.4, 0.8, 12);
    const earInnerGeo = new THREE.ConeGeometry(0.28, 0.5, 12);

    const leftEar = new THREE.Mesh(earOuterGeo, whiteMat);
    leftEar.position.set(-0.8, 2.8, 0.06); leftEar.rotation.z = Math.PI / 10;
    catGroup.add(leftEar);
    const leftInner = new THREE.Mesh(earInnerGeo, pinkMat);
    leftInner.position.set(0, -0.05, 0.15); leftInner.rotation.x = -Math.PI / 12;
    leftEar.add(leftInner);

    const rightEar = new THREE.Mesh(earOuterGeo, whiteMat);
    rightEar.position.set( 0.8, 2.8, 0.06); rightEar.rotation.z = -Math.PI / 10;
    catGroup.add(rightEar);
    const rightInner = new THREE.Mesh(earInnerGeo, pinkMat);
    rightInner.position.set(0, -0.05, 0.15); rightInner.rotation.x = -Math.PI / 12;
    rightEar.add(rightInner);

    // --- 项圈 + 铃铛 ---
    const collar = new THREE.Mesh(new THREE.TorusGeometry(1.3, 0.1, 8, 32), redMat);
    collar.position.y = 1.2; collar.rotation.x = Math.PI / 2; catGroup.add(collar);
    const bell = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 8), goldMat);
    bell.position.set(0, 1.2, 1.3); catGroup.add(bell);

    // --- 手臂/肩关节（左臂招手）---
    // 关键：控制点放到 +Z（身体前方），并添加 wrist（腕关节）
    luckyCatArm = new THREE.Object3D();
    luckyCatArm.position.set(-1.05, 1.1, 0.35);
    catGroup.add(luckyCatArm);

    const armCurvePoints = [
        new THREE.Vector3(0,   0.0, 0.0),
        new THREE.Vector3(0,   0.75, 0.25),
        new THREE.Vector3(0,   1.35, 0.40)
    ];
    const armCurve = new THREE.CatmullRomCurve3(armCurvePoints);
    const arm = new THREE.Mesh(new THREE.TubeGeometry(armCurve, 20, 0.30, 8, false), whiteMat);
    luckyCatArm.add(arm);

    // 腕关节 pivot
    luckyCatWrist = new THREE.Object3D();
    luckyCatWrist.position.copy(armCurvePoints[armCurvePoints.length - 1]);
    luckyCatArm.add(luckyCatWrist);

    // 爪子：面向前方（+Z），爪垫在前侧
    const paw = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 12), whiteMat);
    paw.scale.set(1, 0.8, 1);
    paw.position.set(0, 0, 0);
    paw.rotation.y = 0;
    luckyCatWrist.add(paw);

    const mainPad = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 8), pinkMat);
    mainPad.position.set(0, -0.1, 0.30); mainPad.scale.set(1.2, 1, 0.5); paw.add(mainPad);
    for (let i = 0; i < 3; i++) {
        const pad = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), pinkMat);
        pad.position.set(-0.2 + i * 0.2, 0.1, 0.35); pad.scale.z = 0.5; paw.add(pad);
    }

    // --- （可选）金币 ---
    const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 0.12, 32), goldMat);
    coin.position.set(0, 0.3, 1.0);
    coin.rotation.x = Math.PI / 2;
    catGroup.add(coin);

    return catGroup;
}

function createGoalMarker(goalCoords) {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            const goalPos = gridToWorld(goalCoords.x, goalCoords.z, level.grid);
            
            goalMarker = new THREE.Group();
            
            const cat = createLuckyCat();
            cat.scale.set(1.5, 1.5, 1.5);
            goalMarker.add(cat);
            
            goalMarker.position.copy(goalPos);
            goalMarker.position.y = WALL_HEIGHT/2 - 1.5;
            scene.add(goalMarker);
        }
        
        function createDirectionalHelpers() {
            while (landmarksGroup.children.length > 0) {
                landmarksGroup.remove(landmarksGroup.children[0]);
            }

            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            const gridPos = worldToGrid(player.position);

            const arrowShape = new THREE.Shape();
            const w = 0.4;
            const h = 0.6;
            arrowShape.moveTo(0, h / 2);
            arrowShape.lineTo(w / 2, 0);
            arrowShape.lineTo(w / 4, 0);
            arrowShape.lineTo(w / 4, -h / 2);
            arrowShape.lineTo(-w / 4, -h / 2);
            arrowShape.lineTo(-w / 4, 0);
            arrowShape.lineTo(-w / 2, 0);
            arrowShape.closePath();
            const arrowGeo = new THREE.ShapeGeometry(arrowShape);

            const arrowMat = new THREE.MeshBasicMaterial({
                color: 0xffc107,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });

            // Check FORWARD
            const forwardVector = new THREE.Vector3(0, 0, -1).applyEuler(player.rotation);
            let nextX = gridPos.x + Math.round(forwardVector.x);
            let nextZ = gridPos.z + Math.round(forwardVector.z);
            if (nextZ >= 0 && nextZ < level.grid.length && nextX >= 0 && nextX < level.grid[0].length && level.grid[nextZ][nextX] === 1) {
                const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                arrow.position.set(0, 0, -4);
                landmarksGroup.add(arrow);
            }

            // Check LEFT
            const leftRotation = player.rotation.clone();
            leftRotation.y += Math.PI / 2;
            const leftVector = new THREE.Vector3(0, 0, -1).applyEuler(leftRotation);
            nextX = gridPos.x + Math.round(leftVector.x);
            nextZ = gridPos.z + Math.round(leftVector.z);
            if (nextZ >= 0 && nextZ < level.grid.length && nextX >= 0 && nextX < level.grid[0].length && level.grid[nextZ][nextX] === 1) {
                const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                arrow.position.set(-1.5, 0, -4);
                arrow.rotation.z = Math.PI / 2;
                landmarksGroup.add(arrow);
            }

            // Check RIGHT
            const rightRotation = player.rotation.clone();
            rightRotation.y -= Math.PI / 2;
            const rightVector = new THREE.Vector3(0, 0, -1).applyEuler(rightRotation);
            nextX = gridPos.x + Math.round(rightVector.x);
            nextZ = gridPos.z + Math.round(rightVector.z);
            if (nextZ >= 0 && nextZ < level.grid.length && nextX >= 0 && nextX < level.grid[0].length && level.grid[nextZ][nextX] === 1) {
                const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                arrow.position.set(1.5, 0, -4);
                arrow.rotation.z = -Math.PI / 2;
                landmarksGroup.add(arrow);
            }
        }
        
        function createSteeringWheel() {
            const wheelGroup = new THREE.Group();
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7, metalness: 0.1 });
            const gloveMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
            const cuffMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.6 });

            // Wheel
            const wheel = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.08, 16, 60), wheelMat);
            wheelGroup.add(wheel);
            
            // Cute Gloves
            const createGlove = () => {
                const gloveGroup = new THREE.Group();
                const palm = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 12), gloveMat);
                palm.scale.set(1, 1.2, 1);
                gloveGroup.add(palm);
                
                const thumb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 12, 8), gloveMat);
                thumb.position.set(-0.15, 0.1, 0);
                gloveGroup.add(thumb);
                
                const cuff = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 0.2, 16), cuffMat);
                cuff.position.y = -0.15;
                gloveGroup.add(cuff);
                
                return gloveGroup;
            };

            const leftHand = createGlove();
            leftHand.position.set(-0.45, 0.1, 0);
            leftHand.rotation.z = 0.5;
            wheelGroup.add(leftHand);

            const rightHand = createGlove();
            rightHand.position.set(0.45, 0.1, 0);
            rightHand.rotation.z = -0.5;
            wheelGroup.add(rightHand);

            wheelGroup.position.set(0, -1.2, -2);
            wheelGroup.rotation.x = -0.5;
            
            return wheelGroup;
        }
        
        function createClassicalLamp() {
            const group = new THREE.Group();
            const postMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.6, metalness: 0.4 });

            const baseGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.2, 8);
            const base = new THREE.Mesh(baseGeo, postMat);
            base.position.y = 0.1;
            group.add(base);
            
            const postGeo = new THREE.CylinderGeometry(0.15, 0.1, 3.5, 8);
            const post = new THREE.Mesh(postGeo, postMat);
            post.position.y = 1.85;
            group.add(post);

            const holderGeo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const holder = new THREE.Mesh(holderGeo, postMat);
            holder.position.set(0, 3.6, 0.3);
            group.add(holder);

            const lanternGeo = new THREE.SphereGeometry(0.4, 8, 6);
            const lightColors = [0xfffee0, 0xffffff, 0xe0e0ff, 0xffe0e0, 0xffd54f];
            const randomColor = lightColors[Math.floor(Math.random() * lightColors.length)];
            const bulbMat = new THREE.MeshBasicMaterial({ color: randomColor });
            const bulb = new THREE.Mesh(lanternGeo, bulbMat);
            bulb.position.set(0, 3.6, 0.3);
            group.add(bulb);

            const light = new THREE.PointLight(randomColor, 0, TILE_SIZE * 2, 1.5);
            light.name = 'lampLight';
            light.position.copy(bulb.position);
            group.add(light);
            
            return group;
        }

        function placeRoadsideObjects(grid) {
            const gridHeight = grid.length;
            const gridWidth = grid[0].length;

            for (let z = 0; z < gridHeight; z++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[z][x] === 0) continue;

                    const worldPos = gridToWorld(x, z, grid);

                    if (z > 0 && grid[z - 1][x] === 0) {
                        if (x % 3 === 0) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x, 0, worldPos.z - TILE_SIZE * 0.45);
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (z < gridHeight - 1 && grid[z + 1][x] === 0) {
                       if (x % 3 === 1) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x, 0, worldPos.z + TILE_SIZE * 0.45);
                            lamp.rotation.y = Math.PI;
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (x > 0 && grid[z][x - 1] === 0) {
                        if (z % 3 === 0) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x - TILE_SIZE * 0.45, 0, worldPos.z);
                            lamp.rotation.y = Math.PI / 2;
                            sceneryGroup.add(lamp);
                        }
                    }
                    if (x < gridWidth - 1 && grid[z][x + 1] === 0) {
                        if (z % 3 === 1) {
                            const lamp = createClassicalLamp();
                            lamp.position.set(worldPos.x + TILE_SIZE * 0.45, 0, worldPos.z);
                            lamp.rotation.y = -Math.PI / 2;
                            sceneryGroup.add(lamp);
                        }
                    }
                }
            }
        }

        function createMaterials() {
            const textureLoader = new THREE.TextureLoader();

            wallMaterialNS = new THREE.MeshStandardMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--wall-color-ns')),
                roughness: 0.8,
                metalness: 0.2
            });

            wallMaterialEW = new THREE.MeshStandardMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--wall-color-ew')),
                roughness: 0.8,
                metalness: 0.2
            });
            
            const floorTexture = textureLoader.load('https://threejs.org/examples/textures/checker.png');
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            
            floorTexture.magFilter = THREE.NearestFilter;
            floorTexture.minFilter = THREE.NearestFilter;

            const repeatsPerMazeTile = 2;
            const largestMazeDim = 25;
            floorTexture.repeat.set(largestMazeDim * repeatsPerMazeTile, largestMazeDim * repeatsPerMazeTile);

            floorMaterial = new THREE.MeshStandardMaterial({
                map: floorTexture,
                roughness: 0.8,
                metalness: 0.1
            });

            landmarkMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(getComputedStyle(document.body).getPropertyValue('--landmark-color')),
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const goalTexture = textureLoader.load('http://googleusercontent.com/file_content/1');
            goalTexture.wrapS = THREE.RepeatWrapping;
            goalTexture.wrapT = THREE.RepeatWrapping;
            goalTexture.repeat.set(1, 1);
            goalWallMaterial = new THREE.MeshStandardMaterial({
                map: goalTexture,
                roughness: 0.7,
                metalness: 0.1
            });
        }

        // ====================================================================
        // 小地图 (Minimap)
        // ====================================================================

        let lastPlayerGridPos = { x: -1, z: -1 };

        function drawMinimapBackground(grid, start, goal) {
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;
            const canvas = minimap;
            canvas.width = 500;
            canvas.height = 500;
            const ctx = minimapCtx;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cellWidth = canvas.width / gridWidth;
            const cellHeight = canvas.height / gridHeight;

            for (let z = 0; z < gridHeight; z++) {
                for (let x = 0; x < gridWidth; x++) {
                    const xPos = x * cellWidth;
                    const yPos = z * cellHeight;
                    
                    if (grid[z][x] === 0) { // Wall
                        const wallGradient = ctx.createLinearGradient(xPos, yPos, xPos + cellWidth, yPos + cellHeight);
                        wallGradient.addColorStop(0, "#555");
                        wallGradient.addColorStop(0.5, "#222");
                        wallGradient.addColorStop(1, "#555");
                        ctx.fillStyle = wallGradient;
                    } else { // Path
                        const pathGradient = ctx.createLinearGradient(xPos, yPos, xPos + cellWidth, yPos + cellHeight);
                        pathGradient.addColorStop(0, "#eee");
                        pathGradient.addColorStop(0.5, "#fff");
                        pathGradient.addColorStop(1, "#eee");
                        ctx.fillStyle = pathGradient;
                    }
                    ctx.fillRect(xPos, yPos, cellWidth, cellHeight);
                }
            }

            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--start-color');
            ctx.fillRect(start.x * cellWidth, start.z * cellHeight, cellWidth, cellHeight);
            
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--goal-color');
            ctx.fillRect(goal.x * cellWidth, goal.z * cellHeight, cellWidth, cellHeight);
        }

        function updateMinimapPlayer() {
            const level = (currentLevelIndex === -1) ? customLevels[selectedCustomMapIndex] : levels[currentLevelIndex];
            if (!level) return;
            const { grid, start, goal } = level;
            const gridPos = worldToGrid(player.position);
            
            lastPlayerGridPos = { ...gridPos };

            drawMinimapBackground(grid, start, goal);

            const ctx = minimapCtx;
            const gridWidth = grid[0].length;
            const gridHeight = grid.length;
            const cellWidth = ctx.canvas.width / gridWidth;
            const cellHeight = ctx.canvas.height / gridHeight;

            const playerX = (gridPos.x + 0.5) * cellWidth;
            const playerZ = (gridPos.z + 0.5) * cellHeight;

            ctx.save();
            const dirVec = new THREE.Vector3(0, 0, -1).applyEuler(player.rotation);
            const angle = Math.atan2(dirVec.z, dirVec.x);
            ctx.translate(playerX, playerZ);
            ctx.rotate(angle);
            const size = Math.min(cellWidth, cellHeight) * 1.2; 
            const half = size * 0.5;
            const tail = -half * 0.8; 
            
            ctx.beginPath();
            ctx.moveTo(half, 0);
            ctx.lineTo(tail, -half * 0.6); 
            ctx.lineTo(tail,  half * 0.6); 
            ctx.closePath();
            
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, half);
            gradient.addColorStop(0, '#ff8080');
            gradient.addColorStop(1, '#c00000');
            
            ctx.fillStyle = gradient;
            ctx.shadowColor = 'rgba(255, 0, 0, 0.9)';
            ctx.shadowBlur = size * 0.7;

            ctx.fill();
            
            ctx.lineWidth = Math.max(2, size * 0.1); 
            ctx.strokeStyle = '#006400'; // Dark Green
            ctx.stroke();
            ctx.restore();
        }

        // ====================================================================
        // 寻路算法 (Pathfinding - BFS) for step counting
        // ====================================================================

        function getNeighbors(x, z, grid) {
            const neighbors = [];
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dx, dz] of dirs) {
                const newX = x + dx;
                const newZ = z + dz;
                if (newZ >= 0 && newZ < grid.length && newX >= 0 && newX < grid[0].length && grid[newZ][newX] === 1) {
                    neighbors.push({ x: newX, z: newZ });
                }
            }
            return neighbors;
        }

        function findShortestPath(level) {
            const { grid, start, goal } = level;
            if (!start.hasOwnProperty('x') || !goal.hasOwnProperty('x')) return null;
            const queue = [{ x: start.x, z: start.z, path: [] }];
            const visited = new Set([`${start.x},${start.z}`]);

            while (queue.length > 0) {
                const { x, z, path } = queue.shift();

                if (x === goal.x && z === goal.z) {
                    return { path, choices: path.length };
                }

                const neighbors = getNeighbors(x, z, grid);
                for (const neighbor of neighbors) {
                    const key = `${neighbor.x},${neighbor.z}`;
                    if (!visited.has(key)) {
                        visited.add(key);
                        const newPath = path.concat([{x, z}]);
                        queue.push({ ...neighbor, path: newPath });
                    }
                }
            }
            return null;
        }
        
        // ====================================================================
        // 菜单与UI逻辑 (Menu & UI Logic)
        // ====================================================================
        
        function updateHUD() {
            const mapViewCountEl = document.getElementById('map-view-count');
            if (navigationMode === 'limited') {
                mapViewCountEl.style.display = 'block';
                mapViewCountEl.textContent = `${translations[currentLanguage].mapChances}: ${mapViewChances}`;
            } else {
                mapViewCountEl.style.display = 'none';
            }
        }
        
        function updateUIText() {
            document.querySelectorAll('[data-lang-zh]').forEach(el => {
                const key = currentLanguage === 'zh' ? 'langZh' : 'langEn';
                if (el.dataset[key]) {
                    el.textContent = el.dataset[key];
                }
            });
             document.querySelectorAll('select').forEach(select => {
                select.querySelectorAll('option').forEach(option => {
                    const key = currentLanguage === 'zh' ? 'langZh' : 'langEn';
                    if (option.dataset[key]) {
                        option.textContent = option.dataset[key];
                    }
                });
            });
            document.querySelectorAll('[data-lang-placeholder-zh]').forEach(el => {
                const key = currentLanguage === 'zh' ? 'langPlaceholderZh' : 'langPlaceholderEn';
                 if (el.dataset[key]) {
                    el.placeholder = el.dataset[key];
                }
            });
            
            const welcomeMsg = document.getElementById('welcome-message');
            if (welcomeMsg) {
                welcomeMsg.textContent = translations[currentLanguage].welcome(playerInfo.nickname);
            }
            if (gameState === 'AT_INTERSECTION') {
                updateChoicePrompt();
            }
            if (document.getElementById('dev-panel').style.display === 'block') {
                setupDevPanel();
            }
            updateHUD();
        }

        function togglePauseMenu() {
            const menu = document.getElementById('pause-menu-modal');
            const isPaused = menu.style.display === 'flex';

            if (isPaused) {
                menu.style.display = 'none';
                gameState = previousGameState;
            } else {
                if(!['AT_INTERSECTION', 'DRIVING', 'TURNING', 'BIG_MAP'].includes(gameState)) return;
                previousGameState = gameState;
                gameState = 'PAUSED';
                menu.style.display = 'flex';
            }
        }
        
        function toggleChallengeMap() {
            const container = document.getElementById('minimap-container');
            const isMapViewVisible = container.style.display === 'block' && gameState === 'CHALLENGE_MAP_VIEW';

            if (isMapViewVisible) {
                // Hide map
                container.style.display = 'none';
                gameState = previousGameState;
            } else if (['AT_INTERSECTION', 'DRIVING', 'TURNING'].includes(gameState) && mapViewChances > 0) {
                // Show map
                mapViewChances--;
                updateHUD();
                previousGameState = gameState;
                gameState = 'CHALLENGE_MAP_VIEW';
                container.classList.remove('small-map');
                container.classList.add('big-map');
                container.style.display = 'block';
                renderer.render(scene, camera); // Render one frame of the map
            }
        }

        function showLevelSelectModal() {
            const grid = document.getElementById('level-select-grid');
            grid.innerHTML = '';
            
            const levelCount = (gameMode === 'custom') ? customLevels.filter(l=>l).length : levels.length;
            
            for (let i = 0; i < levelCount; i++) {
                const button = document.createElement('button');
                button.textContent = i + 1;
                const isUnlocked = gameMode !== 'campaign' || i <= unlockedLevel;
                button.disabled = !isUnlocked;
                if (isUnlocked) {
                    button.onclick = () => {
                        document.getElementById('level-select-modal').style.display = 'none';
                        togglePauseMenu();
                        loadLevel(gameMode === 'custom' ? customLevels[i] : i);
                    };
                }
                grid.appendChild(button);
            }

            document.getElementById('pause-menu-modal').style.display = 'none';
            document.getElementById('level-select-modal').style.display = 'flex';
        }

        function resetGame() {
            unlockedLevel = 0;
            playerInfo = { nickname: 'Driver', gender: 'other' };
            document.getElementById('nickname-input').value = '';
            
            const modals = document.querySelectorAll('.modal-overlay');
            modals.forEach(modal => {
                if (modal.id !== 'startup-modal') {
                    modal.style.display = 'none';
                }
            });
            
            document.getElementById('startup-modal').style.display = 'flex';
            gameState = 'STARTUP_MODAL';
            updateUIText();
        }
        
        // ====================================================================
        // 地图编辑器 (Map Editor) & Custom Maps
        // ====================================================================
        
        let editorGridData = [];
        let editorStart = {};
        let editorGoal = {};
        let currentTool = 'wall';
        let isDrawing = false;
        let selectedCustomMapIndex = 0;
        const EDITOR_SIZE = 17;
        const MAX_CUSTOM_LEVELS = 15;

        function loadCustomLevels() {
            const savedLevels = localStorage.getItem('customMazeLevels');
            if (savedLevels) {
                customLevels = JSON.parse(savedLevels);
            } else {
                customLevels = new Array(MAX_CUSTOM_LEVELS).fill(null);
            }
        }

        function saveCustomLevels() {
            localStorage.setItem('customMazeLevels', JSON.stringify(customLevels));
        }

        function showEditor(slotIndex = 0) {
            document.getElementById('main-menu-modal').style.display = 'none';
            document.getElementById('custom-maps-modal').style.display = 'none';
            document.getElementById('editor-modal').style.display = 'flex';
            initEditor(slotIndex);
        }

        function initEditor(slotIndex) {
            const grid = document.getElementById('editor-grid');
            const slotSelect = document.getElementById('editor-slot-select');
            grid.innerHTML = '';
            slotSelect.innerHTML = '';
            
            for (let i = 0; i < MAX_CUSTOM_LEVELS; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${translations[currentLanguage].map_slot} ${i + 1}` + (customLevels[i] ? '' : ` (${translations[currentLanguage].empty_slot})`);
                slotSelect.appendChild(option);
            }
            slotSelect.value = slotIndex;
            
            slotSelect.onchange = () => {
                initEditor(parseInt(slotSelect.value));
            };

            loadEditorGrid(slotIndex);
            
            grid.onmousedown = (e) => {
                isDrawing = true;
                handleGridInteraction(e);
            };
            grid.onmouseover = handleGridInteraction;
            document.onmouseup = () => isDrawing = false;
            grid.onmouseleave = () => isDrawing = false; // Stop drawing if mouse leaves grid

            document.getElementById('editor-toolbar').onclick = (e) => {
                if (e.target.tagName === 'BUTTON') {
                    currentTool = e.target.dataset.tool;
                    document.querySelectorAll('#editor-toolbar button').forEach(b => b.classList.remove('selected'));
                    e.target.classList.add('selected');
                }
            };
            
            document.getElementById('tool-wall').classList.add('selected');
            document.getElementById('editor-save-btn').onclick = saveCustomMap;
            document.getElementById('editor-delete-btn').onclick = deleteCustomMap;
            document.getElementById('editor-back-btn').onclick = () => {
                 document.getElementById('editor-modal').style.display = 'none';
                 showMainMenu();
            };
        }
        
        function loadEditorGrid(slotIndex) {
            const grid = document.getElementById('editor-grid');
            grid.innerHTML = '';
            editorGridData = [];
            editorStart = {};
            editorGoal = {};
            
            const levelToLoad = customLevels[slotIndex];

            for (let z = 0; z < EDITOR_SIZE; z++) {
                const row = [];
                for (let x = 0; x < EDITOR_SIZE; x++) {
                    let cellType = 0; // 0 for path
                    if (levelToLoad) {
                        cellType = levelToLoad.grid[z][x] === 0 ? 1 : 0; // Convert back: 0->wall, 1->path
                        if (levelToLoad.start.x === x && levelToLoad.start.z === z) editorStart = {x, z};
                        if (levelToLoad.goal.x === x && levelToLoad.goal.z === z) editorGoal = {x, z};
                    } else {
                        const isBorder = x === 0 || x === EDITOR_SIZE - 1 || z === 0 || z === EDITOR_SIZE - 1;
                        if (isBorder) cellType = 1; // 1 for wall
                    }
                    
                    row.push(cellType);
                    const cell = document.createElement('div');
                    cell.classList.add('editor-cell');
                    cell.dataset.x = x;
                    cell.dataset.z = z;
                    
                    if(editorStart.x === x && editorStart.z === z) cell.classList.add('start');
                    else if(editorGoal.x === x && editorGoal.z === z) cell.classList.add('goal');
                    else cell.classList.toggle('wall', cellType === 1);
                    
                    grid.appendChild(cell);
                }
                editorGridData.push(row);
            }
        }
        
        function handleGridInteraction(e) {
            if (!isDrawing || e.buttons !== 1) return;
            
            const cell = e.target;
            if (!cell.classList.contains('editor-cell')) return;
            
            const x = parseInt(cell.dataset.x);
            const z = parseInt(cell.dataset.z);
            const grid = document.getElementById('editor-grid');

            // Clear previous start/goal if they exist on this cell
            if (editorStart.x === x && editorStart.z === z) editorStart = {};
            if (editorGoal.x === x && editorGoal.z === z) editorGoal = {};
            
            // Clear old visual if placing a new start/goal
            if (currentTool === 'start' && editorStart.x !== undefined) {
                 grid.children[editorStart.z * EDITOR_SIZE + editorStart.x].className = 'editor-cell path';
                 editorGridData[editorStart.z][editorStart.x] = 0;
            }
            if (currentTool === 'goal' && editorGoal.x !== undefined) {
                 grid.children[editorGoal.z * EDITOR_SIZE + editorGoal.x].className = 'editor-cell path';
                 editorGridData[editorGoal.z][editorGoal.x] = 0;
            }

            switch (currentTool) {
                case 'wall':
                    editorGridData[z][x] = 1;
                    cell.className = 'editor-cell wall';
                    break;
                case 'path':
                    editorGridData[z][x] = 0;
                    cell.className = 'editor-cell path';
                    break;
                case 'start':
                    editorGridData[z][x] = 0; // Start must be on a path
                    editorStart = { x, z };
                    cell.className = 'editor-cell start';
                    isDrawing = false; // only place one at a time
                    break;
                case 'goal':
                    editorGridData[z][x] = 0; // Goal must be on a path
                    editorGoal = { x, z };
                    cell.className = 'editor-cell goal';
                    isDrawing = false; // only place one at a time
                    break;
            }
        }
        
        function saveCustomMap() {
            const messageEl = document.getElementById('editor-message');
            messageEl.textContent = '';
            const slotIndex = parseInt(document.getElementById('editor-slot-select').value);

            if (!editorStart.hasOwnProperty('x')) {
                messageEl.textContent = translations[currentLanguage].editor_need_start;
                return;
            }
            if (!editorGoal.hasOwnProperty('x')) {
                messageEl.textContent = translations[currentLanguage].editor_need_goal;
                return;
            }

            const mazeDataForSolver = editorGridData.map(row => row.map(cell => cell === 1 ? 0 : 1));

            const tempLevel = { grid: mazeDataForSolver, start: editorStart, goal: editorGoal };

            if (!findShortestPath(tempLevel)) {
                messageEl.textContent = translations[currentLanguage].editor_unsolvable;
                return;
            }
            
            const newLevel = {
                grid: mazeDataForSolver,
                start: { ...editorStart, dir: 'S' }, // Default dir
                goal: { ...editorGoal }
            };
            
            if (newLevel.start.x === 0) newLevel.start.dir = 'E';
            else if (newLevel.start.x === EDITOR_SIZE - 1) newLevel.start.dir = 'W';
            else if (newLevel.start.z === 0) newLevel.start.dir = 'S';
            else if (newLevel.start.z === EDITOR_SIZE - 1) newLevel.start.dir = 'N';

            customLevels[slotIndex] = newLevel;
            saveCustomLevels();
            
            // Update dropdown text
            const option = document.getElementById('editor-slot-select').options[slotIndex];
            option.textContent = `${translations[currentLanguage].map_slot} ${slotIndex + 1}`;
            
            messageEl.textContent = `${translations[currentLanguage].map_slot} ${slotIndex + 1} 已保存!`;
            messageEl.style.color = 'green';
            setTimeout(() => {
                messageEl.textContent = '';
                messageEl.style.color = 'red';
            }, 2000);
        }
        
        function deleteCustomMap() {
            const slotIndex = parseInt(document.getElementById('editor-slot-select').value);
            if (customLevels[slotIndex] && confirm(translations[currentLanguage].confirm_delete)) {
                customLevels[slotIndex] = null;
                saveCustomLevels();
                initEditor(slotIndex); // Reload editor for this slot
            }
        }
        
        function showCustomMapsModal() {
            document.getElementById('main-menu-modal').style.display = 'none';
            document.getElementById('custom-maps-modal').style.display = 'flex';
            const grid = document.getElementById('custom-maps-grid');
            grid.innerHTML = '';
            selectedCustomMapIndex = -1;
            
            document.getElementById('custom-play-btn').disabled = true;
            document.getElementById('custom-edit-btn').disabled = true;
            document.getElementById('custom-delete-btn').disabled = true;

            for (let i = 0; i < MAX_CUSTOM_LEVELS; i++) {
                const button = document.createElement('button');
                button.dataset.index = i;
                if (customLevels[i]) {
                    button.textContent = `${translations[currentLanguage].map_slot} ${i + 1}`;
                } else {
                    button.textContent = `${i + 1} (${translations[currentLanguage].empty_slot})`;
                    button.disabled = true;
                }
                grid.appendChild(button);
            }
            
            grid.onclick = (e) => {
                if (e.target.tagName === 'BUTTON' && !e.target.disabled) {
                    document.querySelectorAll('#custom-maps-grid button').forEach(b => b.classList.remove('selected'));
                    e.target.classList.add('selected');
                    selectedCustomMapIndex = parseInt(e.target.dataset.index);
                    document.getElementById('custom-play-btn').disabled = false;
                    document.getElementById('custom-edit-btn').disabled = false;
                    document.getElementById('custom-delete-btn').disabled = false;
                }
            };
            
            document.getElementById('custom-play-btn').onclick = () => {
                if(selectedCustomMapIndex !== -1) {
                    document.getElementById('custom-maps-modal').style.display = 'none';
                    document.getElementById('mode-select-modal').style.display = 'flex';
                }
            };
            document.getElementById('custom-edit-btn').onclick = () => {
                if(selectedCustomMapIndex !== -1) showEditor(selectedCustomMapIndex);
            };
            document.getElementById('custom-delete-btn').onclick = () => {
                if(selectedCustomMapIndex !== -1 && confirm(translations[currentLanguage].confirm_delete)) {
                    customLevels[selectedCustomMapIndex] = null;
                    saveCustomLevels();
                    showCustomMapsModal(); // Refresh
                }
            };
            document.getElementById('custom-back-btn').onclick = () => {
                document.getElementById('custom-maps-modal').style.display = 'none';
                showMainMenu();
            };
        }
        
        // ====================================================================
        // 启动 (Boot)
        // ====================================================================
        init();

    </script>
</body>
</html>
